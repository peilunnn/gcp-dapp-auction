{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nvar constants_1 = require(\"../constants\");\nvar errors = __importStar(require(\"../errors\"));\nvar address_1 = require(\"./address\");\nvar bignumber_1 = require(\"./bignumber\");\nvar bytes_1 = require(\"./bytes\");\nvar utf8_1 = require(\"./utf8\");\nvar properties_1 = require(\"./properties\");\n///////////////////////////////\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexports.defaultCoerceFunc = function (type, value) {\n  var match = type.match(paramTypeNumber);\n  if (match && parseInt(match[2]) <= 48) {\n    return value.toNumber();\n  }\n  return value;\n};\n///////////////////////////////////\n// Parsing for Solidity Signatures\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = 'uint256' + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = 'int256' + type.substring(3);\n  }\n  return type;\n}\nfunction parseParam(param, allowIndexed) {\n  var originalParam = param;\n  function throwError(i) {\n    throw new Error('unexpected character \"' + originalParam[i] + '\" at position ' + i + ' in \"' + originalParam + '\"');\n  }\n  param = param.replace(/\\s/g, ' ');\n  var parent = {\n    type: '',\n    name: '',\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n    switch (c) {\n      case '(':\n        if (!node.state.allowParams) {\n          throwError(i);\n        }\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [{\n          type: '',\n          name: '',\n          parent: node,\n          state: {\n            allowType: true\n          }\n        }];\n        node = node.components[0];\n        break;\n      case ')':\n        delete node.state;\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n        node.type = verifyType(node.type);\n        var child = node;\n        node = node.parent;\n        if (!node) {\n          throwError(i);\n        }\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n      case ',':\n        delete node.state;\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n        node.type = verifyType(node.type);\n        var sibling = {\n          type: '',\n          name: '',\n          parent: node.parent,\n          state: {\n            allowType: true\n          }\n        };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n      case ' ':\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== '') {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        }\n        // If reading name, the name is done\n        if (node.state.allowName) {\n          if (node.name !== '') {\n            if (allowIndexed && node.name === 'indexed') {\n              node.indexed = true;\n              node.name = '';\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n        break;\n      case '[':\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n      case ']':\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n    }\n  }\n  if (node.parent) {\n    throw new Error(\"unexpected eof\");\n  }\n  delete parent.state;\n  if (allowIndexed && node.name === 'indexed') {\n    node.indexed = true;\n    node.name = '';\n  }\n  parent.type = verifyType(parent.type);\n  return parent;\n}\n// @TODO: Better return type\nfunction parseSignatureEvent(fragment) {\n  var abi = {\n    anonymous: false,\n    inputs: [],\n    name: '',\n    type: 'event'\n  };\n  var match = fragment.match(regexParen);\n  if (!match) {\n    throw new Error('invalid event: ' + fragment);\n  }\n  abi.name = match[1].trim();\n  splitNesting(match[2]).forEach(function (param) {\n    param = parseParam(param, true);\n    param.indexed = !!param.indexed;\n    abi.inputs.push(param);\n  });\n  match[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'anonymous':\n        abi.anonymous = true;\n        break;\n      case '':\n        break;\n      default:\n        errors.info('unknown modifier: ' + modifier);\n    }\n  });\n  if (abi.name && !abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + abi.name + '\"');\n  }\n  return abi;\n}\nfunction parseSignatureFunction(fragment) {\n  var abi = {\n    constant: false,\n    gas: null,\n    inputs: [],\n    name: '',\n    outputs: [],\n    payable: false,\n    stateMutability: null,\n    type: 'function'\n  };\n  var comps = fragment.split('@');\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      throw new Error('invalid signature');\n    }\n    if (!comps[1].match(/^[0-9]+$/)) {\n      throw new Error('invalid signature gas');\n    }\n    abi.gas = bignumber_1.bigNumberify(comps[1]);\n    fragment = comps[0];\n  }\n  comps = fragment.split(' returns ');\n  var left = comps[0].match(regexParen);\n  if (!left) {\n    throw new Error('invalid signature');\n  }\n  abi.name = left[1].trim();\n  if (!abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + left[1] + '\"');\n  }\n  splitNesting(left[2]).forEach(function (param) {\n    abi.inputs.push(parseParam(param));\n  });\n  left[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'constant':\n        abi.constant = true;\n        break;\n      case 'payable':\n        abi.payable = true;\n        abi.stateMutability = 'payable';\n        break;\n      case 'pure':\n        abi.constant = true;\n        abi.stateMutability = 'pure';\n        break;\n      case 'view':\n        abi.constant = true;\n        abi.stateMutability = 'view';\n        break;\n      case 'external':\n      case 'public':\n      case '':\n        break;\n      default:\n        errors.info('unknown modifier: ' + modifier);\n    }\n  });\n  // We have outputs\n  if (comps.length > 1) {\n    var right = comps[1].match(regexParen);\n    if (right[1].trim() != '' || right[3].trim() != '') {\n      throw new Error('unexpected tokens');\n    }\n    splitNesting(right[2]).forEach(function (param) {\n      abi.outputs.push(parseParam(param));\n    });\n  }\n  if (abi.name === 'constructor') {\n    abi.type = \"constructor\";\n    if (abi.outputs.length) {\n      throw new Error('constructor may not have outputs');\n    }\n    delete abi.name;\n    delete abi.outputs;\n  }\n  return abi;\n}\nfunction parseParamType(type) {\n  return parseParam(type, true);\n}\nexports.parseParamType = parseParamType;\n// @TODO: Allow a second boolean to expose names\nfunction formatParamType(paramType) {\n  return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\nexports.formatParamType = formatParamType;\n// @TODO: Allow a second boolean to expose names and modifiers\nfunction formatSignature(fragment) {\n  return fragment.name + '(' + fragment.inputs.map(function (i) {\n    return formatParamType(i);\n  }).join(',') + ')';\n}\nexports.formatSignature = formatSignature;\nfunction parseSignature(fragment) {\n  if (typeof fragment === 'string') {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    fragment = fragment.replace(/\\s/g, ' ');\n    fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n    fragment = fragment.trim();\n    if (fragment.substring(0, 6) === 'event ') {\n      return parseSignatureEvent(fragment.substring(6).trim());\n    } else {\n      if (fragment.substring(0, 9) === 'function ') {\n        fragment = fragment.substring(9);\n      }\n      return parseSignatureFunction(fragment.trim());\n    }\n  }\n  throw new Error('unknown signature');\n}\nexports.parseSignature = parseSignature;\nvar Coder = /** @class */function () {\n  function Coder(coerceFunc, name, type, localName, dynamic) {\n    this.coerceFunc = coerceFunc;\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n  return Coder;\n}();\n// Clones the functionality of an existing Coder, but without a localName\nvar CoderAnonymous = /** @class */function (_super) {\n  __extends(CoderAnonymous, _super);\n  function CoderAnonymous(coder) {\n    var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n    properties_1.defineReadOnly(_this, 'coder', coder);\n    return _this;\n  }\n  CoderAnonymous.prototype.encode = function (value) {\n    return this.coder.encode(value);\n  };\n  CoderAnonymous.prototype.decode = function (data, offset) {\n    return this.coder.decode(data, offset);\n  };\n  return CoderAnonymous;\n}(Coder);\nvar CoderNull = /** @class */function (_super) {\n  __extends(CoderNull, _super);\n  function CoderNull(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n  }\n  CoderNull.prototype.encode = function (value) {\n    return bytes_1.arrayify([]);\n  };\n  CoderNull.prototype.decode = function (data, offset) {\n    if (offset > data.length) {\n      throw new Error('invalid null');\n    }\n    return {\n      consumed: 0,\n      value: this.coerceFunc('null', undefined)\n    };\n  };\n  return CoderNull;\n}(Coder);\nvar CoderNumber = /** @class */function (_super) {\n  __extends(CoderNumber, _super);\n  function CoderNumber(coerceFunc, size, signed, localName) {\n    var _this = this;\n    var name = (signed ? 'int' : 'uint') + size * 8;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.size = size;\n    _this.signed = signed;\n    return _this;\n  }\n  CoderNumber.prototype.encode = function (value) {\n    try {\n      var v = bignumber_1.bigNumberify(value);\n      if (this.signed) {\n        var bounds = constants_1.MaxUint256.maskn(this.size * 8 - 1);\n        if (v.gt(bounds)) {\n          throw new Error('out-of-bounds');\n        }\n        bounds = bounds.add(constants_1.One).mul(constants_1.NegativeOne);\n        if (v.lt(bounds)) {\n          throw new Error('out-of-bounds');\n        }\n      } else if (v.lt(constants_1.Zero) || v.gt(constants_1.MaxUint256.maskn(this.size * 8))) {\n        throw new Error('out-of-bounds');\n      }\n      v = v.toTwos(this.size * 8).maskn(this.size * 8);\n      if (this.signed) {\n        v = v.fromTwos(this.size * 8).toTwos(256);\n      }\n      return bytes_1.padZeros(bytes_1.arrayify(v), 32);\n    } catch (error) {\n      errors.throwError('invalid number value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: value\n      });\n    }\n    return null;\n  };\n  CoderNumber.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n    var junkLength = 32 - this.size;\n    var value = bignumber_1.bigNumberify(data.slice(offset + junkLength, offset + 32));\n    if (this.signed) {\n      value = value.fromTwos(this.size * 8);\n    } else {\n      value = value.maskn(this.size * 8);\n    }\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, value)\n    };\n  };\n  return CoderNumber;\n}(Coder);\nvar uint256Coder = new CoderNumber(function (type, value) {\n  return value;\n}, 32, false, 'none');\nvar CoderBoolean = /** @class */function (_super) {\n  __extends(CoderBoolean, _super);\n  function CoderBoolean(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n  }\n  CoderBoolean.prototype.encode = function (value) {\n    return uint256Coder.encode(!!value ? 1 : 0);\n  };\n  CoderBoolean.prototype.decode = function (data, offset) {\n    try {\n      var result = uint256Coder.decode(data, offset);\n    } catch (error) {\n      if (error.reason === 'insufficient data for uint256 type') {\n        errors.throwError('insufficient data for boolean type', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'boolean',\n          value: error.value\n        });\n      }\n      throw error;\n    }\n    return {\n      consumed: result.consumed,\n      value: this.coerceFunc('bool', !result.value.isZero())\n    };\n  };\n  return CoderBoolean;\n}(Coder);\nvar CoderFixedBytes = /** @class */function (_super) {\n  __extends(CoderFixedBytes, _super);\n  function CoderFixedBytes(coerceFunc, length, localName) {\n    var _this = this;\n    var name = 'bytes' + length;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.length = length;\n    return _this;\n  }\n  CoderFixedBytes.prototype.encode = function (value) {\n    var result = new Uint8Array(32);\n    try {\n      var data = bytes_1.arrayify(value);\n      if (data.length !== this.length) {\n        throw new Error('incorrect data length');\n      }\n      result.set(data);\n    } catch (error) {\n      errors.throwError('invalid ' + this.name + ' value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: error.value || value\n      });\n    }\n    return result;\n  };\n  CoderFixedBytes.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, bytes_1.hexlify(data.slice(offset, offset + this.length)))\n    };\n  };\n  return CoderFixedBytes;\n}(Coder);\nvar CoderAddress = /** @class */function (_super) {\n  __extends(CoderAddress, _super);\n  function CoderAddress(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n  }\n  CoderAddress.prototype.encode = function (value) {\n    var result = new Uint8Array(32);\n    try {\n      result.set(bytes_1.arrayify(address_1.getAddress(value)), 12);\n    } catch (error) {\n      errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: value\n      });\n    }\n    return result;\n  };\n  CoderAddress.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for address type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n    return {\n      consumed: 32,\n      value: this.coerceFunc('address', address_1.getAddress(bytes_1.hexlify(data.slice(offset + 12, offset + 32))))\n    };\n  };\n  return CoderAddress;\n}(Coder);\nfunction _encodeDynamicBytes(value) {\n  var dataLength = 32 * Math.ceil(value.length / 32);\n  var padding = new Uint8Array(dataLength - value.length);\n  return bytes_1.concat([uint256Coder.encode(value.length), value, padding]);\n}\nfunction _decodeDynamicBytes(data, offset, localName) {\n  if (data.length < offset + 32) {\n    errors.throwError('insufficient data for dynamicBytes length', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: bytes_1.hexlify(data.slice(offset, offset + 32))\n    });\n  }\n  var length = uint256Coder.decode(data, offset).value;\n  try {\n    length = length.toNumber();\n  } catch (error) {\n    errors.throwError('dynamic bytes count too large', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: length.toString()\n    });\n  }\n  if (data.length < offset + 32 + length) {\n    errors.throwError('insufficient data for dynamicBytes type', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: bytes_1.hexlify(data.slice(offset, offset + 32 + length))\n    });\n  }\n  return {\n    consumed: 32 + 32 * Math.ceil(length / 32),\n    value: data.slice(offset + 32, offset + 32 + length)\n  };\n}\nvar CoderDynamicBytes = /** @class */function (_super) {\n  __extends(CoderDynamicBytes, _super);\n  function CoderDynamicBytes(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n  }\n  CoderDynamicBytes.prototype.encode = function (value) {\n    try {\n      return _encodeDynamicBytes(bytes_1.arrayify(value));\n    } catch (error) {\n      errors.throwError('invalid bytes value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'bytes',\n        value: error.value\n      });\n    }\n    return null;\n  };\n  CoderDynamicBytes.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName);\n    result.value = this.coerceFunc('bytes', bytes_1.hexlify(result.value));\n    return result;\n  };\n  return CoderDynamicBytes;\n}(Coder);\nvar CoderString = /** @class */function (_super) {\n  __extends(CoderString, _super);\n  function CoderString(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n  }\n  CoderString.prototype.encode = function (value) {\n    if (typeof value !== 'string') {\n      errors.throwError('invalid string value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'string',\n        value: value\n      });\n    }\n    return _encodeDynamicBytes(utf8_1.toUtf8Bytes(value));\n  };\n  CoderString.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName);\n    result.value = this.coerceFunc('string', utf8_1.toUtf8String(result.value));\n    return result;\n  };\n  return CoderString;\n}(Coder);\nfunction alignSize(size) {\n  return 32 * Math.ceil(size / 32);\n}\nfunction pack(coders, values) {\n  if (Array.isArray(values)) {\n    // do nothing\n  } else if (values && typeof values === 'object') {\n    var arrayValues = [];\n    coders.forEach(function (coder) {\n      arrayValues.push(values[coder.localName]);\n    });\n    values = arrayValues;\n  } else {\n    errors.throwError('invalid tuple value', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n  if (coders.length !== values.length) {\n    errors.throwError('types/value length mismatch', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n  var parts = [];\n  coders.forEach(function (coder, index) {\n    parts.push({\n      dynamic: coder.dynamic,\n      value: coder.encode(values[index])\n    });\n  });\n  var staticSize = 0,\n    dynamicSize = 0;\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      staticSize += 32;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length);\n    }\n  });\n  var offset = 0,\n    dynamicOffset = staticSize;\n  var data = new Uint8Array(staticSize + dynamicSize);\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      //uint256Coder.encode(dynamicOffset).copy(data, offset);\n      data.set(uint256Coder.encode(dynamicOffset), offset);\n      offset += 32;\n      //part.value.copy(data, dynamicOffset);  @TODO\n      data.set(part.value, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      //part.value.copy(data, offset);  @TODO\n      data.set(part.value, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n  return data;\n}\nfunction unpack(coders, data, offset) {\n  var baseOffset = offset;\n  var consumed = 0;\n  var value = [];\n  coders.forEach(function (coder) {\n    if (coder.dynamic) {\n      var dynamicOffset = uint256Coder.decode(data, offset);\n      var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber());\n      // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n      result.consumed = dynamicOffset.consumed;\n    } else {\n      var result = coder.decode(data, offset);\n    }\n    if (result.value != undefined) {\n      value.push(result.value);\n    }\n    offset += result.consumed;\n    consumed += result.consumed;\n  });\n  coders.forEach(function (coder, index) {\n    var name = coder.localName;\n    if (!name) {\n      return;\n    }\n    if (name === 'length') {\n      name = '_length';\n    }\n    if (value[name] != null) {\n      return;\n    }\n    value[name] = value[index];\n  });\n  return {\n    value: value,\n    consumed: consumed\n  };\n}\nvar CoderArray = /** @class */function (_super) {\n  __extends(CoderArray, _super);\n  function CoderArray(coerceFunc, coder, length, localName) {\n    var _this = this;\n    var type = coder.type + '[' + (length >= 0 ? length : '') + ']';\n    var dynamic = length === -1 || coder.dynamic;\n    _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n    _this.coder = coder;\n    _this.length = length;\n    return _this;\n  }\n  CoderArray.prototype.encode = function (value) {\n    if (!Array.isArray(value)) {\n      errors.throwError('expected array value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'array',\n        value: value\n      });\n    }\n    var count = this.length;\n    var result = new Uint8Array(0);\n    if (count === -1) {\n      count = value.length;\n      result = uint256Coder.encode(count);\n    }\n    errors.checkArgumentCount(count, value.length, ' in coder array' + (this.localName ? \" \" + this.localName : \"\"));\n    var coders = [];\n    for (var i = 0; i < value.length; i++) {\n      coders.push(this.coder);\n    }\n    return bytes_1.concat([result, pack(coders, value)]);\n  };\n  CoderArray.prototype.decode = function (data, offset) {\n    // @TODO:\n    //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n    var consumed = 0;\n    var count = this.length;\n    if (count === -1) {\n      try {\n        var decodedLength = uint256Coder.decode(data, offset);\n      } catch (error) {\n        errors.throwError('insufficient data for dynamic array length', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: error.value\n        });\n      }\n      try {\n        count = decodedLength.value.toNumber();\n      } catch (error) {\n        errors.throwError('array count too large', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: decodedLength.value.toString()\n        });\n      }\n      consumed += decodedLength.consumed;\n      offset += decodedLength.consumed;\n    }\n    var coders = [];\n    for (var i = 0; i < count; i++) {\n      coders.push(new CoderAnonymous(this.coder));\n    }\n    var result = unpack(coders, data, offset);\n    result.consumed += consumed;\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n  return CoderArray;\n}(Coder);\nvar CoderTuple = /** @class */function (_super) {\n  __extends(CoderTuple, _super);\n  function CoderTuple(coerceFunc, coders, localName) {\n    var _this = this;\n    var dynamic = false;\n    var types = [];\n    coders.forEach(function (coder) {\n      if (coder.dynamic) {\n        dynamic = true;\n      }\n      types.push(coder.type);\n    });\n    var type = 'tuple(' + types.join(',') + ')';\n    _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n    _this.coders = coders;\n    return _this;\n  }\n  CoderTuple.prototype.encode = function (value) {\n    return pack(this.coders, value);\n  };\n  CoderTuple.prototype.decode = function (data, offset) {\n    var result = unpack(this.coders, data, offset);\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n  return CoderTuple;\n}(Coder);\n/*\nfunction getTypes(coders) {\n    var type = coderTuple(coders).type;\n    return type.substring(6, type.length - 1);\n}\n*/\nfunction splitNesting(value) {\n  value = value.trim();\n  var result = [];\n  var accum = '';\n  var depth = 0;\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n    if (c === ',' && depth === 0) {\n      result.push(accum);\n      accum = '';\n    } else {\n      accum += c;\n      if (c === '(') {\n        depth++;\n      } else if (c === ')') {\n        depth--;\n        if (depth === -1) {\n          throw new Error('unbalanced parenthsis');\n        }\n      }\n    }\n  }\n  if (accum) {\n    result.push(accum);\n  }\n  return result;\n}\n// @TODO: Is there a way to return \"class\"?\nvar paramTypeSimple = {\n  address: CoderAddress,\n  bool: CoderBoolean,\n  string: CoderString,\n  bytes: CoderDynamicBytes\n};\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n  if (!components) {\n    components = [];\n  }\n  var coders = [];\n  components.forEach(function (component) {\n    coders.push(getParamCoder(coerceFunc, component));\n  });\n  return new CoderTuple(coerceFunc, coders, localName);\n}\nfunction getParamCoder(coerceFunc, param) {\n  var coder = paramTypeSimple[param.type];\n  if (coder) {\n    return new coder(coerceFunc, param.name);\n  }\n  var match = param.type.match(paramTypeNumber);\n  if (match) {\n    var size = parseInt(match[2] || \"256\");\n    if (size === 0 || size > 256 || size % 8 !== 0) {\n      errors.throwError('invalid ' + match[1] + ' bit length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n    return new CoderNumber(coerceFunc, size / 8, match[1] === 'int', param.name);\n  }\n  var match = param.type.match(paramTypeBytes);\n  if (match) {\n    var size = parseInt(match[1]);\n    if (size === 0 || size > 32) {\n      errors.throwError('invalid bytes length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n    return new CoderFixedBytes(coerceFunc, size, param.name);\n  }\n  var match = param.type.match(paramTypeArray);\n  if (match) {\n    var size = parseInt(match[2] || \"-1\");\n    param = properties_1.shallowCopy(param);\n    param.type = match[1];\n    param = properties_1.deepCopy(param);\n    return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);\n  }\n  if (param.type.substring(0, 5) === 'tuple') {\n    return getTupleParamCoder(coerceFunc, param.components, param.name);\n  }\n  if (param.type === '') {\n    return new CoderNull(coerceFunc, param.name);\n  }\n  errors.throwError('invalid type', errors.INVALID_ARGUMENT, {\n    arg: 'type',\n    value: param.type\n  });\n  return null;\n}\nvar AbiCoder = /** @class */function () {\n  function AbiCoder(coerceFunc) {\n    errors.checkNew(this, AbiCoder);\n    if (!coerceFunc) {\n      coerceFunc = exports.defaultCoerceFunc;\n    }\n    properties_1.defineReadOnly(this, 'coerceFunc', coerceFunc);\n  }\n  AbiCoder.prototype.encode = function (types, values) {\n    if (types.length !== values.length) {\n      errors.throwError('types/values length mismatch', errors.INVALID_ARGUMENT, {\n        count: {\n          types: types.length,\n          values: values.length\n        },\n        value: {\n          types: types,\n          values: values\n        }\n      });\n    }\n    var coders = [];\n    types.forEach(function (type) {\n      // Convert types to type objects\n      //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n      //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n      var typeObject = null;\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = type;\n      }\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    return bytes_1.hexlify(new CoderTuple(this.coerceFunc, coders, '_').encode(values));\n  };\n  AbiCoder.prototype.decode = function (types, data) {\n    var coders = [];\n    types.forEach(function (type) {\n      // See encode for details\n      var typeObject = null;\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = properties_1.deepCopy(type);\n      }\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    return new CoderTuple(this.coerceFunc, coders, '_').decode(bytes_1.arrayify(data), 0).value;\n  };\n  return AbiCoder;\n}();\nexports.AbiCoder = AbiCoder;\nexports.defaultAbiCoder = new AbiCoder();","map":{"version":3,"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","__importStar","mod","__esModule","result","k","call","defineProperty","exports","value","constants_1","require","errors","address_1","bignumber_1","bytes_1","utf8_1","properties_1","paramTypeBytes","RegExp","paramTypeNumber","paramTypeArray","defaultCoerceFunc","type","match","parseInt","toNumber","regexParen","regexIdentifier","verifyType","substring","parseParam","param","allowIndexed","originalParam","throwError","i","Error","replace","parent","name","state","allowType","node","length","c","allowParams","components","indexed","child","allowName","allowArray","sibling","push","readArray","parseSignatureEvent","fragment","abi","anonymous","inputs","trim","splitNesting","forEach","split","modifier","info","parseSignatureFunction","constant","gas","outputs","payable","stateMutability","comps","bigNumberify","left","right","parseParamType","formatParamType","paramType","getParamCoder","formatSignature","map","join","parseSignature","Coder","coerceFunc","localName","dynamic","CoderAnonymous","_super","coder","_this","undefined","defineReadOnly","encode","decode","data","offset","CoderNull","arrayify","consumed","CoderNumber","size","signed","v","bounds","MaxUint256","maskn","gt","add","One","mul","NegativeOne","lt","Zero","toTwos","fromTwos","padZeros","error","INVALID_ARGUMENT","arg","coderType","hexlify","slice","junkLength","uint256Coder","CoderBoolean","reason","isZero","CoderFixedBytes","Uint8Array","set","CoderAddress","getAddress","_encodeDynamicBytes","dataLength","Math","ceil","padding","concat","_decodeDynamicBytes","toString","CoderDynamicBytes","CoderString","toUtf8Bytes","toUtf8String","alignSize","pack","coders","values","isArray","arrayValues","parts","index","staticSize","dynamicSize","part","dynamicOffset","unpack","baseOffset","CoderArray","count","checkArgumentCount","decodedLength","CoderTuple","types","accum","depth","paramTypeSimple","address","bool","string","bytes","getTupleParamCoder","component","shallowCopy","deepCopy","AbiCoder","checkNew","typeObject","defaultAbiCoder"],"sources":["/home/peilunnn/Downloads/Internship Projects/gcp-dapp-auction/client/node_modules/truffle-interface-adapter/node_modules/ethers/utils/abi-coder.js"],"sourcesContent":["'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nvar constants_1 = require(\"../constants\");\nvar errors = __importStar(require(\"../errors\"));\nvar address_1 = require(\"./address\");\nvar bignumber_1 = require(\"./bignumber\");\nvar bytes_1 = require(\"./bytes\");\nvar utf8_1 = require(\"./utf8\");\nvar properties_1 = require(\"./properties\");\n///////////////////////////////\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexports.defaultCoerceFunc = function (type, value) {\n    var match = type.match(paramTypeNumber);\n    if (match && parseInt(match[2]) <= 48) {\n        return value.toNumber();\n    }\n    return value;\n};\n///////////////////////////////////\n// Parsing for Solidity Signatures\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = 'uint256' + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = 'int256' + type.substring(3);\n    }\n    return type;\n}\nfunction parseParam(param, allowIndexed) {\n    var originalParam = param;\n    function throwError(i) {\n        throw new Error('unexpected character \"' + originalParam[i] + '\" at position ' + i + ' in \"' + originalParam + '\"');\n    }\n    param = param.replace(/\\s/g, ' ');\n    var parent = { type: '', name: '', state: { allowType: true } };\n    var node = parent;\n    for (var i = 0; i < param.length; i++) {\n        var c = param[i];\n        switch (c) {\n            case '(':\n                if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [{ type: '', name: '', parent: node, state: { allowType: true } }];\n                node = node.components[0];\n                break;\n            case ')':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                node.type = verifyType(node.type);\n                var child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case ',':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                node.type = verifyType(node.type);\n                var sibling = { type: '', name: '', parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case ' ':\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== '') {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== '') {\n                        if (allowIndexed && node.name === 'indexed') {\n                            node.indexed = true;\n                            node.name = '';\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case '[':\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case ']':\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        throw new Error(\"unexpected eof\");\n    }\n    delete parent.state;\n    if (allowIndexed && node.name === 'indexed') {\n        node.indexed = true;\n        node.name = '';\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\n// @TODO: Better return type\nfunction parseSignatureEvent(fragment) {\n    var abi = {\n        anonymous: false,\n        inputs: [],\n        name: '',\n        type: 'event'\n    };\n    var match = fragment.match(regexParen);\n    if (!match) {\n        throw new Error('invalid event: ' + fragment);\n    }\n    abi.name = match[1].trim();\n    splitNesting(match[2]).forEach(function (param) {\n        param = parseParam(param, true);\n        param.indexed = !!param.indexed;\n        abi.inputs.push(param);\n    });\n    match[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'anonymous':\n                abi.anonymous = true;\n                break;\n            case '':\n                break;\n            default:\n                errors.info('unknown modifier: ' + modifier);\n        }\n    });\n    if (abi.name && !abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + abi.name + '\"');\n    }\n    return abi;\n}\nfunction parseSignatureFunction(fragment) {\n    var abi = {\n        constant: false,\n        gas: null,\n        inputs: [],\n        name: '',\n        outputs: [],\n        payable: false,\n        stateMutability: null,\n        type: 'function'\n    };\n    var comps = fragment.split('@');\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            throw new Error('invalid signature');\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            throw new Error('invalid signature gas');\n        }\n        abi.gas = bignumber_1.bigNumberify(comps[1]);\n        fragment = comps[0];\n    }\n    comps = fragment.split(' returns ');\n    var left = comps[0].match(regexParen);\n    if (!left) {\n        throw new Error('invalid signature');\n    }\n    abi.name = left[1].trim();\n    if (!abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + left[1] + '\"');\n    }\n    splitNesting(left[2]).forEach(function (param) {\n        abi.inputs.push(parseParam(param));\n    });\n    left[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'constant':\n                abi.constant = true;\n                break;\n            case 'payable':\n                abi.payable = true;\n                abi.stateMutability = 'payable';\n                break;\n            case 'pure':\n                abi.constant = true;\n                abi.stateMutability = 'pure';\n                break;\n            case 'view':\n                abi.constant = true;\n                abi.stateMutability = 'view';\n                break;\n            case 'external':\n            case 'public':\n            case '':\n                break;\n            default:\n                errors.info('unknown modifier: ' + modifier);\n        }\n    });\n    // We have outputs\n    if (comps.length > 1) {\n        var right = comps[1].match(regexParen);\n        if (right[1].trim() != '' || right[3].trim() != '') {\n            throw new Error('unexpected tokens');\n        }\n        splitNesting(right[2]).forEach(function (param) {\n            abi.outputs.push(parseParam(param));\n        });\n    }\n    if (abi.name === 'constructor') {\n        abi.type = \"constructor\";\n        if (abi.outputs.length) {\n            throw new Error('constructor may not have outputs');\n        }\n        delete abi.name;\n        delete abi.outputs;\n    }\n    return abi;\n}\nfunction parseParamType(type) {\n    return parseParam(type, true);\n}\nexports.parseParamType = parseParamType;\n// @TODO: Allow a second boolean to expose names\nfunction formatParamType(paramType) {\n    return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\nexports.formatParamType = formatParamType;\n// @TODO: Allow a second boolean to expose names and modifiers\nfunction formatSignature(fragment) {\n    return fragment.name + '(' + fragment.inputs.map(function (i) { return formatParamType(i); }).join(',') + ')';\n}\nexports.formatSignature = formatSignature;\nfunction parseSignature(fragment) {\n    if (typeof (fragment) === 'string') {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        fragment = fragment.replace(/\\s/g, ' ');\n        fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n        fragment = fragment.trim();\n        if (fragment.substring(0, 6) === 'event ') {\n            return parseSignatureEvent(fragment.substring(6).trim());\n        }\n        else {\n            if (fragment.substring(0, 9) === 'function ') {\n                fragment = fragment.substring(9);\n            }\n            return parseSignatureFunction(fragment.trim());\n        }\n    }\n    throw new Error('unknown signature');\n}\nexports.parseSignature = parseSignature;\nvar Coder = /** @class */ (function () {\n    function Coder(coerceFunc, name, type, localName, dynamic) {\n        this.coerceFunc = coerceFunc;\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    return Coder;\n}());\n// Clones the functionality of an existing Coder, but without a localName\nvar CoderAnonymous = /** @class */ (function (_super) {\n    __extends(CoderAnonymous, _super);\n    function CoderAnonymous(coder) {\n        var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n        properties_1.defineReadOnly(_this, 'coder', coder);\n        return _this;\n    }\n    CoderAnonymous.prototype.encode = function (value) { return this.coder.encode(value); };\n    CoderAnonymous.prototype.decode = function (data, offset) { return this.coder.decode(data, offset); };\n    return CoderAnonymous;\n}(Coder));\nvar CoderNull = /** @class */ (function (_super) {\n    __extends(CoderNull, _super);\n    function CoderNull(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n    }\n    CoderNull.prototype.encode = function (value) {\n        return bytes_1.arrayify([]);\n    };\n    CoderNull.prototype.decode = function (data, offset) {\n        if (offset > data.length) {\n            throw new Error('invalid null');\n        }\n        return {\n            consumed: 0,\n            value: this.coerceFunc('null', undefined)\n        };\n    };\n    return CoderNull;\n}(Coder));\nvar CoderNumber = /** @class */ (function (_super) {\n    __extends(CoderNumber, _super);\n    function CoderNumber(coerceFunc, size, signed, localName) {\n        var _this = this;\n        var name = ((signed ? 'int' : 'uint') + (size * 8));\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.size = size;\n        _this.signed = signed;\n        return _this;\n    }\n    CoderNumber.prototype.encode = function (value) {\n        try {\n            var v = bignumber_1.bigNumberify(value);\n            if (this.signed) {\n                var bounds = constants_1.MaxUint256.maskn(this.size * 8 - 1);\n                if (v.gt(bounds)) {\n                    throw new Error('out-of-bounds');\n                }\n                bounds = bounds.add(constants_1.One).mul(constants_1.NegativeOne);\n                if (v.lt(bounds)) {\n                    throw new Error('out-of-bounds');\n                }\n            }\n            else if (v.lt(constants_1.Zero) || v.gt(constants_1.MaxUint256.maskn(this.size * 8))) {\n                throw new Error('out-of-bounds');\n            }\n            v = v.toTwos(this.size * 8).maskn(this.size * 8);\n            if (this.signed) {\n                v = v.fromTwos(this.size * 8).toTwos(256);\n            }\n            return bytes_1.padZeros(bytes_1.arrayify(v), 32);\n        }\n        catch (error) {\n            errors.throwError('invalid number value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: value\n            });\n        }\n        return null;\n    };\n    CoderNumber.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        var junkLength = 32 - this.size;\n        var value = bignumber_1.bigNumberify(data.slice(offset + junkLength, offset + 32));\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n        else {\n            value = value.maskn(this.size * 8);\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, value),\n        };\n    };\n    return CoderNumber;\n}(Coder));\nvar uint256Coder = new CoderNumber(function (type, value) { return value; }, 32, false, 'none');\nvar CoderBoolean = /** @class */ (function (_super) {\n    __extends(CoderBoolean, _super);\n    function CoderBoolean(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n    }\n    CoderBoolean.prototype.encode = function (value) {\n        return uint256Coder.encode(!!value ? 1 : 0);\n    };\n    CoderBoolean.prototype.decode = function (data, offset) {\n        try {\n            var result = uint256Coder.decode(data, offset);\n        }\n        catch (error) {\n            if (error.reason === 'insufficient data for uint256 type') {\n                errors.throwError('insufficient data for boolean type', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'boolean',\n                    value: error.value\n                });\n            }\n            throw error;\n        }\n        return {\n            consumed: result.consumed,\n            value: this.coerceFunc('bool', !result.value.isZero())\n        };\n    };\n    return CoderBoolean;\n}(Coder));\nvar CoderFixedBytes = /** @class */ (function (_super) {\n    __extends(CoderFixedBytes, _super);\n    function CoderFixedBytes(coerceFunc, length, localName) {\n        var _this = this;\n        var name = ('bytes' + length);\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.length = length;\n        return _this;\n    }\n    CoderFixedBytes.prototype.encode = function (value) {\n        var result = new Uint8Array(32);\n        try {\n            var data = bytes_1.arrayify(value);\n            if (data.length !== this.length) {\n                throw new Error('incorrect data length');\n            }\n            result.set(data);\n        }\n        catch (error) {\n            errors.throwError('invalid ' + this.name + ' value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: (error.value || value)\n            });\n        }\n        return result;\n    };\n    CoderFixedBytes.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, bytes_1.hexlify(data.slice(offset, offset + this.length)))\n        };\n    };\n    return CoderFixedBytes;\n}(Coder));\nvar CoderAddress = /** @class */ (function (_super) {\n    __extends(CoderAddress, _super);\n    function CoderAddress(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n    }\n    CoderAddress.prototype.encode = function (value) {\n        var result = new Uint8Array(32);\n        try {\n            result.set(bytes_1.arrayify(address_1.getAddress(value)), 12);\n        }\n        catch (error) {\n            errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: value\n            });\n        }\n        return result;\n    };\n    CoderAddress.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficient data for address type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc('address', address_1.getAddress(bytes_1.hexlify(data.slice(offset + 12, offset + 32))))\n        };\n    };\n    return CoderAddress;\n}(Coder));\nfunction _encodeDynamicBytes(value) {\n    var dataLength = 32 * Math.ceil(value.length / 32);\n    var padding = new Uint8Array(dataLength - value.length);\n    return bytes_1.concat([\n        uint256Coder.encode(value.length),\n        value,\n        padding\n    ]);\n}\nfunction _decodeDynamicBytes(data, offset, localName) {\n    if (data.length < offset + 32) {\n        errors.throwError('insufficient data for dynamicBytes length', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: bytes_1.hexlify(data.slice(offset, offset + 32))\n        });\n    }\n    var length = uint256Coder.decode(data, offset).value;\n    try {\n        length = length.toNumber();\n    }\n    catch (error) {\n        errors.throwError('dynamic bytes count too large', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: length.toString()\n        });\n    }\n    if (data.length < offset + 32 + length) {\n        errors.throwError('insufficient data for dynamicBytes type', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: bytes_1.hexlify(data.slice(offset, offset + 32 + length))\n        });\n    }\n    return {\n        consumed: 32 + 32 * Math.ceil(length / 32),\n        value: data.slice(offset + 32, offset + 32 + length),\n    };\n}\nvar CoderDynamicBytes = /** @class */ (function (_super) {\n    __extends(CoderDynamicBytes, _super);\n    function CoderDynamicBytes(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n    }\n    CoderDynamicBytes.prototype.encode = function (value) {\n        try {\n            return _encodeDynamicBytes(bytes_1.arrayify(value));\n        }\n        catch (error) {\n            errors.throwError('invalid bytes value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'bytes',\n                value: error.value\n            });\n        }\n        return null;\n    };\n    CoderDynamicBytes.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName);\n        result.value = this.coerceFunc('bytes', bytes_1.hexlify(result.value));\n        return result;\n    };\n    return CoderDynamicBytes;\n}(Coder));\nvar CoderString = /** @class */ (function (_super) {\n    __extends(CoderString, _super);\n    function CoderString(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n    }\n    CoderString.prototype.encode = function (value) {\n        if (typeof (value) !== 'string') {\n            errors.throwError('invalid string value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'string',\n                value: value\n            });\n        }\n        return _encodeDynamicBytes(utf8_1.toUtf8Bytes(value));\n    };\n    CoderString.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName);\n        result.value = this.coerceFunc('string', utf8_1.toUtf8String(result.value));\n        return result;\n    };\n    return CoderString;\n}(Coder));\nfunction alignSize(size) {\n    return 32 * Math.ceil(size / 32);\n}\nfunction pack(coders, values) {\n    if (Array.isArray(values)) {\n        // do nothing\n    }\n    else if (values && typeof (values) === 'object') {\n        var arrayValues = [];\n        coders.forEach(function (coder) {\n            arrayValues.push(values[coder.localName]);\n        });\n        values = arrayValues;\n    }\n    else {\n        errors.throwError('invalid tuple value', errors.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values\n        });\n    }\n    if (coders.length !== values.length) {\n        errors.throwError('types/value length mismatch', errors.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values\n        });\n    }\n    var parts = [];\n    coders.forEach(function (coder, index) {\n        parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });\n    });\n    var staticSize = 0, dynamicSize = 0;\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            staticSize += 32;\n            dynamicSize += alignSize(part.value.length);\n        }\n        else {\n            staticSize += alignSize(part.value.length);\n        }\n    });\n    var offset = 0, dynamicOffset = staticSize;\n    var data = new Uint8Array(staticSize + dynamicSize);\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            //uint256Coder.encode(dynamicOffset).copy(data, offset);\n            data.set(uint256Coder.encode(dynamicOffset), offset);\n            offset += 32;\n            //part.value.copy(data, dynamicOffset);  @TODO\n            data.set(part.value, dynamicOffset);\n            dynamicOffset += alignSize(part.value.length);\n        }\n        else {\n            //part.value.copy(data, offset);  @TODO\n            data.set(part.value, offset);\n            offset += alignSize(part.value.length);\n        }\n    });\n    return data;\n}\nfunction unpack(coders, data, offset) {\n    var baseOffset = offset;\n    var consumed = 0;\n    var value = [];\n    coders.forEach(function (coder) {\n        if (coder.dynamic) {\n            var dynamicOffset = uint256Coder.decode(data, offset);\n            var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber());\n            // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n            result.consumed = dynamicOffset.consumed;\n        }\n        else {\n            var result = coder.decode(data, offset);\n        }\n        if (result.value != undefined) {\n            value.push(result.value);\n        }\n        offset += result.consumed;\n        consumed += result.consumed;\n    });\n    coders.forEach(function (coder, index) {\n        var name = coder.localName;\n        if (!name) {\n            return;\n        }\n        if (name === 'length') {\n            name = '_length';\n        }\n        if (value[name] != null) {\n            return;\n        }\n        value[name] = value[index];\n    });\n    return {\n        value: value,\n        consumed: consumed\n    };\n}\nvar CoderArray = /** @class */ (function (_super) {\n    __extends(CoderArray, _super);\n    function CoderArray(coerceFunc, coder, length, localName) {\n        var _this = this;\n        var type = (coder.type + '[' + (length >= 0 ? length : '') + ']');\n        var dynamic = (length === -1 || coder.dynamic);\n        _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n        _this.coder = coder;\n        _this.length = length;\n        return _this;\n    }\n    CoderArray.prototype.encode = function (value) {\n        if (!Array.isArray(value)) {\n            errors.throwError('expected array value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'array',\n                value: value\n            });\n        }\n        var count = this.length;\n        var result = new Uint8Array(0);\n        if (count === -1) {\n            count = value.length;\n            result = uint256Coder.encode(count);\n        }\n        errors.checkArgumentCount(count, value.length, ' in coder array' + (this.localName ? (\" \" + this.localName) : \"\"));\n        var coders = [];\n        for (var i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return bytes_1.concat([result, pack(coders, value)]);\n    };\n    CoderArray.prototype.decode = function (data, offset) {\n        // @TODO:\n        //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n        var consumed = 0;\n        var count = this.length;\n        if (count === -1) {\n            try {\n                var decodedLength = uint256Coder.decode(data, offset);\n            }\n            catch (error) {\n                errors.throwError('insufficient data for dynamic array length', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: error.value\n                });\n            }\n            try {\n                count = decodedLength.value.toNumber();\n            }\n            catch (error) {\n                errors.throwError('array count too large', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: decodedLength.value.toString()\n                });\n            }\n            consumed += decodedLength.consumed;\n            offset += decodedLength.consumed;\n        }\n        var coders = [];\n        for (var i = 0; i < count; i++) {\n            coders.push(new CoderAnonymous(this.coder));\n        }\n        var result = unpack(coders, data, offset);\n        result.consumed += consumed;\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderArray;\n}(Coder));\nvar CoderTuple = /** @class */ (function (_super) {\n    __extends(CoderTuple, _super);\n    function CoderTuple(coerceFunc, coders, localName) {\n        var _this = this;\n        var dynamic = false;\n        var types = [];\n        coders.forEach(function (coder) {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        var type = ('tuple(' + types.join(',') + ')');\n        _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n        _this.coders = coders;\n        return _this;\n    }\n    CoderTuple.prototype.encode = function (value) {\n        return pack(this.coders, value);\n    };\n    CoderTuple.prototype.decode = function (data, offset) {\n        var result = unpack(this.coders, data, offset);\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderTuple;\n}(Coder));\n/*\nfunction getTypes(coders) {\n    var type = coderTuple(coders).type;\n    return type.substring(6, type.length - 1);\n}\n*/\nfunction splitNesting(value) {\n    value = value.trim();\n    var result = [];\n    var accum = '';\n    var depth = 0;\n    for (var offset = 0; offset < value.length; offset++) {\n        var c = value[offset];\n        if (c === ',' && depth === 0) {\n            result.push(accum);\n            accum = '';\n        }\n        else {\n            accum += c;\n            if (c === '(') {\n                depth++;\n            }\n            else if (c === ')') {\n                depth--;\n                if (depth === -1) {\n                    throw new Error('unbalanced parenthsis');\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n// @TODO: Is there a way to return \"class\"?\nvar paramTypeSimple = {\n    address: CoderAddress,\n    bool: CoderBoolean,\n    string: CoderString,\n    bytes: CoderDynamicBytes,\n};\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n    if (!components) {\n        components = [];\n    }\n    var coders = [];\n    components.forEach(function (component) {\n        coders.push(getParamCoder(coerceFunc, component));\n    });\n    return new CoderTuple(coerceFunc, coders, localName);\n}\nfunction getParamCoder(coerceFunc, param) {\n    var coder = paramTypeSimple[param.type];\n    if (coder) {\n        return new coder(coerceFunc, param.name);\n    }\n    var match = param.type.match(paramTypeNumber);\n    if (match) {\n        var size = parseInt(match[2] || \"256\");\n        if (size === 0 || size > 256 || (size % 8) !== 0) {\n            errors.throwError('invalid ' + match[1] + ' bit length', errors.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param\n            });\n        }\n        return new CoderNumber(coerceFunc, size / 8, (match[1] === 'int'), param.name);\n    }\n    var match = param.type.match(paramTypeBytes);\n    if (match) {\n        var size = parseInt(match[1]);\n        if (size === 0 || size > 32) {\n            errors.throwError('invalid bytes length', errors.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param\n            });\n        }\n        return new CoderFixedBytes(coerceFunc, size, param.name);\n    }\n    var match = param.type.match(paramTypeArray);\n    if (match) {\n        var size = parseInt(match[2] || \"-1\");\n        param = properties_1.shallowCopy(param);\n        param.type = match[1];\n        param = properties_1.deepCopy(param);\n        return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);\n    }\n    if (param.type.substring(0, 5) === 'tuple') {\n        return getTupleParamCoder(coerceFunc, param.components, param.name);\n    }\n    if (param.type === '') {\n        return new CoderNull(coerceFunc, param.name);\n    }\n    errors.throwError('invalid type', errors.INVALID_ARGUMENT, {\n        arg: 'type',\n        value: param.type\n    });\n    return null;\n}\nvar AbiCoder = /** @class */ (function () {\n    function AbiCoder(coerceFunc) {\n        errors.checkNew(this, AbiCoder);\n        if (!coerceFunc) {\n            coerceFunc = exports.defaultCoerceFunc;\n        }\n        properties_1.defineReadOnly(this, 'coerceFunc', coerceFunc);\n    }\n    AbiCoder.prototype.encode = function (types, values) {\n        if (types.length !== values.length) {\n            errors.throwError('types/values length mismatch', errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n        var coders = [];\n        types.forEach(function (type) {\n            // Convert types to type objects\n            //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n            //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n            var typeObject = null;\n            if (typeof (type) === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = type;\n            }\n            coders.push(getParamCoder(this.coerceFunc, typeObject));\n        }, this);\n        return bytes_1.hexlify(new CoderTuple(this.coerceFunc, coders, '_').encode(values));\n    };\n    AbiCoder.prototype.decode = function (types, data) {\n        var coders = [];\n        types.forEach(function (type) {\n            // See encode for details\n            var typeObject = null;\n            if (typeof (type) === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = properties_1.deepCopy(type);\n            }\n            coders.push(getParamCoder(this.coerceFunc, typeObject));\n        }, this);\n        return new CoderTuple(this.coerceFunc, coders, '_').decode(bytes_1.arrayify(data), 0).value;\n    };\n    return AbiCoder;\n}());\nexports.AbiCoder = AbiCoder;\nexports.defaultAbiCoder = new AbiCoder();\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAM,YAAY;EACrD,IAAIC,aAAa,GAAGC,MAAM,CAACC,cAAc,IACpC;IAAEC,SAAS,EAAE;EAAG,CAAC,YAAYC,KAAK,IAAI,UAAUC,CAAC,EAAEC,CAAC,EAAE;IAAED,CAAC,CAACF,SAAS,GAAGG,CAAC;EAAE,CAAE,IAC5E,UAAUD,CAAC,EAAEC,CAAC,EAAE;IAAE,KAAK,IAAIC,CAAC,IAAID,CAAC,EAAE,IAAIA,CAAC,CAACE,cAAc,CAACD,CAAC,CAAC,EAAEF,CAAC,CAACE,CAAC,CAAC,GAAGD,CAAC,CAACC,CAAC,CAAC;EAAE,CAAC;EAC9E,OAAO,UAAUF,CAAC,EAAEC,CAAC,EAAE;IACnBN,aAAa,CAACK,CAAC,EAAEC,CAAC,CAAC;IACnB,SAASG,EAAE,GAAG;MAAE,IAAI,CAACC,WAAW,GAAGL,CAAC;IAAE;IACtCA,CAAC,CAACM,SAAS,GAAGL,CAAC,KAAK,IAAI,GAAGL,MAAM,CAACW,MAAM,CAACN,CAAC,CAAC,IAAIG,EAAE,CAACE,SAAS,GAAGL,CAAC,CAACK,SAAS,EAAE,IAAIF,EAAE,EAAE,CAAC;EACxF,CAAC;AACL,CAAC,EAAG;AACJ,IAAII,YAAY,GAAI,IAAI,IAAI,IAAI,CAACA,YAAY,IAAK,UAAUC,GAAG,EAAE;EAC7D,IAAIA,GAAG,IAAIA,GAAG,CAACC,UAAU,EAAE,OAAOD,GAAG;EACrC,IAAIE,MAAM,GAAG,CAAC,CAAC;EACf,IAAIF,GAAG,IAAI,IAAI,EAAE,KAAK,IAAIG,CAAC,IAAIH,GAAG,EAAE,IAAIb,MAAM,CAACO,cAAc,CAACU,IAAI,CAACJ,GAAG,EAAEG,CAAC,CAAC,EAAED,MAAM,CAACC,CAAC,CAAC,GAAGH,GAAG,CAACG,CAAC,CAAC;EAC9FD,MAAM,CAAC,SAAS,CAAC,GAAGF,GAAG;EACvB,OAAOE,MAAM;AACjB,CAAC;AACDf,MAAM,CAACkB,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D;AACA,IAAIC,WAAW,GAAGC,OAAO,CAAC,cAAc,CAAC;AACzC,IAAIC,MAAM,GAAGX,YAAY,CAACU,OAAO,CAAC,WAAW,CAAC,CAAC;AAC/C,IAAIE,SAAS,GAAGF,OAAO,CAAC,WAAW,CAAC;AACpC,IAAIG,WAAW,GAAGH,OAAO,CAAC,aAAa,CAAC;AACxC,IAAII,OAAO,GAAGJ,OAAO,CAAC,SAAS,CAAC;AAChC,IAAIK,MAAM,GAAGL,OAAO,CAAC,QAAQ,CAAC;AAC9B,IAAIM,YAAY,GAAGN,OAAO,CAAC,cAAc,CAAC;AAC1C;AACA,IAAIO,cAAc,GAAG,IAAIC,MAAM,CAAC,iBAAiB,CAAC;AAClD,IAAIC,eAAe,GAAG,IAAID,MAAM,CAAC,mBAAmB,CAAC;AACrD,IAAIE,cAAc,GAAG,IAAIF,MAAM,CAAC,oBAAoB,CAAC;AACrDX,OAAO,CAACc,iBAAiB,GAAG,UAAUC,IAAI,EAAEd,KAAK,EAAE;EAC/C,IAAIe,KAAK,GAAGD,IAAI,CAACC,KAAK,CAACJ,eAAe,CAAC;EACvC,IAAII,KAAK,IAAIC,QAAQ,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,EAAE;IACnC,OAAOf,KAAK,CAACiB,QAAQ,EAAE;EAC3B;EACA,OAAOjB,KAAK;AAChB,CAAC;AACD;AACA;AACA,IAAIkB,UAAU,GAAG,IAAIR,MAAM,CAAC,8BAA8B,CAAC;AAC3D,IAAIS,eAAe,GAAG,IAAIT,MAAM,CAAC,0BAA0B,CAAC;AAC5D,SAASU,UAAU,CAACN,IAAI,EAAE;EACtB;EACA,IAAIA,IAAI,CAACC,KAAK,CAAC,iBAAiB,CAAC,EAAE;IAC/BD,IAAI,GAAG,SAAS,GAAGA,IAAI,CAACO,SAAS,CAAC,CAAC,CAAC;EACxC,CAAC,MACI,IAAIP,IAAI,CAACC,KAAK,CAAC,gBAAgB,CAAC,EAAE;IACnCD,IAAI,GAAG,QAAQ,GAAGA,IAAI,CAACO,SAAS,CAAC,CAAC,CAAC;EACvC;EACA,OAAOP,IAAI;AACf;AACA,SAASQ,UAAU,CAACC,KAAK,EAAEC,YAAY,EAAE;EACrC,IAAIC,aAAa,GAAGF,KAAK;EACzB,SAASG,UAAU,CAACC,CAAC,EAAE;IACnB,MAAM,IAAIC,KAAK,CAAC,wBAAwB,GAAGH,aAAa,CAACE,CAAC,CAAC,GAAG,gBAAgB,GAAGA,CAAC,GAAG,OAAO,GAAGF,aAAa,GAAG,GAAG,CAAC;EACvH;EACAF,KAAK,GAAGA,KAAK,CAACM,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;EACjC,IAAIC,MAAM,GAAG;IAAEhB,IAAI,EAAE,EAAE;IAAEiB,IAAI,EAAE,EAAE;IAAEC,KAAK,EAAE;MAAEC,SAAS,EAAE;IAAK;EAAE,CAAC;EAC/D,IAAIC,IAAI,GAAGJ,MAAM;EACjB,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACY,MAAM,EAAER,CAAC,EAAE,EAAE;IACnC,IAAIS,CAAC,GAAGb,KAAK,CAACI,CAAC,CAAC;IAChB,QAAQS,CAAC;MACL,KAAK,GAAG;QACJ,IAAI,CAACF,IAAI,CAACF,KAAK,CAACK,WAAW,EAAE;UACzBX,UAAU,CAACC,CAAC,CAAC;QACjB;QACAO,IAAI,CAACF,KAAK,CAACC,SAAS,GAAG,KAAK;QAC5BC,IAAI,CAACpB,IAAI,GAAGM,UAAU,CAACc,IAAI,CAACpB,IAAI,CAAC;QACjCoB,IAAI,CAACI,UAAU,GAAG,CAAC;UAAExB,IAAI,EAAE,EAAE;UAAEiB,IAAI,EAAE,EAAE;UAAED,MAAM,EAAEI,IAAI;UAAEF,KAAK,EAAE;YAAEC,SAAS,EAAE;UAAK;QAAE,CAAC,CAAC;QACpFC,IAAI,GAAGA,IAAI,CAACI,UAAU,CAAC,CAAC,CAAC;QACzB;MACJ,KAAK,GAAG;QACJ,OAAOJ,IAAI,CAACF,KAAK;QACjB,IAAIR,YAAY,IAAIU,IAAI,CAACH,IAAI,KAAK,SAAS,EAAE;UACzCG,IAAI,CAACK,OAAO,GAAG,IAAI;UACnBL,IAAI,CAACH,IAAI,GAAG,EAAE;QAClB;QACAG,IAAI,CAACpB,IAAI,GAAGM,UAAU,CAACc,IAAI,CAACpB,IAAI,CAAC;QACjC,IAAI0B,KAAK,GAAGN,IAAI;QAChBA,IAAI,GAAGA,IAAI,CAACJ,MAAM;QAClB,IAAI,CAACI,IAAI,EAAE;UACPR,UAAU,CAACC,CAAC,CAAC;QACjB;QACA,OAAOa,KAAK,CAACV,MAAM;QACnBI,IAAI,CAACF,KAAK,CAACK,WAAW,GAAG,KAAK;QAC9BH,IAAI,CAACF,KAAK,CAACS,SAAS,GAAG,IAAI;QAC3BP,IAAI,CAACF,KAAK,CAACU,UAAU,GAAG,IAAI;QAC5B;MACJ,KAAK,GAAG;QACJ,OAAOR,IAAI,CAACF,KAAK;QACjB,IAAIR,YAAY,IAAIU,IAAI,CAACH,IAAI,KAAK,SAAS,EAAE;UACzCG,IAAI,CAACK,OAAO,GAAG,IAAI;UACnBL,IAAI,CAACH,IAAI,GAAG,EAAE;QAClB;QACAG,IAAI,CAACpB,IAAI,GAAGM,UAAU,CAACc,IAAI,CAACpB,IAAI,CAAC;QACjC,IAAI6B,OAAO,GAAG;UAAE7B,IAAI,EAAE,EAAE;UAAEiB,IAAI,EAAE,EAAE;UAAED,MAAM,EAAEI,IAAI,CAACJ,MAAM;UAAEE,KAAK,EAAE;YAAEC,SAAS,EAAE;UAAK;QAAE,CAAC;QACrFC,IAAI,CAACJ,MAAM,CAACQ,UAAU,CAACM,IAAI,CAACD,OAAO,CAAC;QACpC,OAAOT,IAAI,CAACJ,MAAM;QAClBI,IAAI,GAAGS,OAAO;QACd;MACJ;MACA,KAAK,GAAG;QACJ;QACA,IAAIT,IAAI,CAACF,KAAK,CAACC,SAAS,EAAE;UACtB,IAAIC,IAAI,CAACpB,IAAI,KAAK,EAAE,EAAE;YAClBoB,IAAI,CAACpB,IAAI,GAAGM,UAAU,CAACc,IAAI,CAACpB,IAAI,CAAC;YACjC,OAAOoB,IAAI,CAACF,KAAK,CAACC,SAAS;YAC3BC,IAAI,CAACF,KAAK,CAACS,SAAS,GAAG,IAAI;YAC3BP,IAAI,CAACF,KAAK,CAACK,WAAW,GAAG,IAAI;UACjC;QACJ;QACA;QACA,IAAIH,IAAI,CAACF,KAAK,CAACS,SAAS,EAAE;UACtB,IAAIP,IAAI,CAACH,IAAI,KAAK,EAAE,EAAE;YAClB,IAAIP,YAAY,IAAIU,IAAI,CAACH,IAAI,KAAK,SAAS,EAAE;cACzCG,IAAI,CAACK,OAAO,GAAG,IAAI;cACnBL,IAAI,CAACH,IAAI,GAAG,EAAE;YAClB,CAAC,MACI;cACDG,IAAI,CAACF,KAAK,CAACS,SAAS,GAAG,KAAK;YAChC;UACJ;QACJ;QACA;MACJ,KAAK,GAAG;QACJ,IAAI,CAACP,IAAI,CAACF,KAAK,CAACU,UAAU,EAAE;UACxBhB,UAAU,CAACC,CAAC,CAAC;QACjB;QACAO,IAAI,CAACpB,IAAI,IAAIsB,CAAC;QACdF,IAAI,CAACF,KAAK,CAACU,UAAU,GAAG,KAAK;QAC7BR,IAAI,CAACF,KAAK,CAACS,SAAS,GAAG,KAAK;QAC5BP,IAAI,CAACF,KAAK,CAACa,SAAS,GAAG,IAAI;QAC3B;MACJ,KAAK,GAAG;QACJ,IAAI,CAACX,IAAI,CAACF,KAAK,CAACa,SAAS,EAAE;UACvBnB,UAAU,CAACC,CAAC,CAAC;QACjB;QACAO,IAAI,CAACpB,IAAI,IAAIsB,CAAC;QACdF,IAAI,CAACF,KAAK,CAACa,SAAS,GAAG,KAAK;QAC5BX,IAAI,CAACF,KAAK,CAACU,UAAU,GAAG,IAAI;QAC5BR,IAAI,CAACF,KAAK,CAACS,SAAS,GAAG,IAAI;QAC3B;MACJ;QACI,IAAIP,IAAI,CAACF,KAAK,CAACC,SAAS,EAAE;UACtBC,IAAI,CAACpB,IAAI,IAAIsB,CAAC;UACdF,IAAI,CAACF,KAAK,CAACK,WAAW,GAAG,IAAI;UAC7BH,IAAI,CAACF,KAAK,CAACU,UAAU,GAAG,IAAI;QAChC,CAAC,MACI,IAAIR,IAAI,CAACF,KAAK,CAACS,SAAS,EAAE;UAC3BP,IAAI,CAACH,IAAI,IAAIK,CAAC;UACd,OAAOF,IAAI,CAACF,KAAK,CAACU,UAAU;QAChC,CAAC,MACI,IAAIR,IAAI,CAACF,KAAK,CAACa,SAAS,EAAE;UAC3BX,IAAI,CAACpB,IAAI,IAAIsB,CAAC;QAClB,CAAC,MACI;UACDV,UAAU,CAACC,CAAC,CAAC;QACjB;IAAC;EAEb;EACA,IAAIO,IAAI,CAACJ,MAAM,EAAE;IACb,MAAM,IAAIF,KAAK,CAAC,gBAAgB,CAAC;EACrC;EACA,OAAOE,MAAM,CAACE,KAAK;EACnB,IAAIR,YAAY,IAAIU,IAAI,CAACH,IAAI,KAAK,SAAS,EAAE;IACzCG,IAAI,CAACK,OAAO,GAAG,IAAI;IACnBL,IAAI,CAACH,IAAI,GAAG,EAAE;EAClB;EACAD,MAAM,CAAChB,IAAI,GAAGM,UAAU,CAACU,MAAM,CAAChB,IAAI,CAAC;EACrC,OAAOgB,MAAM;AACjB;AACA;AACA,SAASgB,mBAAmB,CAACC,QAAQ,EAAE;EACnC,IAAIC,GAAG,GAAG;IACNC,SAAS,EAAE,KAAK;IAChBC,MAAM,EAAE,EAAE;IACVnB,IAAI,EAAE,EAAE;IACRjB,IAAI,EAAE;EACV,CAAC;EACD,IAAIC,KAAK,GAAGgC,QAAQ,CAAChC,KAAK,CAACG,UAAU,CAAC;EACtC,IAAI,CAACH,KAAK,EAAE;IACR,MAAM,IAAIa,KAAK,CAAC,iBAAiB,GAAGmB,QAAQ,CAAC;EACjD;EACAC,GAAG,CAACjB,IAAI,GAAGhB,KAAK,CAAC,CAAC,CAAC,CAACoC,IAAI,EAAE;EAC1BC,YAAY,CAACrC,KAAK,CAAC,CAAC,CAAC,CAAC,CAACsC,OAAO,CAAC,UAAU9B,KAAK,EAAE;IAC5CA,KAAK,GAAGD,UAAU,CAACC,KAAK,EAAE,IAAI,CAAC;IAC/BA,KAAK,CAACgB,OAAO,GAAG,CAAC,CAAChB,KAAK,CAACgB,OAAO;IAC/BS,GAAG,CAACE,MAAM,CAACN,IAAI,CAACrB,KAAK,CAAC;EAC1B,CAAC,CAAC;EACFR,KAAK,CAAC,CAAC,CAAC,CAACuC,KAAK,CAAC,GAAG,CAAC,CAACD,OAAO,CAAC,UAAUE,QAAQ,EAAE;IAC5C,QAAQA,QAAQ;MACZ,KAAK,WAAW;QACZP,GAAG,CAACC,SAAS,GAAG,IAAI;QACpB;MACJ,KAAK,EAAE;QACH;MACJ;QACI9C,MAAM,CAACqD,IAAI,CAAC,oBAAoB,GAAGD,QAAQ,CAAC;IAAC;EAEzD,CAAC,CAAC;EACF,IAAIP,GAAG,CAACjB,IAAI,IAAI,CAACiB,GAAG,CAACjB,IAAI,CAAChB,KAAK,CAACI,eAAe,CAAC,EAAE;IAC9C,MAAM,IAAIS,KAAK,CAAC,uBAAuB,GAAGoB,GAAG,CAACjB,IAAI,GAAG,GAAG,CAAC;EAC7D;EACA,OAAOiB,GAAG;AACd;AACA,SAASS,sBAAsB,CAACV,QAAQ,EAAE;EACtC,IAAIC,GAAG,GAAG;IACNU,QAAQ,EAAE,KAAK;IACfC,GAAG,EAAE,IAAI;IACTT,MAAM,EAAE,EAAE;IACVnB,IAAI,EAAE,EAAE;IACR6B,OAAO,EAAE,EAAE;IACXC,OAAO,EAAE,KAAK;IACdC,eAAe,EAAE,IAAI;IACrBhD,IAAI,EAAE;EACV,CAAC;EACD,IAAIiD,KAAK,GAAGhB,QAAQ,CAACO,KAAK,CAAC,GAAG,CAAC;EAC/B,IAAIS,KAAK,CAAC5B,MAAM,KAAK,CAAC,EAAE;IACpB,IAAI4B,KAAK,CAAC5B,MAAM,GAAG,CAAC,EAAE;MAClB,MAAM,IAAIP,KAAK,CAAC,mBAAmB,CAAC;IACxC;IACA,IAAI,CAACmC,KAAK,CAAC,CAAC,CAAC,CAAChD,KAAK,CAAC,UAAU,CAAC,EAAE;MAC7B,MAAM,IAAIa,KAAK,CAAC,uBAAuB,CAAC;IAC5C;IACAoB,GAAG,CAACW,GAAG,GAAGtD,WAAW,CAAC2D,YAAY,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC;IAC5ChB,QAAQ,GAAGgB,KAAK,CAAC,CAAC,CAAC;EACvB;EACAA,KAAK,GAAGhB,QAAQ,CAACO,KAAK,CAAC,WAAW,CAAC;EACnC,IAAIW,IAAI,GAAGF,KAAK,CAAC,CAAC,CAAC,CAAChD,KAAK,CAACG,UAAU,CAAC;EACrC,IAAI,CAAC+C,IAAI,EAAE;IACP,MAAM,IAAIrC,KAAK,CAAC,mBAAmB,CAAC;EACxC;EACAoB,GAAG,CAACjB,IAAI,GAAGkC,IAAI,CAAC,CAAC,CAAC,CAACd,IAAI,EAAE;EACzB,IAAI,CAACH,GAAG,CAACjB,IAAI,CAAChB,KAAK,CAACI,eAAe,CAAC,EAAE;IAClC,MAAM,IAAIS,KAAK,CAAC,uBAAuB,GAAGqC,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;EAC5D;EACAb,YAAY,CAACa,IAAI,CAAC,CAAC,CAAC,CAAC,CAACZ,OAAO,CAAC,UAAU9B,KAAK,EAAE;IAC3CyB,GAAG,CAACE,MAAM,CAACN,IAAI,CAACtB,UAAU,CAACC,KAAK,CAAC,CAAC;EACtC,CAAC,CAAC;EACF0C,IAAI,CAAC,CAAC,CAAC,CAACX,KAAK,CAAC,GAAG,CAAC,CAACD,OAAO,CAAC,UAAUE,QAAQ,EAAE;IAC3C,QAAQA,QAAQ;MACZ,KAAK,UAAU;QACXP,GAAG,CAACU,QAAQ,GAAG,IAAI;QACnB;MACJ,KAAK,SAAS;QACVV,GAAG,CAACa,OAAO,GAAG,IAAI;QAClBb,GAAG,CAACc,eAAe,GAAG,SAAS;QAC/B;MACJ,KAAK,MAAM;QACPd,GAAG,CAACU,QAAQ,GAAG,IAAI;QACnBV,GAAG,CAACc,eAAe,GAAG,MAAM;QAC5B;MACJ,KAAK,MAAM;QACPd,GAAG,CAACU,QAAQ,GAAG,IAAI;QACnBV,GAAG,CAACc,eAAe,GAAG,MAAM;QAC5B;MACJ,KAAK,UAAU;MACf,KAAK,QAAQ;MACb,KAAK,EAAE;QACH;MACJ;QACI3D,MAAM,CAACqD,IAAI,CAAC,oBAAoB,GAAGD,QAAQ,CAAC;IAAC;EAEzD,CAAC,CAAC;EACF;EACA,IAAIQ,KAAK,CAAC5B,MAAM,GAAG,CAAC,EAAE;IAClB,IAAI+B,KAAK,GAAGH,KAAK,CAAC,CAAC,CAAC,CAAChD,KAAK,CAACG,UAAU,CAAC;IACtC,IAAIgD,KAAK,CAAC,CAAC,CAAC,CAACf,IAAI,EAAE,IAAI,EAAE,IAAIe,KAAK,CAAC,CAAC,CAAC,CAACf,IAAI,EAAE,IAAI,EAAE,EAAE;MAChD,MAAM,IAAIvB,KAAK,CAAC,mBAAmB,CAAC;IACxC;IACAwB,YAAY,CAACc,KAAK,CAAC,CAAC,CAAC,CAAC,CAACb,OAAO,CAAC,UAAU9B,KAAK,EAAE;MAC5CyB,GAAG,CAACY,OAAO,CAAChB,IAAI,CAACtB,UAAU,CAACC,KAAK,CAAC,CAAC;IACvC,CAAC,CAAC;EACN;EACA,IAAIyB,GAAG,CAACjB,IAAI,KAAK,aAAa,EAAE;IAC5BiB,GAAG,CAAClC,IAAI,GAAG,aAAa;IACxB,IAAIkC,GAAG,CAACY,OAAO,CAACzB,MAAM,EAAE;MACpB,MAAM,IAAIP,KAAK,CAAC,kCAAkC,CAAC;IACvD;IACA,OAAOoB,GAAG,CAACjB,IAAI;IACf,OAAOiB,GAAG,CAACY,OAAO;EACtB;EACA,OAAOZ,GAAG;AACd;AACA,SAASmB,cAAc,CAACrD,IAAI,EAAE;EAC1B,OAAOQ,UAAU,CAACR,IAAI,EAAE,IAAI,CAAC;AACjC;AACAf,OAAO,CAACoE,cAAc,GAAGA,cAAc;AACvC;AACA,SAASC,eAAe,CAACC,SAAS,EAAE;EAChC,OAAOC,aAAa,CAACvE,OAAO,CAACc,iBAAiB,EAAEwD,SAAS,CAAC,CAACvD,IAAI;AACnE;AACAf,OAAO,CAACqE,eAAe,GAAGA,eAAe;AACzC;AACA,SAASG,eAAe,CAACxB,QAAQ,EAAE;EAC/B,OAAOA,QAAQ,CAAChB,IAAI,GAAG,GAAG,GAAGgB,QAAQ,CAACG,MAAM,CAACsB,GAAG,CAAC,UAAU7C,CAAC,EAAE;IAAE,OAAOyC,eAAe,CAACzC,CAAC,CAAC;EAAE,CAAC,CAAC,CAAC8C,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;AACjH;AACA1E,OAAO,CAACwE,eAAe,GAAGA,eAAe;AACzC,SAASG,cAAc,CAAC3B,QAAQ,EAAE;EAC9B,IAAI,OAAQA,QAAS,KAAK,QAAQ,EAAE;IAChC;IACAA,QAAQ,GAAGA,QAAQ,CAAClB,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;IACvCkB,QAAQ,GAAGA,QAAQ,CAAClB,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAACA,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAACA,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC;IAClFkB,QAAQ,GAAGA,QAAQ,CAACI,IAAI,EAAE;IAC1B,IAAIJ,QAAQ,CAAC1B,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,QAAQ,EAAE;MACvC,OAAOyB,mBAAmB,CAACC,QAAQ,CAAC1B,SAAS,CAAC,CAAC,CAAC,CAAC8B,IAAI,EAAE,CAAC;IAC5D,CAAC,MACI;MACD,IAAIJ,QAAQ,CAAC1B,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,WAAW,EAAE;QAC1C0B,QAAQ,GAAGA,QAAQ,CAAC1B,SAAS,CAAC,CAAC,CAAC;MACpC;MACA,OAAOoC,sBAAsB,CAACV,QAAQ,CAACI,IAAI,EAAE,CAAC;IAClD;EACJ;EACA,MAAM,IAAIvB,KAAK,CAAC,mBAAmB,CAAC;AACxC;AACA7B,OAAO,CAAC2E,cAAc,GAAGA,cAAc;AACvC,IAAIC,KAAK,GAAG,aAAe,YAAY;EACnC,SAASA,KAAK,CAACC,UAAU,EAAE7C,IAAI,EAAEjB,IAAI,EAAE+D,SAAS,EAAEC,OAAO,EAAE;IACvD,IAAI,CAACF,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC7C,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACjB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC+D,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,OAAO,GAAGA,OAAO;EAC1B;EACA,OAAOH,KAAK;AAChB,CAAC,EAAG;AACJ;AACA,IAAII,cAAc,GAAG,aAAe,UAAUC,MAAM,EAAE;EAClDtG,SAAS,CAACqG,cAAc,EAAEC,MAAM,CAAC;EACjC,SAASD,cAAc,CAACE,KAAK,EAAE;IAC3B,IAAIC,KAAK,GAAGF,MAAM,CAACnF,IAAI,CAAC,IAAI,EAAEoF,KAAK,CAACL,UAAU,EAAEK,KAAK,CAAClD,IAAI,EAAEkD,KAAK,CAACnE,IAAI,EAAEqE,SAAS,EAAEF,KAAK,CAACH,OAAO,CAAC,IAAI,IAAI;IACzGtE,YAAY,CAAC4E,cAAc,CAACF,KAAK,EAAE,OAAO,EAAED,KAAK,CAAC;IAClD,OAAOC,KAAK;EAChB;EACAH,cAAc,CAACzF,SAAS,CAAC+F,MAAM,GAAG,UAAUrF,KAAK,EAAE;IAAE,OAAO,IAAI,CAACiF,KAAK,CAACI,MAAM,CAACrF,KAAK,CAAC;EAAE,CAAC;EACvF+E,cAAc,CAACzF,SAAS,CAACgG,MAAM,GAAG,UAAUC,IAAI,EAAEC,MAAM,EAAE;IAAE,OAAO,IAAI,CAACP,KAAK,CAACK,MAAM,CAACC,IAAI,EAAEC,MAAM,CAAC;EAAE,CAAC;EACrG,OAAOT,cAAc;AACzB,CAAC,CAACJ,KAAK,CAAE;AACT,IAAIc,SAAS,GAAG,aAAe,UAAUT,MAAM,EAAE;EAC7CtG,SAAS,CAAC+G,SAAS,EAAET,MAAM,CAAC;EAC5B,SAASS,SAAS,CAACb,UAAU,EAAEC,SAAS,EAAE;IACtC,OAAOG,MAAM,CAACnF,IAAI,CAAC,IAAI,EAAE+E,UAAU,EAAE,MAAM,EAAE,EAAE,EAAEC,SAAS,EAAE,KAAK,CAAC,IAAI,IAAI;EAC9E;EACAY,SAAS,CAACnG,SAAS,CAAC+F,MAAM,GAAG,UAAUrF,KAAK,EAAE;IAC1C,OAAOM,OAAO,CAACoF,QAAQ,CAAC,EAAE,CAAC;EAC/B,CAAC;EACDD,SAAS,CAACnG,SAAS,CAACgG,MAAM,GAAG,UAAUC,IAAI,EAAEC,MAAM,EAAE;IACjD,IAAIA,MAAM,GAAGD,IAAI,CAACpD,MAAM,EAAE;MACtB,MAAM,IAAIP,KAAK,CAAC,cAAc,CAAC;IACnC;IACA,OAAO;MACH+D,QAAQ,EAAE,CAAC;MACX3F,KAAK,EAAE,IAAI,CAAC4E,UAAU,CAAC,MAAM,EAAEO,SAAS;IAC5C,CAAC;EACL,CAAC;EACD,OAAOM,SAAS;AACpB,CAAC,CAACd,KAAK,CAAE;AACT,IAAIiB,WAAW,GAAG,aAAe,UAAUZ,MAAM,EAAE;EAC/CtG,SAAS,CAACkH,WAAW,EAAEZ,MAAM,CAAC;EAC9B,SAASY,WAAW,CAAChB,UAAU,EAAEiB,IAAI,EAAEC,MAAM,EAAEjB,SAAS,EAAE;IACtD,IAAIK,KAAK,GAAG,IAAI;IAChB,IAAInD,IAAI,GAAI,CAAC+D,MAAM,GAAG,KAAK,GAAG,MAAM,IAAKD,IAAI,GAAG,CAAG;IACnDX,KAAK,GAAGF,MAAM,CAACnF,IAAI,CAAC,IAAI,EAAE+E,UAAU,EAAE7C,IAAI,EAAEA,IAAI,EAAE8C,SAAS,EAAE,KAAK,CAAC,IAAI,IAAI;IAC3EK,KAAK,CAACW,IAAI,GAAGA,IAAI;IACjBX,KAAK,CAACY,MAAM,GAAGA,MAAM;IACrB,OAAOZ,KAAK;EAChB;EACAU,WAAW,CAACtG,SAAS,CAAC+F,MAAM,GAAG,UAAUrF,KAAK,EAAE;IAC5C,IAAI;MACA,IAAI+F,CAAC,GAAG1F,WAAW,CAAC2D,YAAY,CAAChE,KAAK,CAAC;MACvC,IAAI,IAAI,CAAC8F,MAAM,EAAE;QACb,IAAIE,MAAM,GAAG/F,WAAW,CAACgG,UAAU,CAACC,KAAK,CAAC,IAAI,CAACL,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;QAC5D,IAAIE,CAAC,CAACI,EAAE,CAACH,MAAM,CAAC,EAAE;UACd,MAAM,IAAIpE,KAAK,CAAC,eAAe,CAAC;QACpC;QACAoE,MAAM,GAAGA,MAAM,CAACI,GAAG,CAACnG,WAAW,CAACoG,GAAG,CAAC,CAACC,GAAG,CAACrG,WAAW,CAACsG,WAAW,CAAC;QACjE,IAAIR,CAAC,CAACS,EAAE,CAACR,MAAM,CAAC,EAAE;UACd,MAAM,IAAIpE,KAAK,CAAC,eAAe,CAAC;QACpC;MACJ,CAAC,MACI,IAAImE,CAAC,CAACS,EAAE,CAACvG,WAAW,CAACwG,IAAI,CAAC,IAAIV,CAAC,CAACI,EAAE,CAAClG,WAAW,CAACgG,UAAU,CAACC,KAAK,CAAC,IAAI,CAACL,IAAI,GAAG,CAAC,CAAC,CAAC,EAAE;QAClF,MAAM,IAAIjE,KAAK,CAAC,eAAe,CAAC;MACpC;MACAmE,CAAC,GAAGA,CAAC,CAACW,MAAM,CAAC,IAAI,CAACb,IAAI,GAAG,CAAC,CAAC,CAACK,KAAK,CAAC,IAAI,CAACL,IAAI,GAAG,CAAC,CAAC;MAChD,IAAI,IAAI,CAACC,MAAM,EAAE;QACbC,CAAC,GAAGA,CAAC,CAACY,QAAQ,CAAC,IAAI,CAACd,IAAI,GAAG,CAAC,CAAC,CAACa,MAAM,CAAC,GAAG,CAAC;MAC7C;MACA,OAAOpG,OAAO,CAACsG,QAAQ,CAACtG,OAAO,CAACoF,QAAQ,CAACK,CAAC,CAAC,EAAE,EAAE,CAAC;IACpD,CAAC,CACD,OAAOc,KAAK,EAAE;MACV1G,MAAM,CAACuB,UAAU,CAAC,sBAAsB,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;QAC/DC,GAAG,EAAE,IAAI,CAAClC,SAAS;QACnBmC,SAAS,EAAE,IAAI,CAACjF,IAAI;QACpB/B,KAAK,EAAEA;MACX,CAAC,CAAC;IACN;IACA,OAAO,IAAI;EACf,CAAC;EACD4F,WAAW,CAACtG,SAAS,CAACgG,MAAM,GAAG,UAAUC,IAAI,EAAEC,MAAM,EAAE;IACnD,IAAID,IAAI,CAACpD,MAAM,GAAGqD,MAAM,GAAG,EAAE,EAAE;MAC3BrF,MAAM,CAACuB,UAAU,CAAC,wBAAwB,GAAG,IAAI,CAACK,IAAI,GAAG,OAAO,EAAE5B,MAAM,CAAC2G,gBAAgB,EAAE;QACvFC,GAAG,EAAE,IAAI,CAAClC,SAAS;QACnBmC,SAAS,EAAE,IAAI,CAACjF,IAAI;QACpB/B,KAAK,EAAEM,OAAO,CAAC2G,OAAO,CAAC1B,IAAI,CAAC2B,KAAK,CAAC1B,MAAM,EAAEA,MAAM,GAAG,EAAE,CAAC;MAC1D,CAAC,CAAC;IACN;IACA,IAAI2B,UAAU,GAAG,EAAE,GAAG,IAAI,CAACtB,IAAI;IAC/B,IAAI7F,KAAK,GAAGK,WAAW,CAAC2D,YAAY,CAACuB,IAAI,CAAC2B,KAAK,CAAC1B,MAAM,GAAG2B,UAAU,EAAE3B,MAAM,GAAG,EAAE,CAAC,CAAC;IAClF,IAAI,IAAI,CAACM,MAAM,EAAE;MACb9F,KAAK,GAAGA,KAAK,CAAC2G,QAAQ,CAAC,IAAI,CAACd,IAAI,GAAG,CAAC,CAAC;IACzC,CAAC,MACI;MACD7F,KAAK,GAAGA,KAAK,CAACkG,KAAK,CAAC,IAAI,CAACL,IAAI,GAAG,CAAC,CAAC;IACtC;IACA,OAAO;MACHF,QAAQ,EAAE,EAAE;MACZ3F,KAAK,EAAE,IAAI,CAAC4E,UAAU,CAAC,IAAI,CAAC7C,IAAI,EAAE/B,KAAK;IAC3C,CAAC;EACL,CAAC;EACD,OAAO4F,WAAW;AACtB,CAAC,CAACjB,KAAK,CAAE;AACT,IAAIyC,YAAY,GAAG,IAAIxB,WAAW,CAAC,UAAU9E,IAAI,EAAEd,KAAK,EAAE;EAAE,OAAOA,KAAK;AAAE,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE,MAAM,CAAC;AAC/F,IAAIqH,YAAY,GAAG,aAAe,UAAUrC,MAAM,EAAE;EAChDtG,SAAS,CAAC2I,YAAY,EAAErC,MAAM,CAAC;EAC/B,SAASqC,YAAY,CAACzC,UAAU,EAAEC,SAAS,EAAE;IACzC,OAAOG,MAAM,CAACnF,IAAI,CAAC,IAAI,EAAE+E,UAAU,EAAE,MAAM,EAAE,MAAM,EAAEC,SAAS,EAAE,KAAK,CAAC,IAAI,IAAI;EAClF;EACAwC,YAAY,CAAC/H,SAAS,CAAC+F,MAAM,GAAG,UAAUrF,KAAK,EAAE;IAC7C,OAAOoH,YAAY,CAAC/B,MAAM,CAAC,CAAC,CAACrF,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;EAC/C,CAAC;EACDqH,YAAY,CAAC/H,SAAS,CAACgG,MAAM,GAAG,UAAUC,IAAI,EAAEC,MAAM,EAAE;IACpD,IAAI;MACA,IAAI7F,MAAM,GAAGyH,YAAY,CAAC9B,MAAM,CAACC,IAAI,EAAEC,MAAM,CAAC;IAClD,CAAC,CACD,OAAOqB,KAAK,EAAE;MACV,IAAIA,KAAK,CAACS,MAAM,KAAK,oCAAoC,EAAE;QACvDnH,MAAM,CAACuB,UAAU,CAAC,oCAAoC,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;UAC7EC,GAAG,EAAE,IAAI,CAAClC,SAAS;UACnBmC,SAAS,EAAE,SAAS;UACpBhH,KAAK,EAAE6G,KAAK,CAAC7G;QACjB,CAAC,CAAC;MACN;MACA,MAAM6G,KAAK;IACf;IACA,OAAO;MACHlB,QAAQ,EAAEhG,MAAM,CAACgG,QAAQ;MACzB3F,KAAK,EAAE,IAAI,CAAC4E,UAAU,CAAC,MAAM,EAAE,CAACjF,MAAM,CAACK,KAAK,CAACuH,MAAM,EAAE;IACzD,CAAC;EACL,CAAC;EACD,OAAOF,YAAY;AACvB,CAAC,CAAC1C,KAAK,CAAE;AACT,IAAI6C,eAAe,GAAG,aAAe,UAAUxC,MAAM,EAAE;EACnDtG,SAAS,CAAC8I,eAAe,EAAExC,MAAM,CAAC;EAClC,SAASwC,eAAe,CAAC5C,UAAU,EAAEzC,MAAM,EAAE0C,SAAS,EAAE;IACpD,IAAIK,KAAK,GAAG,IAAI;IAChB,IAAInD,IAAI,GAAI,OAAO,GAAGI,MAAO;IAC7B+C,KAAK,GAAGF,MAAM,CAACnF,IAAI,CAAC,IAAI,EAAE+E,UAAU,EAAE7C,IAAI,EAAEA,IAAI,EAAE8C,SAAS,EAAE,KAAK,CAAC,IAAI,IAAI;IAC3EK,KAAK,CAAC/C,MAAM,GAAGA,MAAM;IACrB,OAAO+C,KAAK;EAChB;EACAsC,eAAe,CAAClI,SAAS,CAAC+F,MAAM,GAAG,UAAUrF,KAAK,EAAE;IAChD,IAAIL,MAAM,GAAG,IAAI8H,UAAU,CAAC,EAAE,CAAC;IAC/B,IAAI;MACA,IAAIlC,IAAI,GAAGjF,OAAO,CAACoF,QAAQ,CAAC1F,KAAK,CAAC;MAClC,IAAIuF,IAAI,CAACpD,MAAM,KAAK,IAAI,CAACA,MAAM,EAAE;QAC7B,MAAM,IAAIP,KAAK,CAAC,uBAAuB,CAAC;MAC5C;MACAjC,MAAM,CAAC+H,GAAG,CAACnC,IAAI,CAAC;IACpB,CAAC,CACD,OAAOsB,KAAK,EAAE;MACV1G,MAAM,CAACuB,UAAU,CAAC,UAAU,GAAG,IAAI,CAACK,IAAI,GAAG,QAAQ,EAAE5B,MAAM,CAAC2G,gBAAgB,EAAE;QAC1EC,GAAG,EAAE,IAAI,CAAClC,SAAS;QACnBmC,SAAS,EAAE,IAAI,CAACjF,IAAI;QACpB/B,KAAK,EAAG6G,KAAK,CAAC7G,KAAK,IAAIA;MAC3B,CAAC,CAAC;IACN;IACA,OAAOL,MAAM;EACjB,CAAC;EACD6H,eAAe,CAAClI,SAAS,CAACgG,MAAM,GAAG,UAAUC,IAAI,EAAEC,MAAM,EAAE;IACvD,IAAID,IAAI,CAACpD,MAAM,GAAGqD,MAAM,GAAG,EAAE,EAAE;MAC3BrF,MAAM,CAACuB,UAAU,CAAC,wBAAwB,GAAG,IAAI,CAACK,IAAI,GAAG,OAAO,EAAE5B,MAAM,CAAC2G,gBAAgB,EAAE;QACvFC,GAAG,EAAE,IAAI,CAAClC,SAAS;QACnBmC,SAAS,EAAE,IAAI,CAACjF,IAAI;QACpB/B,KAAK,EAAEM,OAAO,CAAC2G,OAAO,CAAC1B,IAAI,CAAC2B,KAAK,CAAC1B,MAAM,EAAEA,MAAM,GAAG,EAAE,CAAC;MAC1D,CAAC,CAAC;IACN;IACA,OAAO;MACHG,QAAQ,EAAE,EAAE;MACZ3F,KAAK,EAAE,IAAI,CAAC4E,UAAU,CAAC,IAAI,CAAC7C,IAAI,EAAEzB,OAAO,CAAC2G,OAAO,CAAC1B,IAAI,CAAC2B,KAAK,CAAC1B,MAAM,EAAEA,MAAM,GAAG,IAAI,CAACrD,MAAM,CAAC,CAAC;IAC/F,CAAC;EACL,CAAC;EACD,OAAOqF,eAAe;AAC1B,CAAC,CAAC7C,KAAK,CAAE;AACT,IAAIgD,YAAY,GAAG,aAAe,UAAU3C,MAAM,EAAE;EAChDtG,SAAS,CAACiJ,YAAY,EAAE3C,MAAM,CAAC;EAC/B,SAAS2C,YAAY,CAAC/C,UAAU,EAAEC,SAAS,EAAE;IACzC,OAAOG,MAAM,CAACnF,IAAI,CAAC,IAAI,EAAE+E,UAAU,EAAE,SAAS,EAAE,SAAS,EAAEC,SAAS,EAAE,KAAK,CAAC,IAAI,IAAI;EACxF;EACA8C,YAAY,CAACrI,SAAS,CAAC+F,MAAM,GAAG,UAAUrF,KAAK,EAAE;IAC7C,IAAIL,MAAM,GAAG,IAAI8H,UAAU,CAAC,EAAE,CAAC;IAC/B,IAAI;MACA9H,MAAM,CAAC+H,GAAG,CAACpH,OAAO,CAACoF,QAAQ,CAACtF,SAAS,CAACwH,UAAU,CAAC5H,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;IACjE,CAAC,CACD,OAAO6G,KAAK,EAAE;MACV1G,MAAM,CAACuB,UAAU,CAAC,iBAAiB,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;QAC1DC,GAAG,EAAE,IAAI,CAAClC,SAAS;QACnBmC,SAAS,EAAE,SAAS;QACpBhH,KAAK,EAAEA;MACX,CAAC,CAAC;IACN;IACA,OAAOL,MAAM;EACjB,CAAC;EACDgI,YAAY,CAACrI,SAAS,CAACgG,MAAM,GAAG,UAAUC,IAAI,EAAEC,MAAM,EAAE;IACpD,IAAID,IAAI,CAACpD,MAAM,GAAGqD,MAAM,GAAG,EAAE,EAAE;MAC3BrF,MAAM,CAACuB,UAAU,CAAC,oCAAoC,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;QAC7EC,GAAG,EAAE,IAAI,CAAClC,SAAS;QACnBmC,SAAS,EAAE,SAAS;QACpBhH,KAAK,EAAEM,OAAO,CAAC2G,OAAO,CAAC1B,IAAI,CAAC2B,KAAK,CAAC1B,MAAM,EAAEA,MAAM,GAAG,EAAE,CAAC;MAC1D,CAAC,CAAC;IACN;IACA,OAAO;MACHG,QAAQ,EAAE,EAAE;MACZ3F,KAAK,EAAE,IAAI,CAAC4E,UAAU,CAAC,SAAS,EAAExE,SAAS,CAACwH,UAAU,CAACtH,OAAO,CAAC2G,OAAO,CAAC1B,IAAI,CAAC2B,KAAK,CAAC1B,MAAM,GAAG,EAAE,EAAEA,MAAM,GAAG,EAAE,CAAC,CAAC,CAAC;IACjH,CAAC;EACL,CAAC;EACD,OAAOmC,YAAY;AACvB,CAAC,CAAChD,KAAK,CAAE;AACT,SAASkD,mBAAmB,CAAC7H,KAAK,EAAE;EAChC,IAAI8H,UAAU,GAAG,EAAE,GAAGC,IAAI,CAACC,IAAI,CAAChI,KAAK,CAACmC,MAAM,GAAG,EAAE,CAAC;EAClD,IAAI8F,OAAO,GAAG,IAAIR,UAAU,CAACK,UAAU,GAAG9H,KAAK,CAACmC,MAAM,CAAC;EACvD,OAAO7B,OAAO,CAAC4H,MAAM,CAAC,CAClBd,YAAY,CAAC/B,MAAM,CAACrF,KAAK,CAACmC,MAAM,CAAC,EACjCnC,KAAK,EACLiI,OAAO,CACV,CAAC;AACN;AACA,SAASE,mBAAmB,CAAC5C,IAAI,EAAEC,MAAM,EAAEX,SAAS,EAAE;EAClD,IAAIU,IAAI,CAACpD,MAAM,GAAGqD,MAAM,GAAG,EAAE,EAAE;IAC3BrF,MAAM,CAACuB,UAAU,CAAC,2CAA2C,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;MACpFC,GAAG,EAAElC,SAAS;MACdmC,SAAS,EAAE,cAAc;MACzBhH,KAAK,EAAEM,OAAO,CAAC2G,OAAO,CAAC1B,IAAI,CAAC2B,KAAK,CAAC1B,MAAM,EAAEA,MAAM,GAAG,EAAE,CAAC;IAC1D,CAAC,CAAC;EACN;EACA,IAAIrD,MAAM,GAAGiF,YAAY,CAAC9B,MAAM,CAACC,IAAI,EAAEC,MAAM,CAAC,CAACxF,KAAK;EACpD,IAAI;IACAmC,MAAM,GAAGA,MAAM,CAAClB,QAAQ,EAAE;EAC9B,CAAC,CACD,OAAO4F,KAAK,EAAE;IACV1G,MAAM,CAACuB,UAAU,CAAC,+BAA+B,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;MACxEC,GAAG,EAAElC,SAAS;MACdmC,SAAS,EAAE,cAAc;MACzBhH,KAAK,EAAEmC,MAAM,CAACiG,QAAQ;IAC1B,CAAC,CAAC;EACN;EACA,IAAI7C,IAAI,CAACpD,MAAM,GAAGqD,MAAM,GAAG,EAAE,GAAGrD,MAAM,EAAE;IACpChC,MAAM,CAACuB,UAAU,CAAC,yCAAyC,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;MAClFC,GAAG,EAAElC,SAAS;MACdmC,SAAS,EAAE,cAAc;MACzBhH,KAAK,EAAEM,OAAO,CAAC2G,OAAO,CAAC1B,IAAI,CAAC2B,KAAK,CAAC1B,MAAM,EAAEA,MAAM,GAAG,EAAE,GAAGrD,MAAM,CAAC;IACnE,CAAC,CAAC;EACN;EACA,OAAO;IACHwD,QAAQ,EAAE,EAAE,GAAG,EAAE,GAAGoC,IAAI,CAACC,IAAI,CAAC7F,MAAM,GAAG,EAAE,CAAC;IAC1CnC,KAAK,EAAEuF,IAAI,CAAC2B,KAAK,CAAC1B,MAAM,GAAG,EAAE,EAAEA,MAAM,GAAG,EAAE,GAAGrD,MAAM;EACvD,CAAC;AACL;AACA,IAAIkG,iBAAiB,GAAG,aAAe,UAAUrD,MAAM,EAAE;EACrDtG,SAAS,CAAC2J,iBAAiB,EAAErD,MAAM,CAAC;EACpC,SAASqD,iBAAiB,CAACzD,UAAU,EAAEC,SAAS,EAAE;IAC9C,OAAOG,MAAM,CAACnF,IAAI,CAAC,IAAI,EAAE+E,UAAU,EAAE,OAAO,EAAE,OAAO,EAAEC,SAAS,EAAE,IAAI,CAAC,IAAI,IAAI;EACnF;EACAwD,iBAAiB,CAAC/I,SAAS,CAAC+F,MAAM,GAAG,UAAUrF,KAAK,EAAE;IAClD,IAAI;MACA,OAAO6H,mBAAmB,CAACvH,OAAO,CAACoF,QAAQ,CAAC1F,KAAK,CAAC,CAAC;IACvD,CAAC,CACD,OAAO6G,KAAK,EAAE;MACV1G,MAAM,CAACuB,UAAU,CAAC,qBAAqB,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;QAC9DC,GAAG,EAAE,IAAI,CAAClC,SAAS;QACnBmC,SAAS,EAAE,OAAO;QAClBhH,KAAK,EAAE6G,KAAK,CAAC7G;MACjB,CAAC,CAAC;IACN;IACA,OAAO,IAAI;EACf,CAAC;EACDqI,iBAAiB,CAAC/I,SAAS,CAACgG,MAAM,GAAG,UAAUC,IAAI,EAAEC,MAAM,EAAE;IACzD,IAAI7F,MAAM,GAAGwI,mBAAmB,CAAC5C,IAAI,EAAEC,MAAM,EAAE,IAAI,CAACX,SAAS,CAAC;IAC9DlF,MAAM,CAACK,KAAK,GAAG,IAAI,CAAC4E,UAAU,CAAC,OAAO,EAAEtE,OAAO,CAAC2G,OAAO,CAACtH,MAAM,CAACK,KAAK,CAAC,CAAC;IACtE,OAAOL,MAAM;EACjB,CAAC;EACD,OAAO0I,iBAAiB;AAC5B,CAAC,CAAC1D,KAAK,CAAE;AACT,IAAI2D,WAAW,GAAG,aAAe,UAAUtD,MAAM,EAAE;EAC/CtG,SAAS,CAAC4J,WAAW,EAAEtD,MAAM,CAAC;EAC9B,SAASsD,WAAW,CAAC1D,UAAU,EAAEC,SAAS,EAAE;IACxC,OAAOG,MAAM,CAACnF,IAAI,CAAC,IAAI,EAAE+E,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAEC,SAAS,EAAE,IAAI,CAAC,IAAI,IAAI;EACrF;EACAyD,WAAW,CAAChJ,SAAS,CAAC+F,MAAM,GAAG,UAAUrF,KAAK,EAAE;IAC5C,IAAI,OAAQA,KAAM,KAAK,QAAQ,EAAE;MAC7BG,MAAM,CAACuB,UAAU,CAAC,sBAAsB,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;QAC/DC,GAAG,EAAE,IAAI,CAAClC,SAAS;QACnBmC,SAAS,EAAE,QAAQ;QACnBhH,KAAK,EAAEA;MACX,CAAC,CAAC;IACN;IACA,OAAO6H,mBAAmB,CAACtH,MAAM,CAACgI,WAAW,CAACvI,KAAK,CAAC,CAAC;EACzD,CAAC;EACDsI,WAAW,CAAChJ,SAAS,CAACgG,MAAM,GAAG,UAAUC,IAAI,EAAEC,MAAM,EAAE;IACnD,IAAI7F,MAAM,GAAGwI,mBAAmB,CAAC5C,IAAI,EAAEC,MAAM,EAAE,IAAI,CAACX,SAAS,CAAC;IAC9DlF,MAAM,CAACK,KAAK,GAAG,IAAI,CAAC4E,UAAU,CAAC,QAAQ,EAAErE,MAAM,CAACiI,YAAY,CAAC7I,MAAM,CAACK,KAAK,CAAC,CAAC;IAC3E,OAAOL,MAAM;EACjB,CAAC;EACD,OAAO2I,WAAW;AACtB,CAAC,CAAC3D,KAAK,CAAE;AACT,SAAS8D,SAAS,CAAC5C,IAAI,EAAE;EACrB,OAAO,EAAE,GAAGkC,IAAI,CAACC,IAAI,CAACnC,IAAI,GAAG,EAAE,CAAC;AACpC;AACA,SAAS6C,IAAI,CAACC,MAAM,EAAEC,MAAM,EAAE;EAC1B,IAAI7J,KAAK,CAAC8J,OAAO,CAACD,MAAM,CAAC,EAAE;IACvB;EACJ,CAAC,MACI,IAAIA,MAAM,IAAI,OAAQA,MAAO,KAAK,QAAQ,EAAE;IAC7C,IAAIE,WAAW,GAAG,EAAE;IACpBH,MAAM,CAACtF,OAAO,CAAC,UAAU4B,KAAK,EAAE;MAC5B6D,WAAW,CAAClG,IAAI,CAACgG,MAAM,CAAC3D,KAAK,CAACJ,SAAS,CAAC,CAAC;IAC7C,CAAC,CAAC;IACF+D,MAAM,GAAGE,WAAW;EACxB,CAAC,MACI;IACD3I,MAAM,CAACuB,UAAU,CAAC,qBAAqB,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;MAC9DE,SAAS,EAAE,OAAO;MAClBhH,KAAK,EAAE4I;IACX,CAAC,CAAC;EACN;EACA,IAAID,MAAM,CAACxG,MAAM,KAAKyG,MAAM,CAACzG,MAAM,EAAE;IACjChC,MAAM,CAACuB,UAAU,CAAC,6BAA6B,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;MACtEE,SAAS,EAAE,OAAO;MAClBhH,KAAK,EAAE4I;IACX,CAAC,CAAC;EACN;EACA,IAAIG,KAAK,GAAG,EAAE;EACdJ,MAAM,CAACtF,OAAO,CAAC,UAAU4B,KAAK,EAAE+D,KAAK,EAAE;IACnCD,KAAK,CAACnG,IAAI,CAAC;MAAEkC,OAAO,EAAEG,KAAK,CAACH,OAAO;MAAE9E,KAAK,EAAEiF,KAAK,CAACI,MAAM,CAACuD,MAAM,CAACI,KAAK,CAAC;IAAE,CAAC,CAAC;EAC9E,CAAC,CAAC;EACF,IAAIC,UAAU,GAAG,CAAC;IAAEC,WAAW,GAAG,CAAC;EACnCH,KAAK,CAAC1F,OAAO,CAAC,UAAU8F,IAAI,EAAE;IAC1B,IAAIA,IAAI,CAACrE,OAAO,EAAE;MACdmE,UAAU,IAAI,EAAE;MAChBC,WAAW,IAAIT,SAAS,CAACU,IAAI,CAACnJ,KAAK,CAACmC,MAAM,CAAC;IAC/C,CAAC,MACI;MACD8G,UAAU,IAAIR,SAAS,CAACU,IAAI,CAACnJ,KAAK,CAACmC,MAAM,CAAC;IAC9C;EACJ,CAAC,CAAC;EACF,IAAIqD,MAAM,GAAG,CAAC;IAAE4D,aAAa,GAAGH,UAAU;EAC1C,IAAI1D,IAAI,GAAG,IAAIkC,UAAU,CAACwB,UAAU,GAAGC,WAAW,CAAC;EACnDH,KAAK,CAAC1F,OAAO,CAAC,UAAU8F,IAAI,EAAE;IAC1B,IAAIA,IAAI,CAACrE,OAAO,EAAE;MACd;MACAS,IAAI,CAACmC,GAAG,CAACN,YAAY,CAAC/B,MAAM,CAAC+D,aAAa,CAAC,EAAE5D,MAAM,CAAC;MACpDA,MAAM,IAAI,EAAE;MACZ;MACAD,IAAI,CAACmC,GAAG,CAACyB,IAAI,CAACnJ,KAAK,EAAEoJ,aAAa,CAAC;MACnCA,aAAa,IAAIX,SAAS,CAACU,IAAI,CAACnJ,KAAK,CAACmC,MAAM,CAAC;IACjD,CAAC,MACI;MACD;MACAoD,IAAI,CAACmC,GAAG,CAACyB,IAAI,CAACnJ,KAAK,EAAEwF,MAAM,CAAC;MAC5BA,MAAM,IAAIiD,SAAS,CAACU,IAAI,CAACnJ,KAAK,CAACmC,MAAM,CAAC;IAC1C;EACJ,CAAC,CAAC;EACF,OAAOoD,IAAI;AACf;AACA,SAAS8D,MAAM,CAACV,MAAM,EAAEpD,IAAI,EAAEC,MAAM,EAAE;EAClC,IAAI8D,UAAU,GAAG9D,MAAM;EACvB,IAAIG,QAAQ,GAAG,CAAC;EAChB,IAAI3F,KAAK,GAAG,EAAE;EACd2I,MAAM,CAACtF,OAAO,CAAC,UAAU4B,KAAK,EAAE;IAC5B,IAAIA,KAAK,CAACH,OAAO,EAAE;MACf,IAAIsE,aAAa,GAAGhC,YAAY,CAAC9B,MAAM,CAACC,IAAI,EAAEC,MAAM,CAAC;MACrD,IAAI7F,MAAM,GAAGsF,KAAK,CAACK,MAAM,CAACC,IAAI,EAAE+D,UAAU,GAAGF,aAAa,CAACpJ,KAAK,CAACiB,QAAQ,EAAE,CAAC;MAC5E;MACAtB,MAAM,CAACgG,QAAQ,GAAGyD,aAAa,CAACzD,QAAQ;IAC5C,CAAC,MACI;MACD,IAAIhG,MAAM,GAAGsF,KAAK,CAACK,MAAM,CAACC,IAAI,EAAEC,MAAM,CAAC;IAC3C;IACA,IAAI7F,MAAM,CAACK,KAAK,IAAImF,SAAS,EAAE;MAC3BnF,KAAK,CAAC4C,IAAI,CAACjD,MAAM,CAACK,KAAK,CAAC;IAC5B;IACAwF,MAAM,IAAI7F,MAAM,CAACgG,QAAQ;IACzBA,QAAQ,IAAIhG,MAAM,CAACgG,QAAQ;EAC/B,CAAC,CAAC;EACFgD,MAAM,CAACtF,OAAO,CAAC,UAAU4B,KAAK,EAAE+D,KAAK,EAAE;IACnC,IAAIjH,IAAI,GAAGkD,KAAK,CAACJ,SAAS;IAC1B,IAAI,CAAC9C,IAAI,EAAE;MACP;IACJ;IACA,IAAIA,IAAI,KAAK,QAAQ,EAAE;MACnBA,IAAI,GAAG,SAAS;IACpB;IACA,IAAI/B,KAAK,CAAC+B,IAAI,CAAC,IAAI,IAAI,EAAE;MACrB;IACJ;IACA/B,KAAK,CAAC+B,IAAI,CAAC,GAAG/B,KAAK,CAACgJ,KAAK,CAAC;EAC9B,CAAC,CAAC;EACF,OAAO;IACHhJ,KAAK,EAAEA,KAAK;IACZ2F,QAAQ,EAAEA;EACd,CAAC;AACL;AACA,IAAI4D,UAAU,GAAG,aAAe,UAAUvE,MAAM,EAAE;EAC9CtG,SAAS,CAAC6K,UAAU,EAAEvE,MAAM,CAAC;EAC7B,SAASuE,UAAU,CAAC3E,UAAU,EAAEK,KAAK,EAAE9C,MAAM,EAAE0C,SAAS,EAAE;IACtD,IAAIK,KAAK,GAAG,IAAI;IAChB,IAAIpE,IAAI,GAAImE,KAAK,CAACnE,IAAI,GAAG,GAAG,IAAIqB,MAAM,IAAI,CAAC,GAAGA,MAAM,GAAG,EAAE,CAAC,GAAG,GAAI;IACjE,IAAI2C,OAAO,GAAI3C,MAAM,KAAK,CAAC,CAAC,IAAI8C,KAAK,CAACH,OAAQ;IAC9CI,KAAK,GAAGF,MAAM,CAACnF,IAAI,CAAC,IAAI,EAAE+E,UAAU,EAAE,OAAO,EAAE9D,IAAI,EAAE+D,SAAS,EAAEC,OAAO,CAAC,IAAI,IAAI;IAChFI,KAAK,CAACD,KAAK,GAAGA,KAAK;IACnBC,KAAK,CAAC/C,MAAM,GAAGA,MAAM;IACrB,OAAO+C,KAAK;EAChB;EACAqE,UAAU,CAACjK,SAAS,CAAC+F,MAAM,GAAG,UAAUrF,KAAK,EAAE;IAC3C,IAAI,CAACjB,KAAK,CAAC8J,OAAO,CAAC7I,KAAK,CAAC,EAAE;MACvBG,MAAM,CAACuB,UAAU,CAAC,sBAAsB,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;QAC/DC,GAAG,EAAE,IAAI,CAAClC,SAAS;QACnBmC,SAAS,EAAE,OAAO;QAClBhH,KAAK,EAAEA;MACX,CAAC,CAAC;IACN;IACA,IAAIwJ,KAAK,GAAG,IAAI,CAACrH,MAAM;IACvB,IAAIxC,MAAM,GAAG,IAAI8H,UAAU,CAAC,CAAC,CAAC;IAC9B,IAAI+B,KAAK,KAAK,CAAC,CAAC,EAAE;MACdA,KAAK,GAAGxJ,KAAK,CAACmC,MAAM;MACpBxC,MAAM,GAAGyH,YAAY,CAAC/B,MAAM,CAACmE,KAAK,CAAC;IACvC;IACArJ,MAAM,CAACsJ,kBAAkB,CAACD,KAAK,EAAExJ,KAAK,CAACmC,MAAM,EAAE,iBAAiB,IAAI,IAAI,CAAC0C,SAAS,GAAI,GAAG,GAAG,IAAI,CAACA,SAAS,GAAI,EAAE,CAAC,CAAC;IAClH,IAAI8D,MAAM,GAAG,EAAE;IACf,KAAK,IAAIhH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3B,KAAK,CAACmC,MAAM,EAAER,CAAC,EAAE,EAAE;MACnCgH,MAAM,CAAC/F,IAAI,CAAC,IAAI,CAACqC,KAAK,CAAC;IAC3B;IACA,OAAO3E,OAAO,CAAC4H,MAAM,CAAC,CAACvI,MAAM,EAAE+I,IAAI,CAACC,MAAM,EAAE3I,KAAK,CAAC,CAAC,CAAC;EACxD,CAAC;EACDuJ,UAAU,CAACjK,SAAS,CAACgG,MAAM,GAAG,UAAUC,IAAI,EAAEC,MAAM,EAAE;IAClD;IACA;IACA,IAAIG,QAAQ,GAAG,CAAC;IAChB,IAAI6D,KAAK,GAAG,IAAI,CAACrH,MAAM;IACvB,IAAIqH,KAAK,KAAK,CAAC,CAAC,EAAE;MACd,IAAI;QACA,IAAIE,aAAa,GAAGtC,YAAY,CAAC9B,MAAM,CAACC,IAAI,EAAEC,MAAM,CAAC;MACzD,CAAC,CACD,OAAOqB,KAAK,EAAE;QACV1G,MAAM,CAACuB,UAAU,CAAC,4CAA4C,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;UACrFC,GAAG,EAAE,IAAI,CAAClC,SAAS;UACnBmC,SAAS,EAAE,OAAO;UAClBhH,KAAK,EAAE6G,KAAK,CAAC7G;QACjB,CAAC,CAAC;MACN;MACA,IAAI;QACAwJ,KAAK,GAAGE,aAAa,CAAC1J,KAAK,CAACiB,QAAQ,EAAE;MAC1C,CAAC,CACD,OAAO4F,KAAK,EAAE;QACV1G,MAAM,CAACuB,UAAU,CAAC,uBAAuB,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;UAChEC,GAAG,EAAE,IAAI,CAAClC,SAAS;UACnBmC,SAAS,EAAE,OAAO;UAClBhH,KAAK,EAAE0J,aAAa,CAAC1J,KAAK,CAACoI,QAAQ;QACvC,CAAC,CAAC;MACN;MACAzC,QAAQ,IAAI+D,aAAa,CAAC/D,QAAQ;MAClCH,MAAM,IAAIkE,aAAa,CAAC/D,QAAQ;IACpC;IACA,IAAIgD,MAAM,GAAG,EAAE;IACf,KAAK,IAAIhH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6H,KAAK,EAAE7H,CAAC,EAAE,EAAE;MAC5BgH,MAAM,CAAC/F,IAAI,CAAC,IAAImC,cAAc,CAAC,IAAI,CAACE,KAAK,CAAC,CAAC;IAC/C;IACA,IAAItF,MAAM,GAAG0J,MAAM,CAACV,MAAM,EAAEpD,IAAI,EAAEC,MAAM,CAAC;IACzC7F,MAAM,CAACgG,QAAQ,IAAIA,QAAQ;IAC3BhG,MAAM,CAACK,KAAK,GAAG,IAAI,CAAC4E,UAAU,CAAC,IAAI,CAAC9D,IAAI,EAAEnB,MAAM,CAACK,KAAK,CAAC;IACvD,OAAOL,MAAM;EACjB,CAAC;EACD,OAAO4J,UAAU;AACrB,CAAC,CAAC5E,KAAK,CAAE;AACT,IAAIgF,UAAU,GAAG,aAAe,UAAU3E,MAAM,EAAE;EAC9CtG,SAAS,CAACiL,UAAU,EAAE3E,MAAM,CAAC;EAC7B,SAAS2E,UAAU,CAAC/E,UAAU,EAAE+D,MAAM,EAAE9D,SAAS,EAAE;IAC/C,IAAIK,KAAK,GAAG,IAAI;IAChB,IAAIJ,OAAO,GAAG,KAAK;IACnB,IAAI8E,KAAK,GAAG,EAAE;IACdjB,MAAM,CAACtF,OAAO,CAAC,UAAU4B,KAAK,EAAE;MAC5B,IAAIA,KAAK,CAACH,OAAO,EAAE;QACfA,OAAO,GAAG,IAAI;MAClB;MACA8E,KAAK,CAAChH,IAAI,CAACqC,KAAK,CAACnE,IAAI,CAAC;IAC1B,CAAC,CAAC;IACF,IAAIA,IAAI,GAAI,QAAQ,GAAG8I,KAAK,CAACnF,IAAI,CAAC,GAAG,CAAC,GAAG,GAAI;IAC7CS,KAAK,GAAGF,MAAM,CAACnF,IAAI,CAAC,IAAI,EAAE+E,UAAU,EAAE,OAAO,EAAE9D,IAAI,EAAE+D,SAAS,EAAEC,OAAO,CAAC,IAAI,IAAI;IAChFI,KAAK,CAACyD,MAAM,GAAGA,MAAM;IACrB,OAAOzD,KAAK;EAChB;EACAyE,UAAU,CAACrK,SAAS,CAAC+F,MAAM,GAAG,UAAUrF,KAAK,EAAE;IAC3C,OAAO0I,IAAI,CAAC,IAAI,CAACC,MAAM,EAAE3I,KAAK,CAAC;EACnC,CAAC;EACD2J,UAAU,CAACrK,SAAS,CAACgG,MAAM,GAAG,UAAUC,IAAI,EAAEC,MAAM,EAAE;IAClD,IAAI7F,MAAM,GAAG0J,MAAM,CAAC,IAAI,CAACV,MAAM,EAAEpD,IAAI,EAAEC,MAAM,CAAC;IAC9C7F,MAAM,CAACK,KAAK,GAAG,IAAI,CAAC4E,UAAU,CAAC,IAAI,CAAC9D,IAAI,EAAEnB,MAAM,CAACK,KAAK,CAAC;IACvD,OAAOL,MAAM;EACjB,CAAC;EACD,OAAOgK,UAAU;AACrB,CAAC,CAAChF,KAAK,CAAE;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAASvB,YAAY,CAACpD,KAAK,EAAE;EACzBA,KAAK,GAAGA,KAAK,CAACmD,IAAI,EAAE;EACpB,IAAIxD,MAAM,GAAG,EAAE;EACf,IAAIkK,KAAK,GAAG,EAAE;EACd,IAAIC,KAAK,GAAG,CAAC;EACb,KAAK,IAAItE,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGxF,KAAK,CAACmC,MAAM,EAAEqD,MAAM,EAAE,EAAE;IAClD,IAAIpD,CAAC,GAAGpC,KAAK,CAACwF,MAAM,CAAC;IACrB,IAAIpD,CAAC,KAAK,GAAG,IAAI0H,KAAK,KAAK,CAAC,EAAE;MAC1BnK,MAAM,CAACiD,IAAI,CAACiH,KAAK,CAAC;MAClBA,KAAK,GAAG,EAAE;IACd,CAAC,MACI;MACDA,KAAK,IAAIzH,CAAC;MACV,IAAIA,CAAC,KAAK,GAAG,EAAE;QACX0H,KAAK,EAAE;MACX,CAAC,MACI,IAAI1H,CAAC,KAAK,GAAG,EAAE;QAChB0H,KAAK,EAAE;QACP,IAAIA,KAAK,KAAK,CAAC,CAAC,EAAE;UACd,MAAM,IAAIlI,KAAK,CAAC,uBAAuB,CAAC;QAC5C;MACJ;IACJ;EACJ;EACA,IAAIiI,KAAK,EAAE;IACPlK,MAAM,CAACiD,IAAI,CAACiH,KAAK,CAAC;EACtB;EACA,OAAOlK,MAAM;AACjB;AACA;AACA,IAAIoK,eAAe,GAAG;EAClBC,OAAO,EAAErC,YAAY;EACrBsC,IAAI,EAAE5C,YAAY;EAClB6C,MAAM,EAAE5B,WAAW;EACnB6B,KAAK,EAAE9B;AACX,CAAC;AACD,SAAS+B,kBAAkB,CAACxF,UAAU,EAAEtC,UAAU,EAAEuC,SAAS,EAAE;EAC3D,IAAI,CAACvC,UAAU,EAAE;IACbA,UAAU,GAAG,EAAE;EACnB;EACA,IAAIqG,MAAM,GAAG,EAAE;EACfrG,UAAU,CAACe,OAAO,CAAC,UAAUgH,SAAS,EAAE;IACpC1B,MAAM,CAAC/F,IAAI,CAAC0B,aAAa,CAACM,UAAU,EAAEyF,SAAS,CAAC,CAAC;EACrD,CAAC,CAAC;EACF,OAAO,IAAIV,UAAU,CAAC/E,UAAU,EAAE+D,MAAM,EAAE9D,SAAS,CAAC;AACxD;AACA,SAASP,aAAa,CAACM,UAAU,EAAErD,KAAK,EAAE;EACtC,IAAI0D,KAAK,GAAG8E,eAAe,CAACxI,KAAK,CAACT,IAAI,CAAC;EACvC,IAAImE,KAAK,EAAE;IACP,OAAO,IAAIA,KAAK,CAACL,UAAU,EAAErD,KAAK,CAACQ,IAAI,CAAC;EAC5C;EACA,IAAIhB,KAAK,GAAGQ,KAAK,CAACT,IAAI,CAACC,KAAK,CAACJ,eAAe,CAAC;EAC7C,IAAII,KAAK,EAAE;IACP,IAAI8E,IAAI,GAAG7E,QAAQ,CAACD,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;IACtC,IAAI8E,IAAI,KAAK,CAAC,IAAIA,IAAI,GAAG,GAAG,IAAKA,IAAI,GAAG,CAAC,KAAM,CAAC,EAAE;MAC9C1F,MAAM,CAACuB,UAAU,CAAC,UAAU,GAAGX,KAAK,CAAC,CAAC,CAAC,GAAG,aAAa,EAAEZ,MAAM,CAAC2G,gBAAgB,EAAE;QAC9EC,GAAG,EAAE,OAAO;QACZ/G,KAAK,EAAEuB;MACX,CAAC,CAAC;IACN;IACA,OAAO,IAAIqE,WAAW,CAAChB,UAAU,EAAEiB,IAAI,GAAG,CAAC,EAAG9E,KAAK,CAAC,CAAC,CAAC,KAAK,KAAK,EAAGQ,KAAK,CAACQ,IAAI,CAAC;EAClF;EACA,IAAIhB,KAAK,GAAGQ,KAAK,CAACT,IAAI,CAACC,KAAK,CAACN,cAAc,CAAC;EAC5C,IAAIM,KAAK,EAAE;IACP,IAAI8E,IAAI,GAAG7E,QAAQ,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC;IAC7B,IAAI8E,IAAI,KAAK,CAAC,IAAIA,IAAI,GAAG,EAAE,EAAE;MACzB1F,MAAM,CAACuB,UAAU,CAAC,sBAAsB,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;QAC/DC,GAAG,EAAE,OAAO;QACZ/G,KAAK,EAAEuB;MACX,CAAC,CAAC;IACN;IACA,OAAO,IAAIiG,eAAe,CAAC5C,UAAU,EAAEiB,IAAI,EAAEtE,KAAK,CAACQ,IAAI,CAAC;EAC5D;EACA,IAAIhB,KAAK,GAAGQ,KAAK,CAACT,IAAI,CAACC,KAAK,CAACH,cAAc,CAAC;EAC5C,IAAIG,KAAK,EAAE;IACP,IAAI8E,IAAI,GAAG7E,QAAQ,CAACD,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC;IACrCQ,KAAK,GAAGf,YAAY,CAAC8J,WAAW,CAAC/I,KAAK,CAAC;IACvCA,KAAK,CAACT,IAAI,GAAGC,KAAK,CAAC,CAAC,CAAC;IACrBQ,KAAK,GAAGf,YAAY,CAAC+J,QAAQ,CAAChJ,KAAK,CAAC;IACpC,OAAO,IAAIgI,UAAU,CAAC3E,UAAU,EAAEN,aAAa,CAACM,UAAU,EAAErD,KAAK,CAAC,EAAEsE,IAAI,EAAEtE,KAAK,CAACQ,IAAI,CAAC;EACzF;EACA,IAAIR,KAAK,CAACT,IAAI,CAACO,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,OAAO,EAAE;IACxC,OAAO+I,kBAAkB,CAACxF,UAAU,EAAErD,KAAK,CAACe,UAAU,EAAEf,KAAK,CAACQ,IAAI,CAAC;EACvE;EACA,IAAIR,KAAK,CAACT,IAAI,KAAK,EAAE,EAAE;IACnB,OAAO,IAAI2E,SAAS,CAACb,UAAU,EAAErD,KAAK,CAACQ,IAAI,CAAC;EAChD;EACA5B,MAAM,CAACuB,UAAU,CAAC,cAAc,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;IACvDC,GAAG,EAAE,MAAM;IACX/G,KAAK,EAAEuB,KAAK,CAACT;EACjB,CAAC,CAAC;EACF,OAAO,IAAI;AACf;AACA,IAAI0J,QAAQ,GAAG,aAAe,YAAY;EACtC,SAASA,QAAQ,CAAC5F,UAAU,EAAE;IAC1BzE,MAAM,CAACsK,QAAQ,CAAC,IAAI,EAAED,QAAQ,CAAC;IAC/B,IAAI,CAAC5F,UAAU,EAAE;MACbA,UAAU,GAAG7E,OAAO,CAACc,iBAAiB;IAC1C;IACAL,YAAY,CAAC4E,cAAc,CAAC,IAAI,EAAE,YAAY,EAAER,UAAU,CAAC;EAC/D;EACA4F,QAAQ,CAAClL,SAAS,CAAC+F,MAAM,GAAG,UAAUuE,KAAK,EAAEhB,MAAM,EAAE;IACjD,IAAIgB,KAAK,CAACzH,MAAM,KAAKyG,MAAM,CAACzG,MAAM,EAAE;MAChChC,MAAM,CAACuB,UAAU,CAAC,8BAA8B,EAAEvB,MAAM,CAAC2G,gBAAgB,EAAE;QACvE0C,KAAK,EAAE;UAAEI,KAAK,EAAEA,KAAK,CAACzH,MAAM;UAAEyG,MAAM,EAAEA,MAAM,CAACzG;QAAO,CAAC;QACrDnC,KAAK,EAAE;UAAE4J,KAAK,EAAEA,KAAK;UAAEhB,MAAM,EAAEA;QAAO;MAC1C,CAAC,CAAC;IACN;IACA,IAAID,MAAM,GAAG,EAAE;IACfiB,KAAK,CAACvG,OAAO,CAAC,UAAUvC,IAAI,EAAE;MAC1B;MACA;MACA;MACA,IAAI4J,UAAU,GAAG,IAAI;MACrB,IAAI,OAAQ5J,IAAK,KAAK,QAAQ,EAAE;QAC5B4J,UAAU,GAAGpJ,UAAU,CAACR,IAAI,CAAC;MACjC,CAAC,MACI;QACD4J,UAAU,GAAG5J,IAAI;MACrB;MACA6H,MAAM,CAAC/F,IAAI,CAAC0B,aAAa,CAAC,IAAI,CAACM,UAAU,EAAE8F,UAAU,CAAC,CAAC;IAC3D,CAAC,EAAE,IAAI,CAAC;IACR,OAAOpK,OAAO,CAAC2G,OAAO,CAAC,IAAI0C,UAAU,CAAC,IAAI,CAAC/E,UAAU,EAAE+D,MAAM,EAAE,GAAG,CAAC,CAACtD,MAAM,CAACuD,MAAM,CAAC,CAAC;EACvF,CAAC;EACD4B,QAAQ,CAAClL,SAAS,CAACgG,MAAM,GAAG,UAAUsE,KAAK,EAAErE,IAAI,EAAE;IAC/C,IAAIoD,MAAM,GAAG,EAAE;IACfiB,KAAK,CAACvG,OAAO,CAAC,UAAUvC,IAAI,EAAE;MAC1B;MACA,IAAI4J,UAAU,GAAG,IAAI;MACrB,IAAI,OAAQ5J,IAAK,KAAK,QAAQ,EAAE;QAC5B4J,UAAU,GAAGpJ,UAAU,CAACR,IAAI,CAAC;MACjC,CAAC,MACI;QACD4J,UAAU,GAAGlK,YAAY,CAAC+J,QAAQ,CAACzJ,IAAI,CAAC;MAC5C;MACA6H,MAAM,CAAC/F,IAAI,CAAC0B,aAAa,CAAC,IAAI,CAACM,UAAU,EAAE8F,UAAU,CAAC,CAAC;IAC3D,CAAC,EAAE,IAAI,CAAC;IACR,OAAO,IAAIf,UAAU,CAAC,IAAI,CAAC/E,UAAU,EAAE+D,MAAM,EAAE,GAAG,CAAC,CAACrD,MAAM,CAAChF,OAAO,CAACoF,QAAQ,CAACH,IAAI,CAAC,EAAE,CAAC,CAAC,CAACvF,KAAK;EAC/F,CAAC;EACD,OAAOwK,QAAQ;AACnB,CAAC,EAAG;AACJzK,OAAO,CAACyK,QAAQ,GAAGA,QAAQ;AAC3BzK,OAAO,CAAC4K,eAAe,GAAG,IAAIH,QAAQ,EAAE"},"metadata":{},"sourceType":"script"}