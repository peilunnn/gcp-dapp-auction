{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\n\"use strict\";\n\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\nvar TIMEOUTBLOCK = 50;\nvar POLLINGTIMEOUT = 15 * TIMEOUTBLOCK; // ~average block time (seconds) * TIMEOUTBLOCK\nvar CONFIRMATIONBLOCKS = 24;\nvar Method = function Method(options) {\n  if (!options.call || !options.name) {\n    throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n  }\n  this.name = options.name;\n  this.call = options.call;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter;\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.requestManager = options.requestManager;\n\n  // reference to eth.accounts\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n};\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n  this.requestManager = requestManager;\n\n  // reference to eth.accounts\n  if (accounts) {\n    this.accounts = accounts;\n  }\n};\nMethod.prototype.createFunction = function (requestManager, accounts) {\n  var func = this.buildCall();\n  func.call = this.call;\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n  return func;\n};\nMethod.prototype.attachToObject = function (obj) {\n  var func = this.buildCall();\n  func.call = this.call;\n  var name = this.name.split('.');\n  if (name.length > 1) {\n    obj[name[0]] = obj[name[0]] || {};\n    obj[name[0]][name[1]] = func;\n  } else {\n    obj[name[0]] = func;\n  }\n};\n\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n  return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n  var _this = this;\n  if (!this.inputFormatter) {\n    return args;\n  }\n  return this.inputFormatter.map(function (formatter, index) {\n    // bind this for defaultBlock, and defaultAccount\n    return formatter ? formatter.call(_this, args[index]) : args[index];\n  });\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n  var _this = this;\n  if (_.isArray(result)) {\n    return result.map(function (res) {\n      return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n    });\n  } else {\n    return this.outputFormatter && result ? this.outputFormatter(result) : result;\n  }\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n  var call = this.getCall(args);\n  var callback = this.extractCallback(args);\n  var params = this.formatInput(args);\n  this.validateArgs(params);\n  var payload = {\n    method: call,\n    params: params,\n    callback: callback\n  };\n  if (this.transformPayload) {\n    payload = this.transformPayload(payload);\n  }\n  return payload;\n};\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n  var method = this,\n    promiseResolved = false,\n    canUnsubscribe = true,\n    timeoutCount = 0,\n    confirmationCount = 0,\n    intervalId = null,\n    receiptJSON = '',\n    gasProvided = _.isObject(payload.params[0]) && payload.params[0].gas ? payload.params[0].gas : null,\n    isContractDeployment = _.isObject(payload.params[0]) && payload.params[0].data && payload.params[0].from && !payload.params[0].to;\n\n  // add custom send Methods\n  var _ethereumCalls = [new Method({\n    name: 'getTransactionReceipt',\n    call: 'eth_getTransactionReceipt',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionReceiptFormatter\n  }), new Method({\n    name: 'getCode',\n    call: 'eth_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'eth',\n    subscriptions: {\n      'newBlockHeaders': {\n        subscriptionName: 'newHeads',\n        // replace subscription with this name\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })];\n  // attach methods to this._ethereumCall\n  var _ethereumCall = {};\n  _.each(_ethereumCalls, function (mthd) {\n    mthd.attachToObject(_ethereumCall);\n    mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n  });\n\n  // fire \"receipt\" and confirmation events and resolve after\n  var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n    if (!err) {\n      // create fake unsubscribe\n      if (!sub) {\n        sub = {\n          unsubscribe: function () {\n            clearInterval(intervalId);\n          }\n        };\n      }\n      // if we have a valid receipt we don't need to send a request\n      return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result)\n      // catch error from requesting receipt\n      ).catch(function (err) {\n        sub.unsubscribe();\n        promiseResolved = true;\n        utils._fireError({\n          message: 'Failed to check for transaction receipt:',\n          data: err\n        }, defer.eventEmitter, defer.reject);\n      })\n      // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n      .then(function (receipt) {\n        if (!receipt || !receipt.blockHash) {\n          throw new Error('Receipt missing or blockHash null');\n        }\n\n        // apply extra formatters\n        if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n          receipt = method.extraFormatters.receiptFormatter(receipt);\n        }\n\n        // check if confirmation listener exists\n        if (defer.eventEmitter.listeners('confirmation').length > 0) {\n          // If there was an immediately retrieved receipt, it's already\n          // been confirmed by the direct call to checkConfirmation needed\n          // for parity instant-seal\n          if (existingReceipt === undefined || confirmationCount !== 0) {\n            defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n          }\n          canUnsubscribe = false;\n          confirmationCount++;\n          if (confirmationCount === CONFIRMATIONBLOCKS + 1) {\n            // add 1 so we account for conf 0\n            sub.unsubscribe();\n            defer.eventEmitter.removeAllListeners();\n          }\n        }\n        return receipt;\n      })\n      // CHECK for CONTRACT DEPLOYMENT\n      .then(function (receipt) {\n        if (isContractDeployment && !promiseResolved) {\n          if (!receipt.contractAddress) {\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n              promiseResolved = true;\n            }\n            utils._fireError(new Error('The transaction receipt didn\\'t contain a contract address.'), defer.eventEmitter, defer.reject);\n            return;\n          }\n          _ethereumCall.getCode(receipt.contractAddress, function (e, code) {\n            if (!code) {\n              return;\n            }\n            if (code.length > 2) {\n              defer.eventEmitter.emit('receipt', receipt);\n\n              // if contract, return instance instead of receipt\n              if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n              } else {\n                defer.resolve(receipt);\n              }\n\n              // need to remove listeners, as they aren't removed automatically when succesfull\n              if (canUnsubscribe) {\n                defer.eventEmitter.removeAllListeners();\n              }\n            } else {\n              utils._fireError(new Error('The contract code couldn\\'t be stored, please check your gas limit.'), defer.eventEmitter, defer.reject);\n            }\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n            }\n            promiseResolved = true;\n          });\n        }\n        return receipt;\n      })\n      // CHECK for normal tx check for receipt only\n      .then(function (receipt) {\n        if (!isContractDeployment && !promiseResolved) {\n          if (!receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n            defer.eventEmitter.emit('receipt', receipt);\n            defer.resolve(receipt);\n\n            // need to remove listeners, as they aren't removed automatically when succesfull\n            if (canUnsubscribe) {\n              defer.eventEmitter.removeAllListeners();\n            }\n          } else {\n            receiptJSON = JSON.stringify(receipt, null, 2);\n            if (receipt.status === false || receipt.status === '0x0') {\n              utils._fireError(new Error(\"Transaction has been reverted by the EVM:\\n\" + receiptJSON), defer.eventEmitter, defer.reject);\n            } else {\n              utils._fireError(new Error(\"Transaction ran out of gas. Please provide more gas:\\n\" + receiptJSON), defer.eventEmitter, defer.reject);\n            }\n          }\n          if (canUnsubscribe) {\n            sub.unsubscribe();\n          }\n          promiseResolved = true;\n        }\n      })\n      // time out the transaction if not mined after 50 blocks\n      .catch(function () {\n        timeoutCount++;\n\n        // check to see if we are http polling\n        if (!!isPolling) {\n          // polling timeout is different than TIMEOUTBLOCK blocks since we are triggering every second\n          if (timeoutCount - 1 >= POLLINGTIMEOUT) {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError(new Error('Transaction was not mined within' + POLLINGTIMEOUT + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        } else {\n          if (timeoutCount - 1 >= TIMEOUTBLOCK) {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError(new Error('Transaction was not mined within 50 blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        }\n      });\n    } else {\n      sub.unsubscribe();\n      promiseResolved = true;\n      utils._fireError({\n        message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n        data: err\n      }, defer.eventEmitter, defer.reject);\n    }\n  };\n\n  // start watching for confirmation depending on the support features of the provider\n  var startWatching = function (existingReceipt) {\n    // if provider allows PUB/SUB\n    if (_.isFunction(this.requestManager.provider.on)) {\n      _ethereumCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, existingReceipt, false));\n    } else {\n      intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n    }\n  }.bind(this);\n\n  // first check if we already have a confirmed transaction\n  _ethereumCall.getTransactionReceipt(result).then(function (receipt) {\n    if (receipt && receipt.blockHash) {\n      if (defer.eventEmitter.listeners('confirmation').length > 0) {\n        // We must keep on watching for new Blocks, if a confirmation listener is present\n        startWatching(receipt);\n      }\n      checkConfirmation(receipt, false);\n    } else if (!promiseResolved) {\n      startWatching();\n    }\n  }).catch(function () {\n    if (!promiseResolved) startWatching();\n  });\n};\nvar getWallet = function (from, accounts) {\n  var wallet = null;\n\n  // is index given\n  if (_.isNumber(from)) {\n    wallet = accounts.wallet[from];\n\n    // is account given\n  } else if (_.isObject(from) && from.address && from.privateKey) {\n    wallet = from;\n\n    // search in wallet for address\n  } else {\n    wallet = accounts.wallet[from.toLowerCase()];\n  }\n  return wallet;\n};\nMethod.prototype.buildCall = function () {\n  var method = this,\n    isSendTx = method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'; // || method.call === 'personal_sendTransaction'\n\n  // actual send function\n  var send = function () {\n    var defer = promiEvent(!isSendTx),\n      payload = method.toPayload(Array.prototype.slice.call(arguments));\n\n    // CALLBACK function\n    var sendTxCallback = function (err, result) {\n      try {\n        result = method.formatOutput(result);\n      } catch (e) {\n        err = e;\n      }\n      if (result instanceof Error) {\n        err = result;\n      }\n      if (!err) {\n        if (payload.callback) {\n          payload.callback(null, result);\n        }\n      } else {\n        if (err.error) {\n          err = err.error;\n        }\n        return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n      }\n\n      // return PROMISE\n      if (!isSendTx) {\n        if (!err) {\n          defer.resolve(result);\n        }\n\n        // return PROMIEVENT\n      } else {\n        defer.eventEmitter.emit('transactionHash', result);\n        method._confirmTransaction(defer, result, payload);\n      }\n    };\n\n    // SENDS the SIGNED SIGNATURE\n    var sendSignedTx = function (sign) {\n      var signedPayload = _.extend({}, payload, {\n        method: 'eth_sendRawTransaction',\n        params: [sign.rawTransaction]\n      });\n      method.requestManager.send(signedPayload, sendTxCallback);\n    };\n    var sendRequest = function (payload, method) {\n      if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n        var wallet;\n\n        // ETH_SENDTRANSACTION\n        if (payload.method === 'eth_sendTransaction') {\n          var tx = payload.params[0];\n          wallet = getWallet(_.isObject(tx) ? tx.from : null, method.accounts);\n\n          // If wallet was found, sign tx, and send using sendRawTransaction\n          if (wallet && wallet.privateKey) {\n            return method.accounts.signTransaction(_.omit(tx, 'from'), wallet.privateKey).then(sendSignedTx);\n          }\n\n          // ETH_SIGN\n        } else if (payload.method === 'eth_sign') {\n          var data = payload.params[1];\n          wallet = getWallet(payload.params[0], method.accounts);\n\n          // If wallet was found, sign tx, and send using sendRawTransaction\n          if (wallet && wallet.privateKey) {\n            var sign = method.accounts.sign(data, wallet.privateKey);\n            if (payload.callback) {\n              payload.callback(null, sign.signature);\n            }\n            defer.resolve(sign.signature);\n            return;\n          }\n        }\n      }\n      return method.requestManager.send(payload, sendTxCallback);\n    };\n\n    // Send the actual transaction\n    if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n      var getGasPrice = new Method({\n        name: 'getGasPrice',\n        call: 'eth_gasPrice',\n        params: 0\n      }).createFunction(method.requestManager);\n      getGasPrice(function (err, gasPrice) {\n        if (gasPrice) {\n          payload.params[0].gasPrice = gasPrice;\n        }\n        sendRequest(payload, method);\n      });\n    } else {\n      sendRequest(payload, method);\n    }\n    return defer.eventEmitter;\n  };\n\n  // necessary to attach things to the method\n  send.method = method;\n  // necessary for batch requests\n  send.request = this.request.bind(this);\n  return send;\n};\n\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n  var payload = this.toPayload(Array.prototype.slice.call(arguments));\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n};\nmodule.exports = Method;","map":{"version":3,"names":["_","require","errors","formatters","utils","promiEvent","Subscriptions","subscriptions","TIMEOUTBLOCK","POLLINGTIMEOUT","CONFIRMATIONBLOCKS","Method","options","call","name","Error","params","inputFormatter","outputFormatter","transformPayload","extraFormatters","requestManager","accounts","defaultBlock","defaultAccount","prototype","setRequestManager","createFunction","func","buildCall","attachToObject","obj","split","length","getCall","args","isFunction","extractCallback","pop","validateArgs","InvalidNumberOfParams","formatInput","_this","map","formatter","index","formatOutput","result","isArray","res","toPayload","callback","payload","method","_confirmTransaction","defer","promiseResolved","canUnsubscribe","timeoutCount","confirmationCount","intervalId","receiptJSON","gasProvided","isObject","gas","isContractDeployment","data","from","to","_ethereumCalls","outputTransactionReceiptFormatter","inputAddressFormatter","inputDefaultBlockNumberFormatter","type","subscriptionName","outputBlockFormatter","_ethereumCall","each","mthd","checkConfirmation","existingReceipt","isPolling","err","blockHeader","sub","unsubscribe","clearInterval","resolve","getTransactionReceipt","catch","_fireError","message","eventEmitter","reject","then","receipt","blockHash","receiptFormatter","listeners","undefined","emit","removeAllListeners","contractAddress","getCode","e","code","contractDeployFormatter","outOfGas","gasUsed","status","JSON","stringify","startWatching","provider","on","subscribe","bind","setInterval","getWallet","wallet","isNumber","address","privateKey","toLowerCase","isSendTx","send","Array","slice","arguments","sendTxCallback","error","sendSignedTx","sign","signedPayload","extend","rawTransaction","sendRequest","tx","signTransaction","omit","signature","gasPrice","getGasPrice","request","format","module","exports"],"sources":["/home/peilunnn/Downloads/Internship Projects/gcp-dapp-auction/client/node_modules/truffle-contract/node_modules/web3-core-method/src/index.js"],"sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\n\"use strict\";\n\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\n\nvar TIMEOUTBLOCK = 50;\nvar POLLINGTIMEOUT = 15 * TIMEOUTBLOCK; // ~average block time (seconds) * TIMEOUTBLOCK\nvar CONFIRMATIONBLOCKS = 24;\n\nvar Method = function Method(options) {\n\n    if(!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n\n    this.requestManager = options.requestManager;\n\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n\n    this.defaultBlock = options.defaultBlock || 'latest';\n    this.defaultAccount = options.defaultAccount || null;\n};\n\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n    this.requestManager = requestManager;\n\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n\n};\n\nMethod.prototype.createFunction = function (requestManager, accounts) {\n    var func = this.buildCall();\n    func.call = this.call;\n\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n\n    return func;\n};\n\nMethod.prototype.attachToObject = function (obj) {\n    var func = this.buildCall();\n    func.call = this.call;\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    } else {\n        obj[name[0]] = func;\n    }\n};\n\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n    return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop(); // modify the args array!\n    }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n    var _this = this;\n\n    if (!this.inputFormatter) {\n        return args;\n    }\n\n    return this.inputFormatter.map(function (formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n    var _this = this;\n\n    if(_.isArray(result)) {\n        return result.map(function(res){\n            return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n        });\n    } else {\n        return this.outputFormatter && result ? this.outputFormatter(result) : result;\n    }\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n\n    return payload;\n};\n\n\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n    var method = this,\n        promiseResolved = false,\n        canUnsubscribe = true,\n        timeoutCount = 0,\n        confirmationCount = 0,\n        intervalId = null,\n        receiptJSON = '',\n        gasProvided = (_.isObject(payload.params[0]) && payload.params[0].gas) ? payload.params[0].gas : null,\n        isContractDeployment = _.isObject(payload.params[0]) &&\n            payload.params[0].data &&\n            payload.params[0].from &&\n            !payload.params[0].to;\n\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    subscriptionName: 'newHeads', // replace subscription with this name\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _.each(_ethereumCalls, function (mthd) {\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n\n\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function () {\n                        clearInterval(intervalId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\n            // catch error from requesting receipt\n            .catch(function (err) {\n                sub.unsubscribe();\n                promiseResolved = true;\n                utils._fireError({message: 'Failed to check for transaction receipt:', data: err}, defer.eventEmitter, defer.reject);\n            })\n            // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n            .then(function(receipt) {\n                if (!receipt || !receipt.blockHash) {\n                    throw new Error('Receipt missing or blockHash null');\n                }\n\n                // apply extra formatters\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                    receipt = method.extraFormatters.receiptFormatter(receipt);\n                }\n\n                // check if confirmation listener exists\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\n\n                    // If there was an immediately retrieved receipt, it's already\n                    // been confirmed by the direct call to checkConfirmation needed\n                    // for parity instant-seal\n                    if (existingReceipt === undefined || confirmationCount !== 0){\n                        defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                    }\n\n                    canUnsubscribe = false;\n                    confirmationCount++;\n\n                    if (confirmationCount === CONFIRMATIONBLOCKS + 1) { // add 1 so we account for conf 0\n                        sub.unsubscribe();\n                        defer.eventEmitter.removeAllListeners();\n                    }\n                }\n\n                return receipt;\n            })\n            // CHECK for CONTRACT DEPLOYMENT\n            .then(function(receipt) {\n\n                if (isContractDeployment && !promiseResolved) {\n\n                    if (!receipt.contractAddress) {\n\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                        }\n\n                        utils._fireError(new Error('The transaction receipt didn\\'t contain a contract address.'), defer.eventEmitter, defer.reject);\n                        return;\n                    }\n\n                    _ethereumCall.getCode(receipt.contractAddress, function (e, code) {\n\n                        if (!code) {\n                            return;\n                        }\n\n\n                        if (code.length > 2) {\n                            defer.eventEmitter.emit('receipt', receipt);\n\n                            // if contract, return instance instead of receipt\n                            if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                                defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                            } else {\n                                defer.resolve(receipt);\n                            }\n\n                            // need to remove listeners, as they aren't removed automatically when succesfull\n                            if (canUnsubscribe) {\n                                defer.eventEmitter.removeAllListeners();\n                            }\n\n                        } else {\n                            utils._fireError(new Error('The contract code couldn\\'t be stored, please check your gas limit.'), defer.eventEmitter, defer.reject);\n                        }\n\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                        }\n                        promiseResolved = true;\n                    });\n                }\n\n                return receipt;\n            })\n            // CHECK for normal tx check for receipt only\n            .then(function(receipt) {\n\n                if (!isContractDeployment && !promiseResolved) {\n\n                    if(!receipt.outOfGas &&\n                        (!gasProvided || gasProvided !== receipt.gasUsed) &&\n                        (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        defer.resolve(receipt);\n\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n\n                    } else {\n                        receiptJSON = JSON.stringify(receipt, null, 2);\n                        if (receipt.status === false || receipt.status === '0x0') {\n                            utils._fireError(new Error(\"Transaction has been reverted by the EVM:\\n\" + receiptJSON),\n                                defer.eventEmitter, defer.reject);\n                        } else {\n                            utils._fireError(\n                                new Error(\"Transaction ran out of gas. Please provide more gas:\\n\" + receiptJSON),\n                                defer.eventEmitter, defer.reject);\n                        }\n                    }\n\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n\n            })\n            // time out the transaction if not mined after 50 blocks\n            .catch(function () {\n                timeoutCount++;\n\n                // check to see if we are http polling\n                if(!!isPolling) {\n                    // polling timeout is different than TIMEOUTBLOCK blocks since we are triggering every second\n                    if (timeoutCount - 1 >= POLLINGTIMEOUT) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(new Error('Transaction was not mined within' + POLLINGTIMEOUT + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                } else {\n                    if (timeoutCount - 1 >= TIMEOUTBLOCK) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(new Error('Transaction was not mined within 50 blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n            });\n\n\n        } else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.', data: err}, defer.eventEmitter, defer.reject);\n        }\n    };\n\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = function(existingReceipt) {\n        // if provider allows PUB/SUB\n        if (_.isFunction(this.requestManager.provider.on)) {\n            _ethereumCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, existingReceipt, false));\n        } else {\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n        }\n    }.bind(this);\n\n\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result)\n    .then(function(receipt) {\n        if (receipt && receipt.blockHash) {\n            if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                // We must keep on watching for new Blocks, if a confirmation listener is present\n                startWatching(receipt);\n            }\n            checkConfirmation(receipt, false);\n\n        } else if (!promiseResolved) {\n            startWatching();\n        }\n    })\n    .catch(function(){\n        if (!promiseResolved) startWatching();\n    });\n\n};\n\n\nvar getWallet = function(from, accounts) {\n    var wallet = null;\n\n    // is index given\n    if (_.isNumber(from)) {\n        wallet = accounts.wallet[from];\n\n        // is account given\n    } else if (_.isObject(from) && from.address && from.privateKey) {\n        wallet = from;\n\n        // search in wallet for address\n    } else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n\n    return wallet;\n};\n\nMethod.prototype.buildCall = function() {\n    var method = this,\n        isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'); // || method.call === 'personal_sendTransaction'\n\n    // actual send function\n    var send = function () {\n        var defer = promiEvent(!isSendTx),\n            payload = method.toPayload(Array.prototype.slice.call(arguments));\n\n\n        // CALLBACK function\n        var sendTxCallback = function (err, result) {\n            try {\n                result = method.formatOutput(result);\n            } catch(e) {\n                err = e;\n            }\n\n            if (result instanceof Error) {\n                err = result;\n            }\n\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            } else {\n                if(err.error) {\n                    err = err.error;\n                }\n\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n\n            // return PROMISE\n            if (!isSendTx) {\n\n                if (!err) {\n                    defer.resolve(result);\n\n                }\n\n                // return PROMIEVENT\n            } else {\n                defer.eventEmitter.emit('transactionHash', result);\n\n                method._confirmTransaction(defer, result, payload);\n            }\n\n        };\n\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function(sign){\n\n            var signedPayload = _.extend({}, payload, {\n                method: 'eth_sendRawTransaction',\n                params: [sign.rawTransaction]\n            });\n\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n\n\n        var sendRequest = function(payload, method) {\n\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n\n                // ETH_SENDTRANSACTION\n                if (payload.method === 'eth_sendTransaction') {\n                    var tx = payload.params[0];\n                    wallet = getWallet((_.isObject(tx)) ? tx.from : null, method.accounts);\n\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        return method.accounts.signTransaction(_.omit(tx, 'from'), wallet.privateKey).then(sendSignedTx);\n                    }\n\n                    // ETH_SIGN\n                } else if (payload.method === 'eth_sign') {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n\n\n                }\n            }\n\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n\n        // Send the actual transaction\n        if(isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n\n            var getGasPrice = (new Method({\n                name: 'getGasPrice',\n                call: 'eth_gasPrice',\n                params: 0\n            })).createFunction(method.requestManager);\n\n            getGasPrice(function (err, gasPrice) {\n\n                if (gasPrice) {\n                    payload.params[0].gasPrice = gasPrice;\n                }\n                sendRequest(payload, method);\n            });\n\n        } else {\n            sendRequest(payload, method);\n        }\n\n\n        return defer.eventEmitter;\n    };\n\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\n\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\n\nmodule.exports = Method;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}