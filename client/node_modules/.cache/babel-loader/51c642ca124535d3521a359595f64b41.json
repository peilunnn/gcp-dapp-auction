{"ast":null,"code":"\"use strict\";\n\n/**\n *  Conversion Utilities\n *\n */\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar errors = __importStar(require(\"../errors\"));\n///////////////////////////////\nfunction isHexable(value) {\n  return !!value.toHexString;\n}\nexports.isHexable = isHexable;\nfunction addSlice(array) {\n  if (array.slice) {\n    return array;\n  }\n  array.slice = function () {\n    var args = Array.prototype.slice.call(arguments);\n    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n  };\n  return array;\n}\nfunction isArrayish(value) {\n  if (!value || parseInt(String(value.length)) != value.length || typeof value === 'string') {\n    return false;\n  }\n  for (var i = 0; i < value.length; i++) {\n    var v = value[i];\n    if (v < 0 || v >= 256 || parseInt(String(v)) != v) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.isArrayish = isArrayish;\nfunction arrayify(value) {\n  if (value == null) {\n    errors.throwError('cannot convert null value to array', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n  if (isHexable(value)) {\n    value = value.toHexString();\n  }\n  if (typeof value === 'string') {\n    var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n    if (!match) {\n      errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n    if (match[1] !== '0x') {\n      errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n    value = value.substring(2);\n    if (value.length % 2) {\n      value = '0' + value;\n    }\n    var result = [];\n    for (var i = 0; i < value.length; i += 2) {\n      result.push(parseInt(value.substr(i, 2), 16));\n    }\n    return addSlice(new Uint8Array(result));\n  }\n  if (isArrayish(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n  errors.throwError('invalid arrayify value', null, {\n    arg: 'value',\n    value: value,\n    type: typeof value\n  });\n  return null;\n}\nexports.arrayify = arrayify;\nfunction concat(objects) {\n  var arrays = [];\n  var length = 0;\n  for (var i = 0; i < objects.length; i++) {\n    var object = arrayify(objects[i]);\n    arrays.push(object);\n    length += object.length;\n  }\n  var result = new Uint8Array(length);\n  var offset = 0;\n  for (var i = 0; i < arrays.length; i++) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n  return addSlice(result);\n}\nexports.concat = concat;\nfunction stripZeros(value) {\n  var result = arrayify(value);\n  if (result.length === 0) {\n    return result;\n  }\n  // Find the first non-zero entry\n  var start = 0;\n  while (result[start] === 0) {\n    start++;\n  }\n  // If we started with zeros, strip them\n  if (start) {\n    result = result.slice(start);\n  }\n  return result;\n}\nexports.stripZeros = stripZeros;\nfunction padZeros(value, length) {\n  value = arrayify(value);\n  if (length < value.length) {\n    throw new Error('cannot pad');\n  }\n  var result = new Uint8Array(length);\n  result.set(value, length - value.length);\n  return addSlice(result);\n}\nexports.padZeros = padZeros;\nfunction isHexString(value, length) {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n  return true;\n}\nexports.isHexString = isHexString;\nvar HexCharacters = '0123456789abcdef';\nfunction hexlify(value) {\n  if (isHexable(value)) {\n    return value.toHexString();\n  }\n  if (typeof value === 'number') {\n    if (value < 0) {\n      errors.throwError('cannot hexlify negative value', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n    // @TODO: Roll this into the above error as a numeric fault (overflow); next version, not backward compatible\n    // We can about (value == MAX_INT) to as well, since that may indicate we underflowed already\n    if (value >= 9007199254740991) {\n      errors.throwError(\"out-of-range\", errors.NUMERIC_FAULT, {\n        operartion: \"hexlify\",\n        fault: \"out-of-safe-range\"\n      });\n    }\n    var hex = '';\n    while (value) {\n      hex = HexCharacters[value & 0x0f] + hex;\n      value = Math.floor(value / 16);\n    }\n    if (hex.length) {\n      if (hex.length % 2) {\n        hex = '0' + hex;\n      }\n      return '0x' + hex;\n    }\n    return '0x00';\n  }\n  if (typeof value === 'string') {\n    var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n    if (!match) {\n      errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n    if (match[1] !== '0x') {\n      errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n    if (value.length % 2) {\n      value = '0x0' + value.substring(2);\n    }\n    return value;\n  }\n  if (isArrayish(value)) {\n    var result = [];\n    for (var i = 0; i < value.length; i++) {\n      var v = value[i];\n      result.push(HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f]);\n    }\n    return '0x' + result.join('');\n  }\n  errors.throwError('invalid hexlify value', null, {\n    arg: 'value',\n    value: value\n  });\n  return 'never';\n}\nexports.hexlify = hexlify;\nfunction hexDataLength(data) {\n  if (!isHexString(data) || data.length % 2 !== 0) {\n    return null;\n  }\n  return (data.length - 2) / 2;\n}\nexports.hexDataLength = hexDataLength;\nfunction hexDataSlice(data, offset, endOffset) {\n  if (!isHexString(data)) {\n    errors.throwError('invalid hex data', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: data\n    });\n  }\n  if (data.length % 2 !== 0) {\n    errors.throwError('hex data length must be even', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: data\n    });\n  }\n  offset = 2 + 2 * offset;\n  if (endOffset != null) {\n    return '0x' + data.substring(offset, 2 + 2 * endOffset);\n  }\n  return '0x' + data.substring(offset);\n}\nexports.hexDataSlice = hexDataSlice;\nfunction hexStripZeros(value) {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n  while (value.length > 3 && value.substring(0, 3) === '0x0') {\n    value = '0x' + value.substring(3);\n  }\n  return value;\n}\nexports.hexStripZeros = hexStripZeros;\nfunction hexZeroPad(value, length) {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n  while (value.length < 2 * length + 2) {\n    value = '0x0' + value.substring(2);\n  }\n  return value;\n}\nexports.hexZeroPad = hexZeroPad;\nfunction isSignature(value) {\n  return value && value.r != null && value.s != null;\n}\nfunction splitSignature(signature) {\n  var v = 0;\n  var r = '0x',\n    s = '0x';\n  if (isSignature(signature)) {\n    if (signature.v == null && signature.recoveryParam == null) {\n      errors.throwError('at least on of recoveryParam or v must be specified', errors.INVALID_ARGUMENT, {\n        argument: 'signature',\n        value: signature\n      });\n    }\n    r = hexZeroPad(signature.r, 32);\n    s = hexZeroPad(signature.s, 32);\n    v = signature.v;\n    if (typeof v === 'string') {\n      v = parseInt(v, 16);\n    }\n    var recoveryParam = signature.recoveryParam;\n    if (recoveryParam == null && signature.v != null) {\n      recoveryParam = 1 - v % 2;\n    }\n    v = 27 + recoveryParam;\n  } else {\n    var bytes = arrayify(signature);\n    if (bytes.length !== 65) {\n      throw new Error('invalid signature');\n    }\n    r = hexlify(bytes.slice(0, 32));\n    s = hexlify(bytes.slice(32, 64));\n    v = bytes[64];\n    if (v !== 27 && v !== 28) {\n      v = 27 + v % 2;\n    }\n  }\n  return {\n    r: r,\n    s: s,\n    recoveryParam: v - 27,\n    v: v\n  };\n}\nexports.splitSignature = splitSignature;\nfunction joinSignature(signature) {\n  signature = splitSignature(signature);\n  return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? '0x1c' : '0x1b']));\n}\nexports.joinSignature = joinSignature;","map":{"version":3,"names":["__importStar","mod","__esModule","result","k","Object","hasOwnProperty","call","defineProperty","exports","value","errors","require","isHexable","toHexString","addSlice","array","slice","args","Array","prototype","arguments","Uint8Array","apply","isArrayish","parseInt","String","length","i","v","arrayify","throwError","INVALID_ARGUMENT","arg","match","substring","push","substr","type","concat","objects","arrays","object","offset","set","stripZeros","start","padZeros","Error","isHexString","HexCharacters","hexlify","NUMERIC_FAULT","operartion","fault","hex","Math","floor","join","hexDataLength","data","hexDataSlice","endOffset","hexStripZeros","hexZeroPad","isSignature","r","s","splitSignature","signature","recoveryParam","argument","bytes","joinSignature"],"sources":["/home/peilunnn/Downloads/Internship Projects/gcp-dapp-auction/client/node_modules/truffle-interface-adapter/node_modules/ethers/utils/bytes.js"],"sourcesContent":["\"use strict\";\n/**\n *  Conversion Utilities\n *\n */\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar errors = __importStar(require(\"../errors\"));\n///////////////////////////////\nfunction isHexable(value) {\n    return !!(value.toHexString);\n}\nexports.isHexable = isHexable;\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function () {\n        var args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nfunction isArrayish(value) {\n    if (!value || parseInt(String(value.length)) != value.length || typeof (value) === 'string') {\n        return false;\n    }\n    for (var i = 0; i < value.length; i++) {\n        var v = value[i];\n        if (v < 0 || v >= 256 || parseInt(String(v)) != v) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isArrayish = isArrayish;\nfunction arrayify(value) {\n    if (value == null) {\n        errors.throwError('cannot convert null value to array', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (typeof (value) === 'string') {\n        var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n        if (!match) {\n            errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n        }\n        if (match[1] !== '0x') {\n            errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n        }\n        value = value.substring(2);\n        if (value.length % 2) {\n            value = '0' + value;\n        }\n        var result = [];\n        for (var i = 0; i < value.length; i += 2) {\n            result.push(parseInt(value.substr(i, 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isArrayish(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    errors.throwError('invalid arrayify value', null, { arg: 'value', value: value, type: typeof (value) });\n    return null;\n}\nexports.arrayify = arrayify;\nfunction concat(objects) {\n    var arrays = [];\n    var length = 0;\n    for (var i = 0; i < objects.length; i++) {\n        var object = arrayify(objects[i]);\n        arrays.push(object);\n        length += object.length;\n    }\n    var result = new Uint8Array(length);\n    var offset = 0;\n    for (var i = 0; i < arrays.length; i++) {\n        result.set(arrays[i], offset);\n        offset += arrays[i].length;\n    }\n    return addSlice(result);\n}\nexports.concat = concat;\nfunction stripZeros(value) {\n    var result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    var start = 0;\n    while (result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nexports.stripZeros = stripZeros;\nfunction padZeros(value, length) {\n    value = arrayify(value);\n    if (length < value.length) {\n        throw new Error('cannot pad');\n    }\n    var result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nexports.padZeros = padZeros;\nfunction isHexString(value, length) {\n    if (typeof (value) !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nexports.isHexString = isHexString;\nvar HexCharacters = '0123456789abcdef';\nfunction hexlify(value) {\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (typeof (value) === 'number') {\n        if (value < 0) {\n            errors.throwError('cannot hexlify negative value', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n        }\n        // @TODO: Roll this into the above error as a numeric fault (overflow); next version, not backward compatible\n        // We can about (value == MAX_INT) to as well, since that may indicate we underflowed already\n        if (value >= 9007199254740991) {\n            errors.throwError(\"out-of-range\", errors.NUMERIC_FAULT, {\n                operartion: \"hexlify\",\n                fault: \"out-of-safe-range\"\n            });\n        }\n        var hex = '';\n        while (value) {\n            hex = HexCharacters[value & 0x0f] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = '0' + hex;\n            }\n            return '0x' + hex;\n        }\n        return '0x00';\n    }\n    if (typeof (value) === 'string') {\n        var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n        if (!match) {\n            errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n        }\n        if (match[1] !== '0x') {\n            errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n        }\n        if (value.length % 2) {\n            value = '0x0' + value.substring(2);\n        }\n        return value;\n    }\n    if (isArrayish(value)) {\n        var result = [];\n        for (var i = 0; i < value.length; i++) {\n            var v = value[i];\n            result.push(HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f]);\n        }\n        return '0x' + result.join('');\n    }\n    errors.throwError('invalid hexlify value', null, { arg: 'value', value: value });\n    return 'never';\n}\nexports.hexlify = hexlify;\nfunction hexDataLength(data) {\n    if (!isHexString(data) || (data.length % 2) !== 0) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nexports.hexDataLength = hexDataLength;\nfunction hexDataSlice(data, offset, endOffset) {\n    if (!isHexString(data)) {\n        errors.throwError('invalid hex data', errors.INVALID_ARGUMENT, { arg: 'value', value: data });\n    }\n    if ((data.length % 2) !== 0) {\n        errors.throwError('hex data length must be even', errors.INVALID_ARGUMENT, { arg: 'value', value: data });\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return '0x' + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return '0x' + data.substring(offset);\n}\nexports.hexDataSlice = hexDataSlice;\nfunction hexStripZeros(value) {\n    if (!isHexString(value)) {\n        errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n    }\n    while (value.length > 3 && value.substring(0, 3) === '0x0') {\n        value = '0x' + value.substring(3);\n    }\n    return value;\n}\nexports.hexStripZeros = hexStripZeros;\nfunction hexZeroPad(value, length) {\n    if (!isHexString(value)) {\n        errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n    }\n    while (value.length < 2 * length + 2) {\n        value = '0x0' + value.substring(2);\n    }\n    return value;\n}\nexports.hexZeroPad = hexZeroPad;\nfunction isSignature(value) {\n    return (value && value.r != null && value.s != null);\n}\nfunction splitSignature(signature) {\n    var v = 0;\n    var r = '0x', s = '0x';\n    if (isSignature(signature)) {\n        if (signature.v == null && signature.recoveryParam == null) {\n            errors.throwError('at least on of recoveryParam or v must be specified', errors.INVALID_ARGUMENT, { argument: 'signature', value: signature });\n        }\n        r = hexZeroPad(signature.r, 32);\n        s = hexZeroPad(signature.s, 32);\n        v = signature.v;\n        if (typeof (v) === 'string') {\n            v = parseInt(v, 16);\n        }\n        var recoveryParam = signature.recoveryParam;\n        if (recoveryParam == null && signature.v != null) {\n            recoveryParam = 1 - (v % 2);\n        }\n        v = 27 + recoveryParam;\n    }\n    else {\n        var bytes = arrayify(signature);\n        if (bytes.length !== 65) {\n            throw new Error('invalid signature');\n        }\n        r = hexlify(bytes.slice(0, 32));\n        s = hexlify(bytes.slice(32, 64));\n        v = bytes[64];\n        if (v !== 27 && v !== 28) {\n            v = 27 + (v % 2);\n        }\n    }\n    return {\n        r: r,\n        s: s,\n        recoveryParam: (v - 27),\n        v: v\n    };\n}\nexports.splitSignature = splitSignature;\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        (signature.recoveryParam ? '0x1c' : '0x1b')\n    ]));\n}\nexports.joinSignature = joinSignature;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}