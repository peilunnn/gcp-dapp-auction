{"ast":null,"code":"/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\n\nvar _ = require('underscore');\nvar utils = require('web3-utils');\nvar EthersAbi = require('ethers/utils/abi-coder').AbiCoder;\nvar ethersAbiCoder = new EthersAbi(function (type, value) {\n  if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n    return value.toString();\n  }\n  return value;\n});\n\n// result method\nfunction Result() {}\n\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function () {};\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n  if (_.isObject(functionName)) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n  return utils.sha3(functionName).slice(0, 10);\n};\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n  if (_.isObject(functionName)) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n  return utils.sha3(functionName);\n};\n\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n * @param {String} type\n * @param {Object} param\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n  return this.encodeParameters([type], [param]);\n};\n\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n * @param {Array} types\n * @param {Array} params\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n  return ethersAbiCoder.encode(this.mapTypes(types), params);\n};\n\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function (types) {\n  var self = this;\n  var mappedTypes = [];\n  types.forEach(function (type) {\n    if (self.isSimplifiedStructFormat(type)) {\n      var structName = Object.keys(type)[0];\n      mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n        components: self.mapStructToCoderFormat(type[structName])\n      }));\n      return;\n    }\n    mappedTypes.push(type);\n  });\n  return mappedTypes;\n};\n\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n  return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n  var type = 'tuple';\n  if (structName.indexOf('[]') > -1) {\n    type = 'tuple[]';\n    structName = structName.slice(0, -2);\n  }\n  return {\n    type: type,\n    name: structName\n  };\n};\n\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n  var self = this;\n  var components = [];\n  Object.keys(struct).forEach(function (key) {\n    if (typeof struct[key] === 'object') {\n      components.push(Object.assign(self.mapStructNameAndType(key), {\n        components: self.mapStructToCoderFormat(struct[key])\n      }));\n      return;\n    }\n    components.push({\n      name: key,\n      type: struct[key]\n    });\n  });\n  return components;\n};\n\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n  return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n  return this.decodeParameters([type], bytes)[0];\n};\n\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n  if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n    throw new Error('Returned values aren\\'t valid, did it run Out of Gas?');\n  }\n  var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''));\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  outputs.forEach(function (output, i) {\n    var decodedValue = res[returnValue.__length__];\n    decodedValue = decodedValue === '0x' ? null : decodedValue;\n    returnValue[i] = decodedValue;\n    if (_.isObject(output) && output.name) {\n      returnValue[output.name] = decodedValue;\n    }\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\n\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n  var _this = this;\n  topics = _.isArray(topics) ? topics : [topics];\n  data = data || '';\n  var notIndexedInputs = [];\n  var indexedParams = [];\n  var topicCount = 0;\n\n  // TODO check for anonymous logs?\n\n  inputs.forEach(function (input, i) {\n    if (input.indexed) {\n      indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n        return input.type.indexOf(staticType) !== -1;\n      }) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n      topicCount++;\n    } else {\n      notIndexedInputs[i] = input;\n    }\n  });\n  var nonIndexedData = data;\n  var notIndexedParams = nonIndexedData ? this.decodeParameters(notIndexedInputs, nonIndexedData) : [];\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  inputs.forEach(function (res, i) {\n    returnValue[i] = res.type === 'string' ? '' : null;\n    if (typeof notIndexedParams[i] !== 'undefined') {\n      returnValue[i] = notIndexedParams[i];\n    }\n    if (typeof indexedParams[i] !== 'undefined') {\n      returnValue[i] = indexedParams[i];\n    }\n    if (res.name) {\n      returnValue[res.name] = returnValue[i];\n    }\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\nvar coder = new ABICoder();\nmodule.exports = coder;","map":{"version":3,"names":["_","require","utils","EthersAbi","AbiCoder","ethersAbiCoder","type","value","match","isArray","isObject","constructor","name","toString","Result","ABICoder","prototype","encodeFunctionSignature","functionName","_jsonInterfaceMethodToString","sha3","slice","encodeEventSignature","encodeParameter","param","encodeParameters","types","params","encode","mapTypes","self","mappedTypes","forEach","isSimplifiedStructFormat","structName","Object","keys","push","assign","mapStructNameAndType","components","mapStructToCoderFormat","indexOf","struct","key","encodeFunctionCall","jsonInterface","inputs","replace","decodeParameter","bytes","decodeParameters","outputs","length","Error","res","decode","returnValue","__length__","output","i","decodedValue","decodeLog","data","topics","_this","notIndexedInputs","indexedParams","topicCount","input","indexed","find","staticType","nonIndexedData","notIndexedParams","coder","module","exports"],"sources":["/home/peilunnn/Downloads/Internship Projects/gcp-dapp-auction/client/node_modules/truffle-contract/node_modules/web3-eth-abi/src/index.js"],"sourcesContent":["/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\n\nvar _ = require('underscore');\nvar utils = require('web3-utils');\n\nvar EthersAbi = require('ethers/utils/abi-coder').AbiCoder;\nvar ethersAbiCoder = new EthersAbi(function (type, value) {\n    if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n        return value.toString();\n    }\n    return value;\n});\n\n// result method\nfunction Result() {\n}\n\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function () {\n};\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n    if (_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n\n    return utils.sha3(functionName).slice(0, 10);\n};\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n    if (_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n\n    return utils.sha3(functionName);\n};\n\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n * @param {String} type\n * @param {Object} param\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n    return this.encodeParameters([type], [param]);\n};\n\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n * @param {Array} types\n * @param {Array} params\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n    return ethersAbiCoder.encode(this.mapTypes(types), params);\n};\n\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function (types) {\n    var self = this;\n    var mappedTypes = [];\n    types.forEach(function (type) {\n        if (self.isSimplifiedStructFormat(type)) {\n            var structName = Object.keys(type)[0];\n            mappedTypes.push(\n                Object.assign(\n                    self.mapStructNameAndType(structName),\n                    {\n                        components: self.mapStructToCoderFormat(type[structName])\n                    }\n                )\n            );\n\n            return;\n        }\n\n        mappedTypes.push(type);\n    });\n\n    return mappedTypes;\n};\n\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n    var type = 'tuple';\n\n    if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]';\n        structName = structName.slice(0, -2);\n    }\n\n    return {type: type, name: structName};\n};\n\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n    var self = this;\n    var components = [];\n    Object.keys(struct).forEach(function (key) {\n        if (typeof struct[key] === 'object') {\n            components.push(\n                Object.assign(\n                    self.mapStructNameAndType(key),\n                    {\n                        components: self.mapStructToCoderFormat(struct[key])\n                    }\n                )\n            );\n\n            return;\n        }\n\n        components.push({\n            name: key,\n            type: struct[key]\n        });\n    });\n\n    return components;\n};\n\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n    return this.decodeParameters([type], bytes)[0];\n};\n\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n        throw new Error('Returned values aren\\'t valid, did it run Out of Gas?');\n    }\n\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''));\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n\n    outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        decodedValue = (decodedValue === '0x') ? null : decodedValue;\n\n        returnValue[i] = decodedValue;\n\n        if (_.isObject(output) && output.name) {\n            returnValue[output.name] = decodedValue;\n        }\n\n        returnValue.__length__++;\n    });\n\n    return returnValue;\n};\n\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n    var _this = this;\n    topics = _.isArray(topics) ? topics : [topics];\n\n    data = data || '';\n\n    var notIndexedInputs = [];\n    var indexedParams = [];\n    var topicCount = 0;\n\n    // TODO check for anonymous logs?\n\n    inputs.forEach(function (input, i) {\n        if (input.indexed) {\n            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n                return input.type.indexOf(staticType) !== -1;\n            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n            topicCount++;\n        } else {\n            notIndexedInputs[i] = input;\n        }\n    });\n\n\n    var nonIndexedData = data;\n    var notIndexedParams = (nonIndexedData) ? this.decodeParameters(notIndexedInputs, nonIndexedData) : [];\n\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n\n\n    inputs.forEach(function (res, i) {\n        returnValue[i] = (res.type === 'string') ? '' : null;\n\n        if (typeof notIndexedParams[i] !== 'undefined') {\n            returnValue[i] = notIndexedParams[i];\n        }\n        if (typeof indexedParams[i] !== 'undefined') {\n            returnValue[i] = indexedParams[i];\n        }\n\n        if (res.name) {\n            returnValue[res.name] = returnValue[i];\n        }\n\n        returnValue.__length__++;\n    });\n\n    return returnValue;\n};\n\nvar coder = new ABICoder();\n\nmodule.exports = coder;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}