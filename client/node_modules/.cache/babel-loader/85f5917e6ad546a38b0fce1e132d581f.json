{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\nvar Bytes = require(\"./bytes\");\nvar Nat = require(\"./nat\");\nvar elliptic = require(\"elliptic\");\nvar rlp = require(\"./rlp\");\nvar secp256k1 = new elliptic.ec(\"secp256k1\"); // eslint-disable-line\n\nvar _require = require(\"./hash\"),\n  keccak256 = _require.keccak256,\n  keccak256s = _require.keccak256s;\nvar create = function create(entropy) {\n  var innerHex = keccak256(Bytes.concat(Bytes.random(32), entropy || Bytes.random(32)));\n  var middleHex = Bytes.concat(Bytes.concat(Bytes.random(32), innerHex), Bytes.random(32));\n  var outerHex = keccak256(middleHex);\n  return fromPrivate(outerHex);\n};\nvar toChecksum = function toChecksum(address) {\n  var addressHash = keccak256s(address.slice(2));\n  var checksumAddress = \"0x\";\n  for (var i = 0; i < 40; i++) {\n    checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];\n  }\n  return checksumAddress;\n};\nvar fromPrivate = function fromPrivate(privateKey) {\n  var buffer = new Buffer(privateKey.slice(2), \"hex\");\n  var ecKey = secp256k1.keyFromPrivate(buffer);\n  var publicKey = \"0x\" + ecKey.getPublic(false, 'hex').slice(2);\n  var publicHash = keccak256(publicKey);\n  var address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return {\n    address: address,\n    privateKey: privateKey\n  };\n};\nvar encodeSignature = function encodeSignature(_ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n    v = _ref2[0],\n    r = Bytes.pad(32, _ref2[1]),\n    s = Bytes.pad(32, _ref2[2]);\n  return Bytes.flatten([r, s, v]);\n};\nvar decodeSignature = function decodeSignature(hex) {\n  return [Bytes.slice(64, Bytes.length(hex), hex), Bytes.slice(0, 32, hex), Bytes.slice(32, 64, hex)];\n};\nvar makeSigner = function makeSigner(addToV) {\n  return function (hash, privateKey) {\n    var signature = secp256k1.keyFromPrivate(new Buffer(privateKey.slice(2), \"hex\")).sign(new Buffer(hash.slice(2), \"hex\"), {\n      canonical: true\n    });\n    return encodeSignature([Nat.fromString(Bytes.fromNumber(addToV + signature.recoveryParam)), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.r.toString(16))), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.s.toString(16)))]);\n  };\n};\nvar sign = makeSigner(27); // v=27|28 instead of 0|1...\n\nvar recover = function recover(hash, signature) {\n  var vals = decodeSignature(signature);\n  var vrs = {\n    v: Bytes.toNumber(vals[0]),\n    r: vals[1].slice(2),\n    s: vals[2].slice(2)\n  };\n  var ecPublicKey = secp256k1.recoverPubKey(new Buffer(hash.slice(2), \"hex\"), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n  var publicKey = \"0x\" + ecPublicKey.encode(\"hex\", false).slice(2);\n  var publicHash = keccak256(publicKey);\n  var address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return address;\n};\nmodule.exports = {\n  create: create,\n  toChecksum: toChecksum,\n  fromPrivate: fromPrivate,\n  sign: sign,\n  makeSigner: makeSigner,\n  recover: recover,\n  encodeSignature: encodeSignature,\n  decodeSignature: decodeSignature\n};","map":{"version":3,"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","Bytes","require","Nat","elliptic","rlp","secp256k1","ec","_require","keccak256","keccak256s","create","entropy","innerHex","concat","random","middleHex","outerHex","fromPrivate","toChecksum","address","addressHash","slice","checksumAddress","parseInt","toUpperCase","privateKey","buffer","Buffer","ecKey","keyFromPrivate","publicKey","getPublic","publicHash","encodeSignature","_ref","_ref2","v","r","pad","s","flatten","decodeSignature","hex","makeSigner","addToV","hash","signature","sign","canonical","fromString","fromNumber","recoveryParam","fromNat","toString","recover","vals","vrs","toNumber","ecPublicKey","recoverPubKey","encode","module","exports"],"sources":["/home/peilunnn/Downloads/Internship Projects/gcp-dapp-auction/client/node_modules/truffle-interface-adapter/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/account.js"],"sourcesContent":["var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Bytes = require(\"./bytes\");\nvar Nat = require(\"./nat\");\nvar elliptic = require(\"elliptic\");\nvar rlp = require(\"./rlp\");\nvar secp256k1 = new elliptic.ec(\"secp256k1\"); // eslint-disable-line\n\nvar _require = require(\"./hash\"),\n    keccak256 = _require.keccak256,\n    keccak256s = _require.keccak256s;\n\nvar create = function create(entropy) {\n  var innerHex = keccak256(Bytes.concat(Bytes.random(32), entropy || Bytes.random(32)));\n  var middleHex = Bytes.concat(Bytes.concat(Bytes.random(32), innerHex), Bytes.random(32));\n  var outerHex = keccak256(middleHex);\n  return fromPrivate(outerHex);\n};\n\nvar toChecksum = function toChecksum(address) {\n  var addressHash = keccak256s(address.slice(2));\n  var checksumAddress = \"0x\";\n  for (var i = 0; i < 40; i++) {\n    checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];\n  }return checksumAddress;\n};\n\nvar fromPrivate = function fromPrivate(privateKey) {\n  var buffer = new Buffer(privateKey.slice(2), \"hex\");\n  var ecKey = secp256k1.keyFromPrivate(buffer);\n  var publicKey = \"0x\" + ecKey.getPublic(false, 'hex').slice(2);\n  var publicHash = keccak256(publicKey);\n  var address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return {\n    address: address,\n    privateKey: privateKey\n  };\n};\n\nvar encodeSignature = function encodeSignature(_ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      v = _ref2[0],\n      r = Bytes.pad(32, _ref2[1]),\n      s = Bytes.pad(32, _ref2[2]);\n\n  return Bytes.flatten([r, s, v]);\n};\n\nvar decodeSignature = function decodeSignature(hex) {\n  return [Bytes.slice(64, Bytes.length(hex), hex), Bytes.slice(0, 32, hex), Bytes.slice(32, 64, hex)];\n};\n\nvar makeSigner = function makeSigner(addToV) {\n  return function (hash, privateKey) {\n    var signature = secp256k1.keyFromPrivate(new Buffer(privateKey.slice(2), \"hex\")).sign(new Buffer(hash.slice(2), \"hex\"), { canonical: true });\n    return encodeSignature([Nat.fromString(Bytes.fromNumber(addToV + signature.recoveryParam)), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.r.toString(16))), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.s.toString(16)))]);\n  };\n};\n\nvar sign = makeSigner(27); // v=27|28 instead of 0|1...\n\nvar recover = function recover(hash, signature) {\n  var vals = decodeSignature(signature);\n  var vrs = { v: Bytes.toNumber(vals[0]), r: vals[1].slice(2), s: vals[2].slice(2) };\n  var ecPublicKey = secp256k1.recoverPubKey(new Buffer(hash.slice(2), \"hex\"), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n  var publicKey = \"0x\" + ecPublicKey.encode(\"hex\", false).slice(2);\n  var publicHash = keccak256(publicKey);\n  var address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return address;\n};\n\nmodule.exports = {\n  create: create,\n  toChecksum: toChecksum,\n  fromPrivate: fromPrivate,\n  sign: sign,\n  makeSigner: makeSigner,\n  recover: recover,\n  encodeSignature: encodeSignature,\n  decodeSignature: decodeSignature\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}