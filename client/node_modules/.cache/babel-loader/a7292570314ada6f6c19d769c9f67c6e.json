{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nvar address_1 = require(\"./address\");\nvar bignumber_1 = require(\"./bignumber\");\nvar bytes_1 = require(\"./bytes\");\nvar utf8_1 = require(\"./utf8\");\nvar properties_1 = require(\"./properties\");\nvar errors = __importStar(require(\"./errors\"));\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexports.defaultCoerceFunc = function (type, value) {\n  var match = type.match(paramTypeNumber);\n  if (match && parseInt(match[2]) <= 48) {\n    return value.toNumber();\n  }\n  return value;\n};\n///////////////////////////////////\n// Parsing for Solidity Signatures\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = 'uint256' + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = 'int256' + type.substring(3);\n  }\n  return type;\n}\nfunction parseParam(param, allowIndexed) {\n  function throwError(i) {\n    throw new Error('unexpected character \"' + param[i] + '\" at position ' + i + ' in \"' + param + '\"');\n  }\n  var parent = {\n    type: '',\n    name: '',\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n    switch (c) {\n      case '(':\n        if (!node.state.allowParams) {\n          throwError(i);\n        }\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [{\n          type: '',\n          name: '',\n          parent: node,\n          state: {\n            allowType: true\n          }\n        }];\n        node = node.components[0];\n        break;\n      case ')':\n        delete node.state;\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n        node.type = verifyType(node.type);\n        var child = node;\n        node = node.parent;\n        if (!node) {\n          throwError(i);\n        }\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n      case ',':\n        delete node.state;\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n        node.type = verifyType(node.type);\n        var sibling = {\n          type: '',\n          name: '',\n          parent: node.parent,\n          state: {\n            allowType: true\n          }\n        };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n      case ' ':\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== '') {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        }\n        // If reading name, the name is done\n        if (node.state.allowName) {\n          if (node.name !== '') {\n            if (allowIndexed && node.name === 'indexed') {\n              node.indexed = true;\n              node.name = '';\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n        break;\n      case '[':\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n      case ']':\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n    }\n  }\n  if (node.parent) {\n    throw new Error(\"unexpected eof\");\n  }\n  delete parent.state;\n  if (allowIndexed && node.name === 'indexed') {\n    node.indexed = true;\n    node.name = '';\n  }\n  parent.type = verifyType(parent.type);\n  return parent;\n}\n// @TODO: Better return type\nfunction parseSignatureEvent(fragment) {\n  var abi = {\n    anonymous: false,\n    inputs: [],\n    name: '',\n    type: 'event'\n  };\n  var match = fragment.match(regexParen);\n  if (!match) {\n    throw new Error('invalid event: ' + fragment);\n  }\n  abi.name = match[1].trim();\n  splitNesting(match[2]).forEach(function (param) {\n    param = parseParam(param, true);\n    param.indexed = !!param.indexed;\n    abi.inputs.push(param);\n  });\n  match[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'anonymous':\n        abi.anonymous = true;\n        break;\n      case '':\n        break;\n      default:\n        console.log('unknown modifier: ' + modifier);\n    }\n  });\n  if (abi.name && !abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + abi.name + '\"');\n  }\n  return abi;\n}\nfunction parseSignatureFunction(fragment) {\n  var abi = {\n    constant: false,\n    inputs: [],\n    name: '',\n    outputs: [],\n    payable: false,\n    stateMutability: null,\n    type: 'function'\n  };\n  var comps = fragment.split(' returns ');\n  var left = comps[0].match(regexParen);\n  if (!left) {\n    throw new Error('invalid signature');\n  }\n  abi.name = left[1].trim();\n  if (!abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + left[1] + '\"');\n  }\n  splitNesting(left[2]).forEach(function (param) {\n    abi.inputs.push(parseParam(param));\n  });\n  left[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'constant':\n        abi.constant = true;\n        break;\n      case 'payable':\n        abi.payable = true;\n        break;\n      case 'pure':\n        abi.constant = true;\n        abi.stateMutability = 'pure';\n        break;\n      case 'view':\n        abi.constant = true;\n        abi.stateMutability = 'view';\n        break;\n      case '':\n        break;\n      default:\n        console.log('unknown modifier: ' + modifier);\n    }\n  });\n  // We have outputs\n  if (comps.length > 1) {\n    var right = comps[1].match(regexParen);\n    if (right[1].trim() != '' || right[3].trim() != '') {\n      throw new Error('unexpected tokens');\n    }\n    splitNesting(right[2]).forEach(function (param) {\n      abi.outputs.push(parseParam(param));\n    });\n  }\n  return abi;\n}\nfunction parseParamType(type) {\n  return parseParam(type, true);\n}\nexports.parseParamType = parseParamType;\n// @TODO: Allow a second boolean to expose names\nfunction formatParamType(paramType) {\n  return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\nexports.formatParamType = formatParamType;\n// @TODO: Allow a second boolean to expose names and modifiers\nfunction formatSignature(fragment) {\n  return fragment.name + '(' + fragment.inputs.map(function (i) {\n    return formatParamType(i);\n  }).join(',') + ')';\n}\nexports.formatSignature = formatSignature;\nfunction parseSignature(fragment) {\n  if (typeof fragment === 'string') {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n    fragment = fragment.trim();\n    if (fragment.substring(0, 6) === 'event ') {\n      return parseSignatureEvent(fragment.substring(6).trim());\n    } else {\n      if (fragment.substring(0, 9) === 'function ') {\n        fragment = fragment.substring(9);\n      }\n      return parseSignatureFunction(fragment.trim());\n    }\n  }\n  throw new Error('unknown signature');\n}\nexports.parseSignature = parseSignature;\nvar Coder = /** @class */function () {\n  function Coder(coerceFunc, name, type, localName, dynamic) {\n    this.coerceFunc = coerceFunc;\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n  return Coder;\n}();\n// Clones the functionality of an existing Coder, but without a localName\nvar CoderAnonymous = /** @class */function (_super) {\n  __extends(CoderAnonymous, _super);\n  function CoderAnonymous(coder) {\n    var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n    properties_1.defineReadOnly(_this, 'coder', coder);\n    return _this;\n  }\n  CoderAnonymous.prototype.encode = function (value) {\n    return this.coder.encode(value);\n  };\n  CoderAnonymous.prototype.decode = function (data, offset) {\n    return this.coder.decode(data, offset);\n  };\n  return CoderAnonymous;\n}(Coder);\nvar CoderNull = /** @class */function (_super) {\n  __extends(CoderNull, _super);\n  function CoderNull(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n  }\n  CoderNull.prototype.encode = function (value) {\n    return bytes_1.arrayify([]);\n  };\n  CoderNull.prototype.decode = function (data, offset) {\n    if (offset > data.length) {\n      throw new Error('invalid null');\n    }\n    return {\n      consumed: 0,\n      value: this.coerceFunc('null', undefined)\n    };\n  };\n  return CoderNull;\n}(Coder);\nvar CoderNumber = /** @class */function (_super) {\n  __extends(CoderNumber, _super);\n  function CoderNumber(coerceFunc, size, signed, localName) {\n    var _this = this;\n    var name = (signed ? 'int' : 'uint') + size * 8;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.size = size;\n    _this.signed = signed;\n    return _this;\n  }\n  CoderNumber.prototype.encode = function (value) {\n    try {\n      var v = bignumber_1.bigNumberify(value);\n      v = v.toTwos(this.size * 8).maskn(this.size * 8);\n      //value = value.toTwos(size * 8).maskn(size * 8);\n      if (this.signed) {\n        v = v.fromTwos(this.size * 8).toTwos(256);\n      }\n      return bytes_1.padZeros(bytes_1.arrayify(v), 32);\n    } catch (error) {\n      errors.throwError('invalid number value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: value\n      });\n    }\n    return null;\n  };\n  CoderNumber.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n    var junkLength = 32 - this.size;\n    var value = bignumber_1.bigNumberify(data.slice(offset + junkLength, offset + 32));\n    if (this.signed) {\n      value = value.fromTwos(this.size * 8);\n    } else {\n      value = value.maskn(this.size * 8);\n    }\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, value)\n    };\n  };\n  return CoderNumber;\n}(Coder);\nvar uint256Coder = new CoderNumber(function (type, value) {\n  return value;\n}, 32, false, 'none');\nvar CoderBoolean = /** @class */function (_super) {\n  __extends(CoderBoolean, _super);\n  function CoderBoolean(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n  }\n  CoderBoolean.prototype.encode = function (value) {\n    return uint256Coder.encode(!!value ? 1 : 0);\n  };\n  CoderBoolean.prototype.decode = function (data, offset) {\n    try {\n      var result = uint256Coder.decode(data, offset);\n    } catch (error) {\n      if (error.reason === 'insufficient data for uint256 type') {\n        errors.throwError('insufficient data for boolean type', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'boolean',\n          value: error.value\n        });\n      }\n      throw error;\n    }\n    return {\n      consumed: result.consumed,\n      value: this.coerceFunc('bool', !result.value.isZero())\n    };\n  };\n  return CoderBoolean;\n}(Coder);\nvar CoderFixedBytes = /** @class */function (_super) {\n  __extends(CoderFixedBytes, _super);\n  function CoderFixedBytes(coerceFunc, length, localName) {\n    var _this = this;\n    var name = 'bytes' + length;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.length = length;\n    return _this;\n  }\n  CoderFixedBytes.prototype.encode = function (value) {\n    var result = new Uint8Array(32);\n    try {\n      var data = bytes_1.arrayify(value);\n      if (data.length > 32) {\n        throw new Error();\n      }\n      result.set(data);\n    } catch (error) {\n      errors.throwError('invalid ' + this.name + ' value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: error.value || value\n      });\n    }\n    return result;\n  };\n  CoderFixedBytes.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for ' + name + ' type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, bytes_1.hexlify(data.slice(offset, offset + this.length)))\n    };\n  };\n  return CoderFixedBytes;\n}(Coder);\nvar CoderAddress = /** @class */function (_super) {\n  __extends(CoderAddress, _super);\n  function CoderAddress(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n  }\n  CoderAddress.prototype.encode = function (value) {\n    var result = new Uint8Array(32);\n    try {\n      result.set(bytes_1.arrayify(address_1.getAddress(value)), 12);\n    } catch (error) {\n      errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: value\n      });\n    }\n    return result;\n  };\n  CoderAddress.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficuent data for address type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n    return {\n      consumed: 32,\n      value: this.coerceFunc('address', address_1.getAddress(bytes_1.hexlify(data.slice(offset + 12, offset + 32))))\n    };\n  };\n  return CoderAddress;\n}(Coder);\nfunction _encodeDynamicBytes(value) {\n  var dataLength = 32 * Math.ceil(value.length / 32);\n  var padding = new Uint8Array(dataLength - value.length);\n  return bytes_1.concat([uint256Coder.encode(value.length), value, padding]);\n}\nfunction _decodeDynamicBytes(data, offset, localName) {\n  if (data.length < offset + 32) {\n    errors.throwError('insufficient data for dynamicBytes length', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: bytes_1.hexlify(data.slice(offset, offset + 32))\n    });\n  }\n  var length = uint256Coder.decode(data, offset).value;\n  try {\n    length = length.toNumber();\n  } catch (error) {\n    errors.throwError('dynamic bytes count too large', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: length.toString()\n    });\n  }\n  if (data.length < offset + 32 + length) {\n    errors.throwError('insufficient data for dynamicBytes type', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: bytes_1.hexlify(data.slice(offset, offset + 32 + length))\n    });\n  }\n  return {\n    consumed: 32 + 32 * Math.ceil(length / 32),\n    value: data.slice(offset + 32, offset + 32 + length)\n  };\n}\nvar CoderDynamicBytes = /** @class */function (_super) {\n  __extends(CoderDynamicBytes, _super);\n  function CoderDynamicBytes(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n  }\n  CoderDynamicBytes.prototype.encode = function (value) {\n    try {\n      return _encodeDynamicBytes(bytes_1.arrayify(value));\n    } catch (error) {\n      errors.throwError('invalid bytes value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'bytes',\n        value: error.value\n      });\n    }\n    return null;\n  };\n  CoderDynamicBytes.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName);\n    result.value = this.coerceFunc('bytes', bytes_1.hexlify(result.value));\n    return result;\n  };\n  return CoderDynamicBytes;\n}(Coder);\nvar CoderString = /** @class */function (_super) {\n  __extends(CoderString, _super);\n  function CoderString(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n  }\n  CoderString.prototype.encode = function (value) {\n    if (typeof value !== 'string') {\n      errors.throwError('invalid string value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'string',\n        value: value\n      });\n    }\n    return _encodeDynamicBytes(utf8_1.toUtf8Bytes(value));\n  };\n  CoderString.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName);\n    result.value = this.coerceFunc('string', utf8_1.toUtf8String(result.value));\n    return result;\n  };\n  return CoderString;\n}(Coder);\nfunction alignSize(size) {\n  return 32 * Math.ceil(size / 32);\n}\nfunction pack(coders, values) {\n  if (Array.isArray(values)) {\n    // do nothing\n  } else if (values && typeof values === 'object') {\n    var arrayValues = [];\n    coders.forEach(function (coder) {\n      arrayValues.push(values[coder.localName]);\n    });\n    values = arrayValues;\n  } else {\n    errors.throwError('invalid tuple value', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n  if (coders.length !== values.length) {\n    errors.throwError('types/value length mismatch', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n  var parts = [];\n  coders.forEach(function (coder, index) {\n    parts.push({\n      dynamic: coder.dynamic,\n      value: coder.encode(values[index])\n    });\n  });\n  var staticSize = 0,\n    dynamicSize = 0;\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      staticSize += 32;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length);\n    }\n  });\n  var offset = 0,\n    dynamicOffset = staticSize;\n  var data = new Uint8Array(staticSize + dynamicSize);\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      //uint256Coder.encode(dynamicOffset).copy(data, offset);\n      data.set(uint256Coder.encode(dynamicOffset), offset);\n      offset += 32;\n      //part.value.copy(data, dynamicOffset);  @TODO\n      data.set(part.value, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      //part.value.copy(data, offset);  @TODO\n      data.set(part.value, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n  return data;\n}\nfunction unpack(coders, data, offset) {\n  var baseOffset = offset;\n  var consumed = 0;\n  var value = [];\n  coders.forEach(function (coder) {\n    if (coder.dynamic) {\n      var dynamicOffset = uint256Coder.decode(data, offset);\n      var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber());\n      // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n      result.consumed = dynamicOffset.consumed;\n    } else {\n      var result = coder.decode(data, offset);\n    }\n    if (result.value != undefined) {\n      value.push(result.value);\n    }\n    offset += result.consumed;\n    consumed += result.consumed;\n  });\n  coders.forEach(function (coder, index) {\n    var name = coder.localName;\n    if (!name) {\n      return;\n    }\n    if (name === 'length') {\n      name = '_length';\n    }\n    if (value[name] != null) {\n      return;\n    }\n    value[name] = value[index];\n  });\n  return {\n    value: value,\n    consumed: consumed\n  };\n}\nvar CoderArray = /** @class */function (_super) {\n  __extends(CoderArray, _super);\n  function CoderArray(coerceFunc, coder, length, localName) {\n    var _this = this;\n    var type = coder.type + '[' + (length >= 0 ? length : '') + ']';\n    var dynamic = length === -1 || coder.dynamic;\n    _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n    _this.coder = coder;\n    _this.length = length;\n    return _this;\n  }\n  CoderArray.prototype.encode = function (value) {\n    if (!Array.isArray(value)) {\n      errors.throwError('expected array value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'array',\n        value: value\n      });\n    }\n    var count = this.length;\n    var result = new Uint8Array(0);\n    if (count === -1) {\n      count = value.length;\n      result = uint256Coder.encode(count);\n    }\n    errors.checkArgumentCount(count, value.length, 'in coder array' + (this.localName ? \" \" + this.localName : \"\"));\n    var coders = [];\n    for (var i = 0; i < value.length; i++) {\n      coders.push(this.coder);\n    }\n    return bytes_1.concat([result, pack(coders, value)]);\n  };\n  CoderArray.prototype.decode = function (data, offset) {\n    // @TODO:\n    //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n    var consumed = 0;\n    var count = this.length;\n    if (count === -1) {\n      try {\n        var decodedLength = uint256Coder.decode(data, offset);\n      } catch (error) {\n        errors.throwError('insufficient data for dynamic array length', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: error.value\n        });\n      }\n      try {\n        count = decodedLength.value.toNumber();\n      } catch (error) {\n        errors.throwError('array count too large', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: decodedLength.value.toString()\n        });\n      }\n      consumed += decodedLength.consumed;\n      offset += decodedLength.consumed;\n    }\n    var coders = [];\n    for (var i = 0; i < count; i++) {\n      coders.push(new CoderAnonymous(this.coder));\n    }\n    var result = unpack(coders, data, offset);\n    result.consumed += consumed;\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n  return CoderArray;\n}(Coder);\nvar CoderTuple = /** @class */function (_super) {\n  __extends(CoderTuple, _super);\n  function CoderTuple(coerceFunc, coders, localName) {\n    var _this = this;\n    var dynamic = false;\n    var types = [];\n    coders.forEach(function (coder) {\n      if (coder.dynamic) {\n        dynamic = true;\n      }\n      types.push(coder.type);\n    });\n    var type = 'tuple(' + types.join(',') + ')';\n    _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n    _this.coders = coders;\n    return _this;\n  }\n  CoderTuple.prototype.encode = function (value) {\n    return pack(this.coders, value);\n  };\n  CoderTuple.prototype.decode = function (data, offset) {\n    var result = unpack(this.coders, data, offset);\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n  return CoderTuple;\n}(Coder);\n/*\nfunction getTypes(coders) {\n    var type = coderTuple(coders).type;\n    return type.substring(6, type.length - 1);\n}\n*/\nfunction splitNesting(value) {\n  var result = [];\n  var accum = '';\n  var depth = 0;\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n    if (c === ',' && depth === 0) {\n      result.push(accum);\n      accum = '';\n    } else {\n      accum += c;\n      if (c === '(') {\n        depth++;\n      } else if (c === ')') {\n        depth--;\n        if (depth === -1) {\n          throw new Error('unbalanced parenthsis');\n        }\n      }\n    }\n  }\n  result.push(accum);\n  return result;\n}\n// @TODO: Is there a way to return \"class\"?\nvar paramTypeSimple = {\n  address: CoderAddress,\n  bool: CoderBoolean,\n  string: CoderString,\n  bytes: CoderDynamicBytes\n};\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n  if (!components) {\n    components = [];\n  }\n  var coders = [];\n  components.forEach(function (component) {\n    coders.push(getParamCoder(coerceFunc, component));\n  });\n  return new CoderTuple(coerceFunc, coders, localName);\n}\nfunction getParamCoder(coerceFunc, param) {\n  var coder = paramTypeSimple[param.type];\n  if (coder) {\n    return new coder(coerceFunc, param.name);\n  }\n  var match = param.type.match(paramTypeNumber);\n  if (match) {\n    var size = parseInt(match[2] || \"256\");\n    if (size === 0 || size > 256 || size % 8 !== 0) {\n      errors.throwError('invalid ' + match[1] + ' bit length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n    return new CoderNumber(coerceFunc, size / 8, match[1] === 'int', param.name);\n  }\n  var match = param.type.match(paramTypeBytes);\n  if (match) {\n    var size = parseInt(match[1]);\n    if (size === 0 || size > 32) {\n      errors.throwError('invalid bytes length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n    return new CoderFixedBytes(coerceFunc, size, param.name);\n  }\n  var match = param.type.match(paramTypeArray);\n  if (match) {\n    var size = parseInt(match[2] || \"-1\");\n    param = properties_1.jsonCopy(param);\n    param.type = match[1];\n    return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);\n  }\n  if (param.type.substring(0, 5) === 'tuple') {\n    return getTupleParamCoder(coerceFunc, param.components, param.name);\n  }\n  if (param.type === '') {\n    return new CoderNull(coerceFunc, param.name);\n  }\n  errors.throwError('invalid type', errors.INVALID_ARGUMENT, {\n    arg: 'type',\n    value: param.type\n  });\n  return null;\n}\nvar AbiCoder = /** @class */function () {\n  function AbiCoder(coerceFunc) {\n    errors.checkNew(this, AbiCoder);\n    if (!coerceFunc) {\n      coerceFunc = exports.defaultCoerceFunc;\n    }\n    properties_1.defineReadOnly(this, 'coerceFunc', coerceFunc);\n  }\n  AbiCoder.prototype.encode = function (types, values) {\n    if (types.length !== values.length) {\n      errors.throwError('types/values length mismatch', errors.INVALID_ARGUMENT, {\n        count: {\n          types: types.length,\n          values: values.length\n        },\n        value: {\n          types: types,\n          values: values\n        }\n      });\n    }\n    var coders = [];\n    types.forEach(function (type) {\n      // Convert types to type objects\n      //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n      //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n      var typeObject = null;\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = type;\n      }\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    return bytes_1.hexlify(new CoderTuple(this.coerceFunc, coders, '_').encode(values));\n  };\n  AbiCoder.prototype.decode = function (types, data) {\n    var coders = [];\n    types.forEach(function (type) {\n      // See encode for details\n      var typeObject = null;\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = properties_1.jsonCopy(type);\n      }\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    return new CoderTuple(this.coerceFunc, coders, '_').decode(bytes_1.arrayify(data), 0).value;\n  };\n  return AbiCoder;\n}();\nexports.AbiCoder = AbiCoder;\nexports.defaultAbiCoder = new AbiCoder();","map":{"version":3,"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","__importStar","mod","__esModule","result","k","call","defineProperty","exports","value","address_1","require","bignumber_1","bytes_1","utf8_1","properties_1","errors","paramTypeBytes","RegExp","paramTypeNumber","paramTypeArray","defaultCoerceFunc","type","match","parseInt","toNumber","regexParen","regexIdentifier","verifyType","substring","parseParam","param","allowIndexed","throwError","i","Error","parent","name","state","allowType","node","length","c","allowParams","components","indexed","child","allowName","allowArray","sibling","push","readArray","parseSignatureEvent","fragment","abi","anonymous","inputs","trim","splitNesting","forEach","split","modifier","console","log","parseSignatureFunction","constant","outputs","payable","stateMutability","comps","left","right","parseParamType","formatParamType","paramType","getParamCoder","formatSignature","map","join","parseSignature","replace","Coder","coerceFunc","localName","dynamic","CoderAnonymous","_super","coder","_this","undefined","defineReadOnly","encode","decode","data","offset","CoderNull","arrayify","consumed","CoderNumber","size","signed","v","bigNumberify","toTwos","maskn","fromTwos","padZeros","error","INVALID_ARGUMENT","arg","coderType","hexlify","slice","junkLength","uint256Coder","CoderBoolean","reason","isZero","CoderFixedBytes","Uint8Array","set","CoderAddress","getAddress","_encodeDynamicBytes","dataLength","Math","ceil","padding","concat","_decodeDynamicBytes","toString","CoderDynamicBytes","CoderString","toUtf8Bytes","toUtf8String","alignSize","pack","coders","values","isArray","arrayValues","parts","index","staticSize","dynamicSize","part","dynamicOffset","unpack","baseOffset","CoderArray","count","checkArgumentCount","decodedLength","CoderTuple","types","accum","depth","paramTypeSimple","address","bool","string","bytes","getTupleParamCoder","component","jsonCopy","AbiCoder","checkNew","typeObject","defaultAbiCoder"],"sources":["/home/peilunnn/Downloads/Internship Projects/gcp-dapp-auction/client/node_modules/truffle-contract/node_modules/web3-eth-abi/node_modules/ethers/utils/abi-coder.js"],"sourcesContent":["'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nvar address_1 = require(\"./address\");\nvar bignumber_1 = require(\"./bignumber\");\nvar bytes_1 = require(\"./bytes\");\nvar utf8_1 = require(\"./utf8\");\nvar properties_1 = require(\"./properties\");\nvar errors = __importStar(require(\"./errors\"));\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexports.defaultCoerceFunc = function (type, value) {\n    var match = type.match(paramTypeNumber);\n    if (match && parseInt(match[2]) <= 48) {\n        return value.toNumber();\n    }\n    return value;\n};\n///////////////////////////////////\n// Parsing for Solidity Signatures\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = 'uint256' + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = 'int256' + type.substring(3);\n    }\n    return type;\n}\nfunction parseParam(param, allowIndexed) {\n    function throwError(i) {\n        throw new Error('unexpected character \"' + param[i] + '\" at position ' + i + ' in \"' + param + '\"');\n    }\n    var parent = { type: '', name: '', state: { allowType: true } };\n    var node = parent;\n    for (var i = 0; i < param.length; i++) {\n        var c = param[i];\n        switch (c) {\n            case '(':\n                if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [{ type: '', name: '', parent: node, state: { allowType: true } }];\n                node = node.components[0];\n                break;\n            case ')':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                node.type = verifyType(node.type);\n                var child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case ',':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                node.type = verifyType(node.type);\n                var sibling = { type: '', name: '', parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case ' ':\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== '') {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== '') {\n                        if (allowIndexed && node.name === 'indexed') {\n                            node.indexed = true;\n                            node.name = '';\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case '[':\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case ']':\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        throw new Error(\"unexpected eof\");\n    }\n    delete parent.state;\n    if (allowIndexed && node.name === 'indexed') {\n        node.indexed = true;\n        node.name = '';\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\n// @TODO: Better return type\nfunction parseSignatureEvent(fragment) {\n    var abi = {\n        anonymous: false,\n        inputs: [],\n        name: '',\n        type: 'event'\n    };\n    var match = fragment.match(regexParen);\n    if (!match) {\n        throw new Error('invalid event: ' + fragment);\n    }\n    abi.name = match[1].trim();\n    splitNesting(match[2]).forEach(function (param) {\n        param = parseParam(param, true);\n        param.indexed = !!param.indexed;\n        abi.inputs.push(param);\n    });\n    match[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'anonymous':\n                abi.anonymous = true;\n                break;\n            case '':\n                break;\n            default:\n                console.log('unknown modifier: ' + modifier);\n        }\n    });\n    if (abi.name && !abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + abi.name + '\"');\n    }\n    return abi;\n}\nfunction parseSignatureFunction(fragment) {\n    var abi = {\n        constant: false,\n        inputs: [],\n        name: '',\n        outputs: [],\n        payable: false,\n        stateMutability: null,\n        type: 'function'\n    };\n    var comps = fragment.split(' returns ');\n    var left = comps[0].match(regexParen);\n    if (!left) {\n        throw new Error('invalid signature');\n    }\n    abi.name = left[1].trim();\n    if (!abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + left[1] + '\"');\n    }\n    splitNesting(left[2]).forEach(function (param) {\n        abi.inputs.push(parseParam(param));\n    });\n    left[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'constant':\n                abi.constant = true;\n                break;\n            case 'payable':\n                abi.payable = true;\n                break;\n            case 'pure':\n                abi.constant = true;\n                abi.stateMutability = 'pure';\n                break;\n            case 'view':\n                abi.constant = true;\n                abi.stateMutability = 'view';\n                break;\n            case '':\n                break;\n            default:\n                console.log('unknown modifier: ' + modifier);\n        }\n    });\n    // We have outputs\n    if (comps.length > 1) {\n        var right = comps[1].match(regexParen);\n        if (right[1].trim() != '' || right[3].trim() != '') {\n            throw new Error('unexpected tokens');\n        }\n        splitNesting(right[2]).forEach(function (param) {\n            abi.outputs.push(parseParam(param));\n        });\n    }\n    return abi;\n}\nfunction parseParamType(type) {\n    return parseParam(type, true);\n}\nexports.parseParamType = parseParamType;\n// @TODO: Allow a second boolean to expose names\nfunction formatParamType(paramType) {\n    return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\nexports.formatParamType = formatParamType;\n// @TODO: Allow a second boolean to expose names and modifiers\nfunction formatSignature(fragment) {\n    return fragment.name + '(' + fragment.inputs.map(function (i) { return formatParamType(i); }).join(',') + ')';\n}\nexports.formatSignature = formatSignature;\nfunction parseSignature(fragment) {\n    if (typeof (fragment) === 'string') {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n        fragment = fragment.trim();\n        if (fragment.substring(0, 6) === 'event ') {\n            return parseSignatureEvent(fragment.substring(6).trim());\n        }\n        else {\n            if (fragment.substring(0, 9) === 'function ') {\n                fragment = fragment.substring(9);\n            }\n            return parseSignatureFunction(fragment.trim());\n        }\n    }\n    throw new Error('unknown signature');\n}\nexports.parseSignature = parseSignature;\nvar Coder = /** @class */ (function () {\n    function Coder(coerceFunc, name, type, localName, dynamic) {\n        this.coerceFunc = coerceFunc;\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    return Coder;\n}());\n// Clones the functionality of an existing Coder, but without a localName\nvar CoderAnonymous = /** @class */ (function (_super) {\n    __extends(CoderAnonymous, _super);\n    function CoderAnonymous(coder) {\n        var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n        properties_1.defineReadOnly(_this, 'coder', coder);\n        return _this;\n    }\n    CoderAnonymous.prototype.encode = function (value) { return this.coder.encode(value); };\n    CoderAnonymous.prototype.decode = function (data, offset) { return this.coder.decode(data, offset); };\n    return CoderAnonymous;\n}(Coder));\nvar CoderNull = /** @class */ (function (_super) {\n    __extends(CoderNull, _super);\n    function CoderNull(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n    }\n    CoderNull.prototype.encode = function (value) {\n        return bytes_1.arrayify([]);\n    };\n    CoderNull.prototype.decode = function (data, offset) {\n        if (offset > data.length) {\n            throw new Error('invalid null');\n        }\n        return {\n            consumed: 0,\n            value: this.coerceFunc('null', undefined)\n        };\n    };\n    return CoderNull;\n}(Coder));\nvar CoderNumber = /** @class */ (function (_super) {\n    __extends(CoderNumber, _super);\n    function CoderNumber(coerceFunc, size, signed, localName) {\n        var _this = this;\n        var name = ((signed ? 'int' : 'uint') + (size * 8));\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.size = size;\n        _this.signed = signed;\n        return _this;\n    }\n    CoderNumber.prototype.encode = function (value) {\n        try {\n            var v = bignumber_1.bigNumberify(value);\n            v = v.toTwos(this.size * 8).maskn(this.size * 8);\n            //value = value.toTwos(size * 8).maskn(size * 8);\n            if (this.signed) {\n                v = v.fromTwos(this.size * 8).toTwos(256);\n            }\n            return bytes_1.padZeros(bytes_1.arrayify(v), 32);\n        }\n        catch (error) {\n            errors.throwError('invalid number value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: value\n            });\n        }\n        return null;\n    };\n    CoderNumber.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        var junkLength = 32 - this.size;\n        var value = bignumber_1.bigNumberify(data.slice(offset + junkLength, offset + 32));\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n        else {\n            value = value.maskn(this.size * 8);\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, value),\n        };\n    };\n    return CoderNumber;\n}(Coder));\nvar uint256Coder = new CoderNumber(function (type, value) { return value; }, 32, false, 'none');\nvar CoderBoolean = /** @class */ (function (_super) {\n    __extends(CoderBoolean, _super);\n    function CoderBoolean(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n    }\n    CoderBoolean.prototype.encode = function (value) {\n        return uint256Coder.encode(!!value ? 1 : 0);\n    };\n    CoderBoolean.prototype.decode = function (data, offset) {\n        try {\n            var result = uint256Coder.decode(data, offset);\n        }\n        catch (error) {\n            if (error.reason === 'insufficient data for uint256 type') {\n                errors.throwError('insufficient data for boolean type', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'boolean',\n                    value: error.value\n                });\n            }\n            throw error;\n        }\n        return {\n            consumed: result.consumed,\n            value: this.coerceFunc('bool', !result.value.isZero())\n        };\n    };\n    return CoderBoolean;\n}(Coder));\nvar CoderFixedBytes = /** @class */ (function (_super) {\n    __extends(CoderFixedBytes, _super);\n    function CoderFixedBytes(coerceFunc, length, localName) {\n        var _this = this;\n        var name = ('bytes' + length);\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.length = length;\n        return _this;\n    }\n    CoderFixedBytes.prototype.encode = function (value) {\n        var result = new Uint8Array(32);\n        try {\n            var data = bytes_1.arrayify(value);\n            if (data.length > 32) {\n                throw new Error();\n            }\n            result.set(data);\n        }\n        catch (error) {\n            errors.throwError('invalid ' + this.name + ' value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: (error.value || value)\n            });\n        }\n        return result;\n    };\n    CoderFixedBytes.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficient data for ' + name + ' type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, bytes_1.hexlify(data.slice(offset, offset + this.length)))\n        };\n    };\n    return CoderFixedBytes;\n}(Coder));\nvar CoderAddress = /** @class */ (function (_super) {\n    __extends(CoderAddress, _super);\n    function CoderAddress(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n    }\n    CoderAddress.prototype.encode = function (value) {\n        var result = new Uint8Array(32);\n        try {\n            result.set(bytes_1.arrayify(address_1.getAddress(value)), 12);\n        }\n        catch (error) {\n            errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: value\n            });\n        }\n        return result;\n    };\n    CoderAddress.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficuent data for address type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc('address', address_1.getAddress(bytes_1.hexlify(data.slice(offset + 12, offset + 32))))\n        };\n    };\n    return CoderAddress;\n}(Coder));\nfunction _encodeDynamicBytes(value) {\n    var dataLength = 32 * Math.ceil(value.length / 32);\n    var padding = new Uint8Array(dataLength - value.length);\n    return bytes_1.concat([\n        uint256Coder.encode(value.length),\n        value,\n        padding\n    ]);\n}\nfunction _decodeDynamicBytes(data, offset, localName) {\n    if (data.length < offset + 32) {\n        errors.throwError('insufficient data for dynamicBytes length', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: bytes_1.hexlify(data.slice(offset, offset + 32))\n        });\n    }\n    var length = uint256Coder.decode(data, offset).value;\n    try {\n        length = length.toNumber();\n    }\n    catch (error) {\n        errors.throwError('dynamic bytes count too large', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: length.toString()\n        });\n    }\n    if (data.length < offset + 32 + length) {\n        errors.throwError('insufficient data for dynamicBytes type', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: bytes_1.hexlify(data.slice(offset, offset + 32 + length))\n        });\n    }\n    return {\n        consumed: 32 + 32 * Math.ceil(length / 32),\n        value: data.slice(offset + 32, offset + 32 + length),\n    };\n}\nvar CoderDynamicBytes = /** @class */ (function (_super) {\n    __extends(CoderDynamicBytes, _super);\n    function CoderDynamicBytes(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n    }\n    CoderDynamicBytes.prototype.encode = function (value) {\n        try {\n            return _encodeDynamicBytes(bytes_1.arrayify(value));\n        }\n        catch (error) {\n            errors.throwError('invalid bytes value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'bytes',\n                value: error.value\n            });\n        }\n        return null;\n    };\n    CoderDynamicBytes.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName);\n        result.value = this.coerceFunc('bytes', bytes_1.hexlify(result.value));\n        return result;\n    };\n    return CoderDynamicBytes;\n}(Coder));\nvar CoderString = /** @class */ (function (_super) {\n    __extends(CoderString, _super);\n    function CoderString(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n    }\n    CoderString.prototype.encode = function (value) {\n        if (typeof (value) !== 'string') {\n            errors.throwError('invalid string value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'string',\n                value: value\n            });\n        }\n        return _encodeDynamicBytes(utf8_1.toUtf8Bytes(value));\n    };\n    CoderString.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName);\n        result.value = this.coerceFunc('string', utf8_1.toUtf8String(result.value));\n        return result;\n    };\n    return CoderString;\n}(Coder));\nfunction alignSize(size) {\n    return 32 * Math.ceil(size / 32);\n}\nfunction pack(coders, values) {\n    if (Array.isArray(values)) {\n        // do nothing\n    }\n    else if (values && typeof (values) === 'object') {\n        var arrayValues = [];\n        coders.forEach(function (coder) {\n            arrayValues.push(values[coder.localName]);\n        });\n        values = arrayValues;\n    }\n    else {\n        errors.throwError('invalid tuple value', errors.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values\n        });\n    }\n    if (coders.length !== values.length) {\n        errors.throwError('types/value length mismatch', errors.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values\n        });\n    }\n    var parts = [];\n    coders.forEach(function (coder, index) {\n        parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });\n    });\n    var staticSize = 0, dynamicSize = 0;\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            staticSize += 32;\n            dynamicSize += alignSize(part.value.length);\n        }\n        else {\n            staticSize += alignSize(part.value.length);\n        }\n    });\n    var offset = 0, dynamicOffset = staticSize;\n    var data = new Uint8Array(staticSize + dynamicSize);\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            //uint256Coder.encode(dynamicOffset).copy(data, offset);\n            data.set(uint256Coder.encode(dynamicOffset), offset);\n            offset += 32;\n            //part.value.copy(data, dynamicOffset);  @TODO\n            data.set(part.value, dynamicOffset);\n            dynamicOffset += alignSize(part.value.length);\n        }\n        else {\n            //part.value.copy(data, offset);  @TODO\n            data.set(part.value, offset);\n            offset += alignSize(part.value.length);\n        }\n    });\n    return data;\n}\nfunction unpack(coders, data, offset) {\n    var baseOffset = offset;\n    var consumed = 0;\n    var value = [];\n    coders.forEach(function (coder) {\n        if (coder.dynamic) {\n            var dynamicOffset = uint256Coder.decode(data, offset);\n            var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber());\n            // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n            result.consumed = dynamicOffset.consumed;\n        }\n        else {\n            var result = coder.decode(data, offset);\n        }\n        if (result.value != undefined) {\n            value.push(result.value);\n        }\n        offset += result.consumed;\n        consumed += result.consumed;\n    });\n    coders.forEach(function (coder, index) {\n        var name = coder.localName;\n        if (!name) {\n            return;\n        }\n        if (name === 'length') {\n            name = '_length';\n        }\n        if (value[name] != null) {\n            return;\n        }\n        value[name] = value[index];\n    });\n    return {\n        value: value,\n        consumed: consumed\n    };\n}\nvar CoderArray = /** @class */ (function (_super) {\n    __extends(CoderArray, _super);\n    function CoderArray(coerceFunc, coder, length, localName) {\n        var _this = this;\n        var type = (coder.type + '[' + (length >= 0 ? length : '') + ']');\n        var dynamic = (length === -1 || coder.dynamic);\n        _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n        _this.coder = coder;\n        _this.length = length;\n        return _this;\n    }\n    CoderArray.prototype.encode = function (value) {\n        if (!Array.isArray(value)) {\n            errors.throwError('expected array value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'array',\n                value: value\n            });\n        }\n        var count = this.length;\n        var result = new Uint8Array(0);\n        if (count === -1) {\n            count = value.length;\n            result = uint256Coder.encode(count);\n        }\n        errors.checkArgumentCount(count, value.length, 'in coder array' + (this.localName ? (\" \" + this.localName) : \"\"));\n        var coders = [];\n        for (var i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return bytes_1.concat([result, pack(coders, value)]);\n    };\n    CoderArray.prototype.decode = function (data, offset) {\n        // @TODO:\n        //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n        var consumed = 0;\n        var count = this.length;\n        if (count === -1) {\n            try {\n                var decodedLength = uint256Coder.decode(data, offset);\n            }\n            catch (error) {\n                errors.throwError('insufficient data for dynamic array length', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: error.value\n                });\n            }\n            try {\n                count = decodedLength.value.toNumber();\n            }\n            catch (error) {\n                errors.throwError('array count too large', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: decodedLength.value.toString()\n                });\n            }\n            consumed += decodedLength.consumed;\n            offset += decodedLength.consumed;\n        }\n        var coders = [];\n        for (var i = 0; i < count; i++) {\n            coders.push(new CoderAnonymous(this.coder));\n        }\n        var result = unpack(coders, data, offset);\n        result.consumed += consumed;\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderArray;\n}(Coder));\nvar CoderTuple = /** @class */ (function (_super) {\n    __extends(CoderTuple, _super);\n    function CoderTuple(coerceFunc, coders, localName) {\n        var _this = this;\n        var dynamic = false;\n        var types = [];\n        coders.forEach(function (coder) {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        var type = ('tuple(' + types.join(',') + ')');\n        _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n        _this.coders = coders;\n        return _this;\n    }\n    CoderTuple.prototype.encode = function (value) {\n        return pack(this.coders, value);\n    };\n    CoderTuple.prototype.decode = function (data, offset) {\n        var result = unpack(this.coders, data, offset);\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderTuple;\n}(Coder));\n/*\nfunction getTypes(coders) {\n    var type = coderTuple(coders).type;\n    return type.substring(6, type.length - 1);\n}\n*/\nfunction splitNesting(value) {\n    var result = [];\n    var accum = '';\n    var depth = 0;\n    for (var offset = 0; offset < value.length; offset++) {\n        var c = value[offset];\n        if (c === ',' && depth === 0) {\n            result.push(accum);\n            accum = '';\n        }\n        else {\n            accum += c;\n            if (c === '(') {\n                depth++;\n            }\n            else if (c === ')') {\n                depth--;\n                if (depth === -1) {\n                    throw new Error('unbalanced parenthsis');\n                }\n            }\n        }\n    }\n    result.push(accum);\n    return result;\n}\n// @TODO: Is there a way to return \"class\"?\nvar paramTypeSimple = {\n    address: CoderAddress,\n    bool: CoderBoolean,\n    string: CoderString,\n    bytes: CoderDynamicBytes,\n};\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n    if (!components) {\n        components = [];\n    }\n    var coders = [];\n    components.forEach(function (component) {\n        coders.push(getParamCoder(coerceFunc, component));\n    });\n    return new CoderTuple(coerceFunc, coders, localName);\n}\nfunction getParamCoder(coerceFunc, param) {\n    var coder = paramTypeSimple[param.type];\n    if (coder) {\n        return new coder(coerceFunc, param.name);\n    }\n    var match = param.type.match(paramTypeNumber);\n    if (match) {\n        var size = parseInt(match[2] || \"256\");\n        if (size === 0 || size > 256 || (size % 8) !== 0) {\n            errors.throwError('invalid ' + match[1] + ' bit length', errors.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param\n            });\n        }\n        return new CoderNumber(coerceFunc, size / 8, (match[1] === 'int'), param.name);\n    }\n    var match = param.type.match(paramTypeBytes);\n    if (match) {\n        var size = parseInt(match[1]);\n        if (size === 0 || size > 32) {\n            errors.throwError('invalid bytes length', errors.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param\n            });\n        }\n        return new CoderFixedBytes(coerceFunc, size, param.name);\n    }\n    var match = param.type.match(paramTypeArray);\n    if (match) {\n        var size = parseInt(match[2] || \"-1\");\n        param = properties_1.jsonCopy(param);\n        param.type = match[1];\n        return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);\n    }\n    if (param.type.substring(0, 5) === 'tuple') {\n        return getTupleParamCoder(coerceFunc, param.components, param.name);\n    }\n    if (param.type === '') {\n        return new CoderNull(coerceFunc, param.name);\n    }\n    errors.throwError('invalid type', errors.INVALID_ARGUMENT, {\n        arg: 'type',\n        value: param.type\n    });\n    return null;\n}\nvar AbiCoder = /** @class */ (function () {\n    function AbiCoder(coerceFunc) {\n        errors.checkNew(this, AbiCoder);\n        if (!coerceFunc) {\n            coerceFunc = exports.defaultCoerceFunc;\n        }\n        properties_1.defineReadOnly(this, 'coerceFunc', coerceFunc);\n    }\n    AbiCoder.prototype.encode = function (types, values) {\n        if (types.length !== values.length) {\n            errors.throwError('types/values length mismatch', errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n        var coders = [];\n        types.forEach(function (type) {\n            // Convert types to type objects\n            //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n            //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n            var typeObject = null;\n            if (typeof (type) === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = type;\n            }\n            coders.push(getParamCoder(this.coerceFunc, typeObject));\n        }, this);\n        return bytes_1.hexlify(new CoderTuple(this.coerceFunc, coders, '_').encode(values));\n    };\n    AbiCoder.prototype.decode = function (types, data) {\n        var coders = [];\n        types.forEach(function (type) {\n            // See encode for details\n            var typeObject = null;\n            if (typeof (type) === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = properties_1.jsonCopy(type);\n            }\n            coders.push(getParamCoder(this.coerceFunc, typeObject));\n        }, this);\n        return new CoderTuple(this.coerceFunc, coders, '_').decode(bytes_1.arrayify(data), 0).value;\n    };\n    return AbiCoder;\n}());\nexports.AbiCoder = AbiCoder;\nexports.defaultAbiCoder = new AbiCoder();\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}