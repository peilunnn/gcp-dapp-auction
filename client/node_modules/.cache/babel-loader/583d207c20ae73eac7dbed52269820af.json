{"ast":null,"code":"// TODO: this is a temporary fix to hide those libraries from the browser. A\n// slightly better long-term solution would be to split this file into two,\n// separating the functions that are used on Node.js from the functions that\n// are used only on the browser.\nmodule.exports = function (_ref) {\n  var fs = _ref.fs,\n    files = _ref.files,\n    os = _ref.os,\n    path = _ref.path,\n    child_process = _ref.child_process,\n    mimetype = _ref.mimetype,\n    defaultArchives = _ref.defaultArchives,\n    request = _ref.request,\n    downloadUrl = _ref.downloadUrl,\n    bytes = _ref.bytes,\n    hash = _ref.hash,\n    pick = _ref.pick;\n\n  // ∀ a . String -> JSON -> Map String a -o Map String a\n  //   Inserts a key/val pair in an object impurely.\n  var impureInsert = function impureInsert(key) {\n    return function (val) {\n      return function (map) {\n        return map[key] = val, map;\n      };\n    };\n  }; // String -> JSON -> Map String JSON\n  //   Merges an array of keys and an array of vals into an object.\n\n  var toMap = function toMap(keys) {\n    return function (vals) {\n      var map = {};\n      for (var i = 0, l = keys.length; i < l; ++i) {\n        map[keys[i]] = vals[i];\n      }\n      return map;\n    };\n  }; // ∀ a . Map String a -> Map String a -> Map String a\n  //   Merges two maps into one.\n\n  var merge = function merge(a) {\n    return function (b) {\n      var map = {};\n      for (var key in a) {\n        map[key] = a[key];\n      }\n      for (var _key in b) {\n        map[_key] = b[_key];\n      }\n      return map;\n    };\n  }; // ∀ a . [a] -> [a] -> Bool\n\n  var equals = function equals(a) {\n    return function (b) {\n      if (a.length !== b.length) {\n        return false;\n      } else {\n        for (var i = 0, l = a.length; i < l; ++i) {\n          if (a[i] !== b[i]) return false;\n        }\n      }\n      return true;\n    };\n  }; // String -> String -> String\n\n  var rawUrl = function rawUrl(swarmUrl) {\n    return function (hash) {\n      return \"\".concat(swarmUrl, \"/bzzr:/\").concat(hash);\n    };\n  }; // String -> String -> Promise Uint8Array\n  //   Gets the raw contents of a Swarm hash address.\n\n  var downloadData = function downloadData(swarmUrl) {\n    return function (hash) {\n      return request(rawUrl(swarmUrl)(hash), {\n        responseType: \"arraybuffer\"\n      }).then(function (arrayBuffer) {\n        var uint8Array = new Uint8Array(arrayBuffer);\n        var error404 = [52, 48, 52, 32, 112, 97, 103, 101, 32, 110, 111, 116, 32, 102, 111, 117, 110, 100, 10];\n        if (equals(uint8Array)(error404)) throw \"Error 404.\";\n        return uint8Array;\n      });\n    };\n  }; // type Entry = {\"type\": String, \"hash\": String}\n  // type File = {\"type\": String, \"data\": Uint8Array}\n  // String -> String -> Promise (Map String Entry)\n  //   Solves the manifest of a Swarm address recursively.\n  //   Returns a map from full paths to entries.\n\n  var downloadEntries = function downloadEntries(swarmUrl) {\n    return function (hash) {\n      var search = function search(hash) {\n        return function (path) {\n          return function (routes) {\n            // Formats an entry to the Swarm.js type.\n            var format = function format(entry) {\n              return {\n                type: entry.contentType,\n                hash: entry.hash\n              };\n            }; // To download a single entry:\n            //   if type is bzz-manifest, go deeper\n            //   if not, add it to the routing table\n\n            var downloadEntry = function downloadEntry(entry) {\n              if (entry.path === undefined) {\n                return Promise.resolve();\n              } else {\n                return entry.contentType === \"application/bzz-manifest+json\" ? search(entry.hash)(path + entry.path)(routes) : Promise.resolve(impureInsert(path + entry.path)(format(entry))(routes));\n              }\n            }; // Downloads the initial manifest and then each entry.\n\n            return downloadData(swarmUrl)(hash).then(function (text) {\n              return JSON.parse(toString(text)).entries;\n            }).then(function (entries) {\n              return Promise.all(entries.map(downloadEntry));\n            }).then(function () {\n              return routes;\n            });\n          };\n        };\n      };\n      return search(hash)(\"\")({});\n    };\n  }; // String -> String -> Promise (Map String String)\n  //   Same as `downloadEntries`, but returns only hashes (no types).\n\n  var downloadRoutes = function downloadRoutes(swarmUrl) {\n    return function (hash) {\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\n        return toMap(Object.keys(entries))(Object.keys(entries).map(function (route) {\n          return entries[route].hash;\n        }));\n      });\n    };\n  }; // String -> String -> Promise (Map String File)\n  //   Gets the entire directory tree in a Swarm address.\n  //   Returns a promise mapping paths to file contents.\n\n  var downloadDirectory = function downloadDirectory(swarmUrl) {\n    return function (hash) {\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\n        var paths = Object.keys(entries);\n        var hashs = paths.map(function (path) {\n          return entries[path].hash;\n        });\n        var types = paths.map(function (path) {\n          return entries[path].type;\n        });\n        var datas = hashs.map(downloadData(swarmUrl));\n        var files = function files(datas) {\n          return datas.map(function (data, i) {\n            return {\n              type: types[i],\n              data: data\n            };\n          });\n        };\n        return Promise.all(datas).then(function (datas) {\n          return toMap(paths)(files(datas));\n        });\n      });\n    };\n  }; // String -> String -> String -> Promise String\n  //   Gets the raw contents of a Swarm hash address.\n  //   Returns a promise with the downloaded file path.\n\n  var downloadDataToDisk = function downloadDataToDisk(swarmUrl) {\n    return function (hash) {\n      return function (filePath) {\n        return files.download(rawUrl(swarmUrl)(hash))(filePath);\n      };\n    };\n  }; // String -> String -> String -> Promise (Map String String)\n  //   Gets the entire directory tree in a Swarm address.\n  //   Returns a promise mapping paths to file contents.\n\n  var downloadDirectoryToDisk = function downloadDirectoryToDisk(swarmUrl) {\n    return function (hash) {\n      return function (dirPath) {\n        return downloadRoutes(swarmUrl)(hash).then(function (routingTable) {\n          var downloads = [];\n          for (var route in routingTable) {\n            if (route.length > 0) {\n              var filePath = path.join(dirPath, route);\n              downloads.push(downloadDataToDisk(swarmUrl)(routingTable[route])(filePath));\n            }\n            ;\n          }\n          ;\n          return Promise.all(downloads).then(function () {\n            return dirPath;\n          });\n        });\n      };\n    };\n  }; // String -> Uint8Array -> Promise String\n  //   Uploads raw data to Swarm.\n  //   Returns a promise with the uploaded hash.\n\n  var uploadData = function uploadData(swarmUrl) {\n    return function (data) {\n      return request(\"\".concat(swarmUrl, \"/bzzr:/\"), {\n        body: typeof data === \"string\" ? fromString(data) : data,\n        method: \"POST\"\n      });\n    };\n  }; // String -> String -> String -> File -> Promise String\n  //   Uploads a file to the Swarm manifest at a given hash, under a specific\n  //   route. Returns a promise containing the uploaded hash.\n  //   FIXME: for some reasons Swarm-Gateways is sometimes returning\n  //   error 404 (bad request), so we retry up to 3 times. Why?\n\n  var uploadToManifest = function uploadToManifest(swarmUrl) {\n    return function (hash) {\n      return function (route) {\n        return function (file) {\n          var attempt = function attempt(n) {\n            var slashRoute = route[0] === \"/\" ? route : \"/\" + route;\n            var url = \"\".concat(swarmUrl, \"/bzz:/\").concat(hash).concat(slashRoute);\n            var opt = {\n              method: \"PUT\",\n              headers: {\n                \"Content-Type\": file.type\n              },\n              body: file.data\n            };\n            return request(url, opt).then(function (response) {\n              if (response.indexOf(\"error\") !== -1) {\n                throw response;\n              }\n              return response;\n            }).catch(function (e) {\n              return n > 0 && attempt(n - 1);\n            });\n          };\n          return attempt(3);\n        };\n      };\n    };\n  }; // String -> {type: String, data: Uint8Array} -> Promise String\n\n  var uploadFile = function uploadFile(swarmUrl) {\n    return function (file) {\n      return uploadDirectory(swarmUrl)({\n        \"\": file\n      });\n    };\n  }; // String -> String -> Promise String\n\n  var uploadFileFromDisk = function uploadFileFromDisk(swarmUrl) {\n    return function (filePath) {\n      return fs.readFile(filePath).then(function (data) {\n        return uploadFile(swarmUrl)({\n          type: mimetype.lookup(filePath),\n          data: data\n        });\n      });\n    };\n  }; // String -> Map String File -> Promise String\n  //   Uploads a directory to Swarm. The directory is\n  //   represented as a map of routes and files.\n  //   A default path is encoded by having a \"\" route.\n\n  var uploadDirectory = function uploadDirectory(swarmUrl) {\n    return function (directory) {\n      return uploadData(swarmUrl)(\"{}\").then(function (hash) {\n        var uploadRoute = function uploadRoute(route) {\n          return function (hash) {\n            return uploadToManifest(swarmUrl)(hash)(route)(directory[route]);\n          };\n        };\n        var uploadToHash = function uploadToHash(hash, route) {\n          return hash.then(uploadRoute(route));\n        };\n        return Object.keys(directory).reduce(uploadToHash, Promise.resolve(hash));\n      });\n    };\n  }; // String -> Promise String\n\n  var uploadDataFromDisk = function uploadDataFromDisk(swarmUrl) {\n    return function (filePath) {\n      return fs.readFile(filePath).then(uploadData(swarmUrl));\n    };\n  }; // String -> Nullable String -> String -> Promise String\n\n  var uploadDirectoryFromDisk = function uploadDirectoryFromDisk(swarmUrl) {\n    return function (defaultPath) {\n      return function (dirPath) {\n        return files.directoryTree(dirPath).then(function (fullPaths) {\n          return Promise.all(fullPaths.map(function (path) {\n            return fs.readFile(path);\n          })).then(function (datas) {\n            var paths = fullPaths.map(function (path) {\n              return path.slice(dirPath.length);\n            });\n            var types = fullPaths.map(function (path) {\n              return mimetype.lookup(path) || \"text/plain\";\n            });\n            return toMap(paths)(datas.map(function (data, i) {\n              return {\n                type: types[i],\n                data: data\n              };\n            }));\n          });\n        }).then(function (directory) {\n          return merge(defaultPath ? {\n            \"\": directory[defaultPath]\n          } : {})(directory);\n        }).then(uploadDirectory(swarmUrl));\n      };\n    };\n  }; // String -> UploadInfo -> Promise String\n  //   Simplified multi-type upload which calls the correct\n  //   one based on the type of the argument given.\n\n  var _upload = function upload(swarmUrl) {\n    return function (arg) {\n      // Upload raw data from browser\n      if (arg.pick === \"data\") {\n        return pick.data().then(uploadData(swarmUrl)); // Upload a file from browser\n      } else if (arg.pick === \"file\") {\n        return pick.file().then(uploadFile(swarmUrl)); // Upload a directory from browser\n      } else if (arg.pick === \"directory\") {\n        return pick.directory().then(uploadDirectory(swarmUrl)); // Upload directory/file from disk\n      } else if (arg.path) {\n        switch (arg.kind) {\n          case \"data\":\n            return uploadDataFromDisk(swarmUrl)(arg.path);\n          case \"file\":\n            return uploadFileFromDisk(swarmUrl)(arg.path);\n          case \"directory\":\n            return uploadDirectoryFromDisk(swarmUrl)(arg.defaultFile)(arg.path);\n        }\n        ; // Upload UTF-8 string or raw data (buffer)\n      } else if (arg.length || typeof arg === \"string\") {\n        return uploadData(swarmUrl)(arg); // Upload directory with JSON\n      } else if (arg instanceof Object) {\n        return uploadDirectory(swarmUrl)(arg);\n      }\n      return Promise.reject(new Error(\"Bad arguments\"));\n    };\n  }; // String -> String -> Nullable String -> Promise (String | Uint8Array | Map String Uint8Array)\n  //   Simplified multi-type download which calls the correct function based on\n  //   the type of the argument given, and on whether the Swwarm address has a\n  //   directory or a file.\n\n  var _download = function download(swarmUrl) {\n    return function (hash) {\n      return function (path) {\n        return isDirectory(swarmUrl)(hash).then(function (isDir) {\n          if (isDir) {\n            return path ? downloadDirectoryToDisk(swarmUrl)(hash)(path) : downloadDirectory(swarmUrl)(hash);\n          } else {\n            return path ? downloadDataToDisk(swarmUrl)(hash)(path) : downloadData(swarmUrl)(hash);\n          }\n        });\n      };\n    };\n  }; // String -> Promise String\n  //   Downloads the Swarm binaries into a path. Returns a promise that only\n  //   resolves when the exact Swarm file is there, and verified to be correct.\n  //   If it was already there to begin with, skips the download.\n\n  var downloadBinary = function downloadBinary(path, archives) {\n    var system = os.platform().replace(\"win32\", \"windows\") + \"-\" + (os.arch() === \"x64\" ? \"amd64\" : \"386\");\n    var archive = (archives || defaultArchives)[system];\n    var archiveUrl = downloadUrl + archive.archive + \".tar.gz\";\n    var archiveMD5 = archive.archiveMD5;\n    var binaryMD5 = archive.binaryMD5;\n    return files.safeDownloadArchived(archiveUrl)(archiveMD5)(binaryMD5)(path);\n  }; // type SwarmSetup = {\n  //   account : String,\n  //   password : String,\n  //   dataDir : String,\n  //   binPath : String,\n  //   ensApi : String,\n  //   onDownloadProgress : Number ~> (),\n  //   archives : [{\n  //     archive: String,\n  //     binaryMD5: String,\n  //     archiveMD5: String\n  //   }]\n  // }\n  // SwarmSetup ~> Promise Process\n  //   Starts the Swarm process.\n\n  var startProcess = function startProcess(swarmSetup) {\n    return new Promise(function (resolve, reject) {\n      var spawn = child_process.spawn;\n      var hasString = function hasString(str) {\n        return function (buffer) {\n          return ('' + buffer).indexOf(str) !== -1;\n        };\n      };\n      var account = swarmSetup.account,\n        password = swarmSetup.password,\n        dataDir = swarmSetup.dataDir,\n        ensApi = swarmSetup.ensApi,\n        privateKey = swarmSetup.privateKey;\n      var STARTUP_TIMEOUT_SECS = 3;\n      var WAITING_PASSWORD = 0;\n      var STARTING = 1;\n      var LISTENING = 2;\n      var PASSWORD_PROMPT_HOOK = \"Passphrase\";\n      var LISTENING_HOOK = \"Swarm http proxy started\";\n      var state = WAITING_PASSWORD;\n      var swarmProcess = spawn(swarmSetup.binPath, ['--bzzaccount', account || privateKey, '--datadir', dataDir, '--ens-api', ensApi]);\n      var handleProcessOutput = function handleProcessOutput(data) {\n        if (state === WAITING_PASSWORD && hasString(PASSWORD_PROMPT_HOOK)(data)) {\n          setTimeout(function () {\n            state = STARTING;\n            swarmProcess.stdin.write(password + '\\n');\n          }, 500);\n        } else if (hasString(LISTENING_HOOK)(data)) {\n          state = LISTENING;\n          clearTimeout(timeout);\n          resolve(swarmProcess);\n        }\n      };\n      swarmProcess.stdout.on('data', handleProcessOutput);\n      swarmProcess.stderr.on('data', handleProcessOutput); //swarmProcess.on('close', () => setTimeout(restart, 2000));\n\n      var restart = function restart() {\n        return startProcess(swarmSetup).then(resolve).catch(reject);\n      };\n      var error = function error() {\n        return reject(new Error(\"Couldn't start swarm process.\"));\n      };\n      var timeout = setTimeout(error, 20000);\n    });\n  }; // Process ~> Promise ()\n  //   Stops the Swarm process.\n\n  var stopProcess = function stopProcess(process) {\n    return new Promise(function (resolve, reject) {\n      process.stderr.removeAllListeners('data');\n      process.stdout.removeAllListeners('data');\n      process.stdin.removeAllListeners('error');\n      process.removeAllListeners('error');\n      process.removeAllListeners('exit');\n      process.kill('SIGINT');\n      var killTimeout = setTimeout(function () {\n        return process.kill('SIGKILL');\n      }, 8000);\n      process.once('close', function () {\n        clearTimeout(killTimeout);\n        resolve();\n      });\n    });\n  }; // SwarmSetup -> (SwarmAPI -> Promise ()) -> Promise ()\n  //   Receives a Swarm configuration object and a callback function. It then\n  //   checks if a local Swarm node is running. If no local Swarm is found, it\n  //   downloads the Swarm binaries to the dataDir (if not there), checksums,\n  //   starts the Swarm process and calls the callback function with an API\n  //   object using the local node. That callback must return a promise which\n  //   will resolve when it is done using the API, so that this function can\n  //   close the Swarm process properly. Returns a promise that resolves when the\n  //   user is done with the API and the Swarm process is closed.\n  //   TODO: check if Swarm process is already running (improve `isAvailable`)\n\n  var local = function local(swarmSetup) {\n    return function (useAPI) {\n      return _isAvailable(\"http://localhost:8500\").then(function (isAvailable) {\n        return isAvailable ? useAPI(at(\"http://localhost:8500\")).then(function () {}) : downloadBinary(swarmSetup.binPath, swarmSetup.archives).onData(function (data) {\n          return (swarmSetup.onProgress || function () {})(data.length);\n        }).then(function () {\n          return startProcess(swarmSetup);\n        }).then(function (process) {\n          return useAPI(at(\"http://localhost:8500\")).then(function () {\n            return process;\n          });\n        }).then(stopProcess);\n      });\n    };\n  }; // String ~> Promise Bool\n  //   Returns true if Swarm is available on `url`.\n  //   Perfoms a test upload to determine that.\n  //   TODO: improve this?\n\n  var _isAvailable = function isAvailable(swarmUrl) {\n    var testFile = \"test\";\n    var testHash = \"c9a99c7d326dcc6316f32fe2625b311f6dc49a175e6877681ded93137d3569e7\";\n    return uploadData(swarmUrl)(testFile).then(function (hash) {\n      return hash === testHash;\n    }).catch(function () {\n      return false;\n    });\n  }; // String -> String ~> Promise Bool\n  //   Returns a Promise which is true if that Swarm address is a directory.\n  //   Determines that by checking that it (i) is a JSON, (ii) has a .entries.\n  //   TODO: improve this?\n\n  var isDirectory = function isDirectory(swarmUrl) {\n    return function (hash) {\n      return downloadData(swarmUrl)(hash).then(function (data) {\n        try {\n          return !!JSON.parse(toString(data)).entries;\n        } catch (e) {\n          return false;\n        }\n      });\n    };\n  }; // Uncurries a function; used to allow the f(x,y,z) style on exports.\n\n  var uncurry = function uncurry(f) {\n    return function (a, b, c, d, e) {\n      var p; // Hardcoded because efficiency (`arguments` is very slow).\n\n      if (typeof a !== \"undefined\") p = f(a);\n      if (typeof b !== \"undefined\") p = f(b);\n      if (typeof c !== \"undefined\") p = f(c);\n      if (typeof d !== \"undefined\") p = f(d);\n      if (typeof e !== \"undefined\") p = f(e);\n      return p;\n    };\n  }; // () -> Promise Bool\n  //   Not sure how to mock Swarm to test it properly. Ideas?\n\n  var test = function test() {\n    return Promise.resolve(true);\n  }; // Uint8Array -> String\n\n  var toString = function toString(uint8Array) {\n    return bytes.toString(bytes.fromUint8Array(uint8Array));\n  }; // String -> Uint8Array\n\n  var fromString = function fromString(string) {\n    return bytes.toUint8Array(bytes.fromString(string));\n  }; // String -> SwarmAPI\n  //   Fixes the `swarmUrl`, returning an API where you don't have to pass it.\n\n  var at = function at(swarmUrl) {\n    return {\n      download: function download(hash, path) {\n        return _download(swarmUrl)(hash)(path);\n      },\n      downloadData: uncurry(downloadData(swarmUrl)),\n      downloadDataToDisk: uncurry(downloadDataToDisk(swarmUrl)),\n      downloadDirectory: uncurry(downloadDirectory(swarmUrl)),\n      downloadDirectoryToDisk: uncurry(downloadDirectoryToDisk(swarmUrl)),\n      downloadEntries: uncurry(downloadEntries(swarmUrl)),\n      downloadRoutes: uncurry(downloadRoutes(swarmUrl)),\n      isAvailable: function isAvailable() {\n        return _isAvailable(swarmUrl);\n      },\n      upload: function upload(arg) {\n        return _upload(swarmUrl)(arg);\n      },\n      uploadData: uncurry(uploadData(swarmUrl)),\n      uploadFile: uncurry(uploadFile(swarmUrl)),\n      uploadFileFromDisk: uncurry(uploadFile(swarmUrl)),\n      uploadDataFromDisk: uncurry(uploadDataFromDisk(swarmUrl)),\n      uploadDirectory: uncurry(uploadDirectory(swarmUrl)),\n      uploadDirectoryFromDisk: uncurry(uploadDirectoryFromDisk(swarmUrl)),\n      uploadToManifest: uncurry(uploadToManifest(swarmUrl)),\n      pick: pick,\n      hash: hash,\n      fromString: fromString,\n      toString: toString\n    };\n  };\n  return {\n    at: at,\n    local: local,\n    download: _download,\n    downloadBinary: downloadBinary,\n    downloadData: downloadData,\n    downloadDataToDisk: downloadDataToDisk,\n    downloadDirectory: downloadDirectory,\n    downloadDirectoryToDisk: downloadDirectoryToDisk,\n    downloadEntries: downloadEntries,\n    downloadRoutes: downloadRoutes,\n    isAvailable: _isAvailable,\n    startProcess: startProcess,\n    stopProcess: stopProcess,\n    upload: _upload,\n    uploadData: uploadData,\n    uploadDataFromDisk: uploadDataFromDisk,\n    uploadFile: uploadFile,\n    uploadFileFromDisk: uploadFileFromDisk,\n    uploadDirectory: uploadDirectory,\n    uploadDirectoryFromDisk: uploadDirectoryFromDisk,\n    uploadToManifest: uploadToManifest,\n    pick: pick,\n    hash: hash,\n    fromString: fromString,\n    toString: toString\n  };\n};","map":{"version":3,"names":["module","exports","_ref","fs","files","os","path","child_process","mimetype","defaultArchives","request","downloadUrl","bytes","hash","pick","impureInsert","key","val","map","toMap","keys","vals","i","l","length","merge","a","b","_key","equals","rawUrl","swarmUrl","concat","downloadData","responseType","then","arrayBuffer","uint8Array","Uint8Array","error404","downloadEntries","search","routes","format","entry","type","contentType","downloadEntry","undefined","Promise","resolve","text","JSON","parse","toString","entries","all","downloadRoutes","Object","route","downloadDirectory","paths","hashs","types","datas","data","downloadDataToDisk","filePath","download","downloadDirectoryToDisk","dirPath","routingTable","downloads","join","push","uploadData","body","fromString","method","uploadToManifest","file","attempt","n","slashRoute","url","opt","headers","response","indexOf","catch","e","uploadFile","uploadDirectory","uploadFileFromDisk","readFile","lookup","directory","uploadRoute","uploadToHash","reduce","uploadDataFromDisk","uploadDirectoryFromDisk","defaultPath","directoryTree","fullPaths","slice","_upload","upload","arg","kind","defaultFile","reject","Error","_download","isDirectory","isDir","downloadBinary","archives","system","platform","replace","arch","archive","archiveUrl","archiveMD5","binaryMD5","safeDownloadArchived","startProcess","swarmSetup","spawn","hasString","str","buffer","account","password","dataDir","ensApi","privateKey","STARTUP_TIMEOUT_SECS","WAITING_PASSWORD","STARTING","LISTENING","PASSWORD_PROMPT_HOOK","LISTENING_HOOK","state","swarmProcess","binPath","handleProcessOutput","setTimeout","stdin","write","clearTimeout","timeout","stdout","on","stderr","restart","error","stopProcess","process","removeAllListeners","kill","killTimeout","once","local","useAPI","_isAvailable","isAvailable","at","onData","onProgress","testFile","testHash","uncurry","f","c","d","p","test","fromUint8Array","string","toUint8Array"],"sources":["/home/peilunnn/Downloads/Internship Projects/gcp-dapp-auction/client/node_modules/truffle-interface-adapter/node_modules/swarm-js/lib/swarm.js"],"sourcesContent":["// TODO: this is a temporary fix to hide those libraries from the browser. A\n// slightly better long-term solution would be to split this file into two,\n// separating the functions that are used on Node.js from the functions that\n// are used only on the browser.\nmodule.exports = function (_ref) {\n  var fs = _ref.fs,\n      files = _ref.files,\n      os = _ref.os,\n      path = _ref.path,\n      child_process = _ref.child_process,\n      mimetype = _ref.mimetype,\n      defaultArchives = _ref.defaultArchives,\n      request = _ref.request,\n      downloadUrl = _ref.downloadUrl,\n      bytes = _ref.bytes,\n      hash = _ref.hash,\n      pick = _ref.pick;\n\n  // ∀ a . String -> JSON -> Map String a -o Map String a\n  //   Inserts a key/val pair in an object impurely.\n  var impureInsert = function impureInsert(key) {\n    return function (val) {\n      return function (map) {\n        return map[key] = val, map;\n      };\n    };\n  }; // String -> JSON -> Map String JSON\n  //   Merges an array of keys and an array of vals into an object.\n\n\n  var toMap = function toMap(keys) {\n    return function (vals) {\n      var map = {};\n\n      for (var i = 0, l = keys.length; i < l; ++i) {\n        map[keys[i]] = vals[i];\n      }\n\n      return map;\n    };\n  }; // ∀ a . Map String a -> Map String a -> Map String a\n  //   Merges two maps into one.\n\n\n  var merge = function merge(a) {\n    return function (b) {\n      var map = {};\n\n      for (var key in a) {\n        map[key] = a[key];\n      }\n\n      for (var _key in b) {\n        map[_key] = b[_key];\n      }\n\n      return map;\n    };\n  }; // ∀ a . [a] -> [a] -> Bool\n\n\n  var equals = function equals(a) {\n    return function (b) {\n      if (a.length !== b.length) {\n        return false;\n      } else {\n        for (var i = 0, l = a.length; i < l; ++i) {\n          if (a[i] !== b[i]) return false;\n        }\n      }\n\n      return true;\n    };\n  }; // String -> String -> String\n\n\n  var rawUrl = function rawUrl(swarmUrl) {\n    return function (hash) {\n      return \"\".concat(swarmUrl, \"/bzzr:/\").concat(hash);\n    };\n  }; // String -> String -> Promise Uint8Array\n  //   Gets the raw contents of a Swarm hash address.\n\n\n  var downloadData = function downloadData(swarmUrl) {\n    return function (hash) {\n      return request(rawUrl(swarmUrl)(hash), {\n        responseType: \"arraybuffer\"\n      }).then(function (arrayBuffer) {\n        var uint8Array = new Uint8Array(arrayBuffer);\n        var error404 = [52, 48, 52, 32, 112, 97, 103, 101, 32, 110, 111, 116, 32, 102, 111, 117, 110, 100, 10];\n        if (equals(uint8Array)(error404)) throw \"Error 404.\";\n        return uint8Array;\n      });\n    };\n  }; // type Entry = {\"type\": String, \"hash\": String}\n  // type File = {\"type\": String, \"data\": Uint8Array}\n  // String -> String -> Promise (Map String Entry)\n  //   Solves the manifest of a Swarm address recursively.\n  //   Returns a map from full paths to entries.\n\n\n  var downloadEntries = function downloadEntries(swarmUrl) {\n    return function (hash) {\n      var search = function search(hash) {\n        return function (path) {\n          return function (routes) {\n            // Formats an entry to the Swarm.js type.\n            var format = function format(entry) {\n              return {\n                type: entry.contentType,\n                hash: entry.hash\n              };\n            }; // To download a single entry:\n            //   if type is bzz-manifest, go deeper\n            //   if not, add it to the routing table\n\n\n            var downloadEntry = function downloadEntry(entry) {\n              if (entry.path === undefined) {\n                return Promise.resolve();\n              } else {\n                return entry.contentType === \"application/bzz-manifest+json\" ? search(entry.hash)(path + entry.path)(routes) : Promise.resolve(impureInsert(path + entry.path)(format(entry))(routes));\n              }\n            }; // Downloads the initial manifest and then each entry.\n\n\n            return downloadData(swarmUrl)(hash).then(function (text) {\n              return JSON.parse(toString(text)).entries;\n            }).then(function (entries) {\n              return Promise.all(entries.map(downloadEntry));\n            }).then(function () {\n              return routes;\n            });\n          };\n        };\n      };\n\n      return search(hash)(\"\")({});\n    };\n  }; // String -> String -> Promise (Map String String)\n  //   Same as `downloadEntries`, but returns only hashes (no types).\n\n\n  var downloadRoutes = function downloadRoutes(swarmUrl) {\n    return function (hash) {\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\n        return toMap(Object.keys(entries))(Object.keys(entries).map(function (route) {\n          return entries[route].hash;\n        }));\n      });\n    };\n  }; // String -> String -> Promise (Map String File)\n  //   Gets the entire directory tree in a Swarm address.\n  //   Returns a promise mapping paths to file contents.\n\n\n  var downloadDirectory = function downloadDirectory(swarmUrl) {\n    return function (hash) {\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\n        var paths = Object.keys(entries);\n        var hashs = paths.map(function (path) {\n          return entries[path].hash;\n        });\n        var types = paths.map(function (path) {\n          return entries[path].type;\n        });\n        var datas = hashs.map(downloadData(swarmUrl));\n\n        var files = function files(datas) {\n          return datas.map(function (data, i) {\n            return {\n              type: types[i],\n              data: data\n            };\n          });\n        };\n\n        return Promise.all(datas).then(function (datas) {\n          return toMap(paths)(files(datas));\n        });\n      });\n    };\n  }; // String -> String -> String -> Promise String\n  //   Gets the raw contents of a Swarm hash address.\n  //   Returns a promise with the downloaded file path.\n\n\n  var downloadDataToDisk = function downloadDataToDisk(swarmUrl) {\n    return function (hash) {\n      return function (filePath) {\n        return files.download(rawUrl(swarmUrl)(hash))(filePath);\n      };\n    };\n  }; // String -> String -> String -> Promise (Map String String)\n  //   Gets the entire directory tree in a Swarm address.\n  //   Returns a promise mapping paths to file contents.\n\n\n  var downloadDirectoryToDisk = function downloadDirectoryToDisk(swarmUrl) {\n    return function (hash) {\n      return function (dirPath) {\n        return downloadRoutes(swarmUrl)(hash).then(function (routingTable) {\n          var downloads = [];\n\n          for (var route in routingTable) {\n            if (route.length > 0) {\n              var filePath = path.join(dirPath, route);\n              downloads.push(downloadDataToDisk(swarmUrl)(routingTable[route])(filePath));\n            }\n\n            ;\n          }\n\n          ;\n          return Promise.all(downloads).then(function () {\n            return dirPath;\n          });\n        });\n      };\n    };\n  }; // String -> Uint8Array -> Promise String\n  //   Uploads raw data to Swarm.\n  //   Returns a promise with the uploaded hash.\n\n\n  var uploadData = function uploadData(swarmUrl) {\n    return function (data) {\n      return request(\"\".concat(swarmUrl, \"/bzzr:/\"), {\n        body: typeof data === \"string\" ? fromString(data) : data,\n        method: \"POST\"\n      });\n    };\n  }; // String -> String -> String -> File -> Promise String\n  //   Uploads a file to the Swarm manifest at a given hash, under a specific\n  //   route. Returns a promise containing the uploaded hash.\n  //   FIXME: for some reasons Swarm-Gateways is sometimes returning\n  //   error 404 (bad request), so we retry up to 3 times. Why?\n\n\n  var uploadToManifest = function uploadToManifest(swarmUrl) {\n    return function (hash) {\n      return function (route) {\n        return function (file) {\n          var attempt = function attempt(n) {\n            var slashRoute = route[0] === \"/\" ? route : \"/\" + route;\n            var url = \"\".concat(swarmUrl, \"/bzz:/\").concat(hash).concat(slashRoute);\n            var opt = {\n              method: \"PUT\",\n              headers: {\n                \"Content-Type\": file.type\n              },\n              body: file.data\n            };\n            return request(url, opt).then(function (response) {\n              if (response.indexOf(\"error\") !== -1) {\n                throw response;\n              }\n\n              return response;\n            }).catch(function (e) {\n              return n > 0 && attempt(n - 1);\n            });\n          };\n\n          return attempt(3);\n        };\n      };\n    };\n  }; // String -> {type: String, data: Uint8Array} -> Promise String\n\n\n  var uploadFile = function uploadFile(swarmUrl) {\n    return function (file) {\n      return uploadDirectory(swarmUrl)({\n        \"\": file\n      });\n    };\n  }; // String -> String -> Promise String\n\n\n  var uploadFileFromDisk = function uploadFileFromDisk(swarmUrl) {\n    return function (filePath) {\n      return fs.readFile(filePath).then(function (data) {\n        return uploadFile(swarmUrl)({\n          type: mimetype.lookup(filePath),\n          data: data\n        });\n      });\n    };\n  }; // String -> Map String File -> Promise String\n  //   Uploads a directory to Swarm. The directory is\n  //   represented as a map of routes and files.\n  //   A default path is encoded by having a \"\" route.\n\n\n  var uploadDirectory = function uploadDirectory(swarmUrl) {\n    return function (directory) {\n      return uploadData(swarmUrl)(\"{}\").then(function (hash) {\n        var uploadRoute = function uploadRoute(route) {\n          return function (hash) {\n            return uploadToManifest(swarmUrl)(hash)(route)(directory[route]);\n          };\n        };\n\n        var uploadToHash = function uploadToHash(hash, route) {\n          return hash.then(uploadRoute(route));\n        };\n\n        return Object.keys(directory).reduce(uploadToHash, Promise.resolve(hash));\n      });\n    };\n  }; // String -> Promise String\n\n\n  var uploadDataFromDisk = function uploadDataFromDisk(swarmUrl) {\n    return function (filePath) {\n      return fs.readFile(filePath).then(uploadData(swarmUrl));\n    };\n  }; // String -> Nullable String -> String -> Promise String\n\n\n  var uploadDirectoryFromDisk = function uploadDirectoryFromDisk(swarmUrl) {\n    return function (defaultPath) {\n      return function (dirPath) {\n        return files.directoryTree(dirPath).then(function (fullPaths) {\n          return Promise.all(fullPaths.map(function (path) {\n            return fs.readFile(path);\n          })).then(function (datas) {\n            var paths = fullPaths.map(function (path) {\n              return path.slice(dirPath.length);\n            });\n            var types = fullPaths.map(function (path) {\n              return mimetype.lookup(path) || \"text/plain\";\n            });\n            return toMap(paths)(datas.map(function (data, i) {\n              return {\n                type: types[i],\n                data: data\n              };\n            }));\n          });\n        }).then(function (directory) {\n          return merge(defaultPath ? {\n            \"\": directory[defaultPath]\n          } : {})(directory);\n        }).then(uploadDirectory(swarmUrl));\n      };\n    };\n  }; // String -> UploadInfo -> Promise String\n  //   Simplified multi-type upload which calls the correct\n  //   one based on the type of the argument given.\n\n\n  var _upload = function upload(swarmUrl) {\n    return function (arg) {\n      // Upload raw data from browser\n      if (arg.pick === \"data\") {\n        return pick.data().then(uploadData(swarmUrl)); // Upload a file from browser\n      } else if (arg.pick === \"file\") {\n        return pick.file().then(uploadFile(swarmUrl)); // Upload a directory from browser\n      } else if (arg.pick === \"directory\") {\n        return pick.directory().then(uploadDirectory(swarmUrl)); // Upload directory/file from disk\n      } else if (arg.path) {\n        switch (arg.kind) {\n          case \"data\":\n            return uploadDataFromDisk(swarmUrl)(arg.path);\n\n          case \"file\":\n            return uploadFileFromDisk(swarmUrl)(arg.path);\n\n          case \"directory\":\n            return uploadDirectoryFromDisk(swarmUrl)(arg.defaultFile)(arg.path);\n        }\n\n        ; // Upload UTF-8 string or raw data (buffer)\n      } else if (arg.length || typeof arg === \"string\") {\n        return uploadData(swarmUrl)(arg); // Upload directory with JSON\n      } else if (arg instanceof Object) {\n        return uploadDirectory(swarmUrl)(arg);\n      }\n\n      return Promise.reject(new Error(\"Bad arguments\"));\n    };\n  }; // String -> String -> Nullable String -> Promise (String | Uint8Array | Map String Uint8Array)\n  //   Simplified multi-type download which calls the correct function based on\n  //   the type of the argument given, and on whether the Swwarm address has a\n  //   directory or a file.\n\n\n  var _download = function download(swarmUrl) {\n    return function (hash) {\n      return function (path) {\n        return isDirectory(swarmUrl)(hash).then(function (isDir) {\n          if (isDir) {\n            return path ? downloadDirectoryToDisk(swarmUrl)(hash)(path) : downloadDirectory(swarmUrl)(hash);\n          } else {\n            return path ? downloadDataToDisk(swarmUrl)(hash)(path) : downloadData(swarmUrl)(hash);\n          }\n        });\n      };\n    };\n  }; // String -> Promise String\n  //   Downloads the Swarm binaries into a path. Returns a promise that only\n  //   resolves when the exact Swarm file is there, and verified to be correct.\n  //   If it was already there to begin with, skips the download.\n\n\n  var downloadBinary = function downloadBinary(path, archives) {\n    var system = os.platform().replace(\"win32\", \"windows\") + \"-\" + (os.arch() === \"x64\" ? \"amd64\" : \"386\");\n    var archive = (archives || defaultArchives)[system];\n    var archiveUrl = downloadUrl + archive.archive + \".tar.gz\";\n    var archiveMD5 = archive.archiveMD5;\n    var binaryMD5 = archive.binaryMD5;\n    return files.safeDownloadArchived(archiveUrl)(archiveMD5)(binaryMD5)(path);\n  }; // type SwarmSetup = {\n  //   account : String,\n  //   password : String,\n  //   dataDir : String,\n  //   binPath : String,\n  //   ensApi : String,\n  //   onDownloadProgress : Number ~> (),\n  //   archives : [{\n  //     archive: String,\n  //     binaryMD5: String,\n  //     archiveMD5: String\n  //   }]\n  // }\n  // SwarmSetup ~> Promise Process\n  //   Starts the Swarm process.\n\n\n  var startProcess = function startProcess(swarmSetup) {\n    return new Promise(function (resolve, reject) {\n      var spawn = child_process.spawn;\n\n      var hasString = function hasString(str) {\n        return function (buffer) {\n          return ('' + buffer).indexOf(str) !== -1;\n        };\n      };\n\n      var account = swarmSetup.account,\n          password = swarmSetup.password,\n          dataDir = swarmSetup.dataDir,\n          ensApi = swarmSetup.ensApi,\n          privateKey = swarmSetup.privateKey;\n      var STARTUP_TIMEOUT_SECS = 3;\n      var WAITING_PASSWORD = 0;\n      var STARTING = 1;\n      var LISTENING = 2;\n      var PASSWORD_PROMPT_HOOK = \"Passphrase\";\n      var LISTENING_HOOK = \"Swarm http proxy started\";\n      var state = WAITING_PASSWORD;\n      var swarmProcess = spawn(swarmSetup.binPath, ['--bzzaccount', account || privateKey, '--datadir', dataDir, '--ens-api', ensApi]);\n\n      var handleProcessOutput = function handleProcessOutput(data) {\n        if (state === WAITING_PASSWORD && hasString(PASSWORD_PROMPT_HOOK)(data)) {\n          setTimeout(function () {\n            state = STARTING;\n            swarmProcess.stdin.write(password + '\\n');\n          }, 500);\n        } else if (hasString(LISTENING_HOOK)(data)) {\n          state = LISTENING;\n          clearTimeout(timeout);\n          resolve(swarmProcess);\n        }\n      };\n\n      swarmProcess.stdout.on('data', handleProcessOutput);\n      swarmProcess.stderr.on('data', handleProcessOutput); //swarmProcess.on('close', () => setTimeout(restart, 2000));\n\n      var restart = function restart() {\n        return startProcess(swarmSetup).then(resolve).catch(reject);\n      };\n\n      var error = function error() {\n        return reject(new Error(\"Couldn't start swarm process.\"));\n      };\n\n      var timeout = setTimeout(error, 20000);\n    });\n  }; // Process ~> Promise ()\n  //   Stops the Swarm process.\n\n\n  var stopProcess = function stopProcess(process) {\n    return new Promise(function (resolve, reject) {\n      process.stderr.removeAllListeners('data');\n      process.stdout.removeAllListeners('data');\n      process.stdin.removeAllListeners('error');\n      process.removeAllListeners('error');\n      process.removeAllListeners('exit');\n      process.kill('SIGINT');\n      var killTimeout = setTimeout(function () {\n        return process.kill('SIGKILL');\n      }, 8000);\n      process.once('close', function () {\n        clearTimeout(killTimeout);\n        resolve();\n      });\n    });\n  }; // SwarmSetup -> (SwarmAPI -> Promise ()) -> Promise ()\n  //   Receives a Swarm configuration object and a callback function. It then\n  //   checks if a local Swarm node is running. If no local Swarm is found, it\n  //   downloads the Swarm binaries to the dataDir (if not there), checksums,\n  //   starts the Swarm process and calls the callback function with an API\n  //   object using the local node. That callback must return a promise which\n  //   will resolve when it is done using the API, so that this function can\n  //   close the Swarm process properly. Returns a promise that resolves when the\n  //   user is done with the API and the Swarm process is closed.\n  //   TODO: check if Swarm process is already running (improve `isAvailable`)\n\n\n  var local = function local(swarmSetup) {\n    return function (useAPI) {\n      return _isAvailable(\"http://localhost:8500\").then(function (isAvailable) {\n        return isAvailable ? useAPI(at(\"http://localhost:8500\")).then(function () {}) : downloadBinary(swarmSetup.binPath, swarmSetup.archives).onData(function (data) {\n          return (swarmSetup.onProgress || function () {})(data.length);\n        }).then(function () {\n          return startProcess(swarmSetup);\n        }).then(function (process) {\n          return useAPI(at(\"http://localhost:8500\")).then(function () {\n            return process;\n          });\n        }).then(stopProcess);\n      });\n    };\n  }; // String ~> Promise Bool\n  //   Returns true if Swarm is available on `url`.\n  //   Perfoms a test upload to determine that.\n  //   TODO: improve this?\n\n\n  var _isAvailable = function isAvailable(swarmUrl) {\n    var testFile = \"test\";\n    var testHash = \"c9a99c7d326dcc6316f32fe2625b311f6dc49a175e6877681ded93137d3569e7\";\n    return uploadData(swarmUrl)(testFile).then(function (hash) {\n      return hash === testHash;\n    }).catch(function () {\n      return false;\n    });\n  }; // String -> String ~> Promise Bool\n  //   Returns a Promise which is true if that Swarm address is a directory.\n  //   Determines that by checking that it (i) is a JSON, (ii) has a .entries.\n  //   TODO: improve this?\n\n\n  var isDirectory = function isDirectory(swarmUrl) {\n    return function (hash) {\n      return downloadData(swarmUrl)(hash).then(function (data) {\n        try {\n          return !!JSON.parse(toString(data)).entries;\n        } catch (e) {\n          return false;\n        }\n      });\n    };\n  }; // Uncurries a function; used to allow the f(x,y,z) style on exports.\n\n\n  var uncurry = function uncurry(f) {\n    return function (a, b, c, d, e) {\n      var p; // Hardcoded because efficiency (`arguments` is very slow).\n\n      if (typeof a !== \"undefined\") p = f(a);\n      if (typeof b !== \"undefined\") p = f(b);\n      if (typeof c !== \"undefined\") p = f(c);\n      if (typeof d !== \"undefined\") p = f(d);\n      if (typeof e !== \"undefined\") p = f(e);\n      return p;\n    };\n  }; // () -> Promise Bool\n  //   Not sure how to mock Swarm to test it properly. Ideas?\n\n\n  var test = function test() {\n    return Promise.resolve(true);\n  }; // Uint8Array -> String\n\n\n  var toString = function toString(uint8Array) {\n    return bytes.toString(bytes.fromUint8Array(uint8Array));\n  }; // String -> Uint8Array\n\n\n  var fromString = function fromString(string) {\n    return bytes.toUint8Array(bytes.fromString(string));\n  }; // String -> SwarmAPI\n  //   Fixes the `swarmUrl`, returning an API where you don't have to pass it.\n\n\n  var at = function at(swarmUrl) {\n    return {\n      download: function download(hash, path) {\n        return _download(swarmUrl)(hash)(path);\n      },\n      downloadData: uncurry(downloadData(swarmUrl)),\n      downloadDataToDisk: uncurry(downloadDataToDisk(swarmUrl)),\n      downloadDirectory: uncurry(downloadDirectory(swarmUrl)),\n      downloadDirectoryToDisk: uncurry(downloadDirectoryToDisk(swarmUrl)),\n      downloadEntries: uncurry(downloadEntries(swarmUrl)),\n      downloadRoutes: uncurry(downloadRoutes(swarmUrl)),\n      isAvailable: function isAvailable() {\n        return _isAvailable(swarmUrl);\n      },\n      upload: function upload(arg) {\n        return _upload(swarmUrl)(arg);\n      },\n      uploadData: uncurry(uploadData(swarmUrl)),\n      uploadFile: uncurry(uploadFile(swarmUrl)),\n      uploadFileFromDisk: uncurry(uploadFile(swarmUrl)),\n      uploadDataFromDisk: uncurry(uploadDataFromDisk(swarmUrl)),\n      uploadDirectory: uncurry(uploadDirectory(swarmUrl)),\n      uploadDirectoryFromDisk: uncurry(uploadDirectoryFromDisk(swarmUrl)),\n      uploadToManifest: uncurry(uploadToManifest(swarmUrl)),\n      pick: pick,\n      hash: hash,\n      fromString: fromString,\n      toString: toString\n    };\n  };\n\n  return {\n    at: at,\n    local: local,\n    download: _download,\n    downloadBinary: downloadBinary,\n    downloadData: downloadData,\n    downloadDataToDisk: downloadDataToDisk,\n    downloadDirectory: downloadDirectory,\n    downloadDirectoryToDisk: downloadDirectoryToDisk,\n    downloadEntries: downloadEntries,\n    downloadRoutes: downloadRoutes,\n    isAvailable: _isAvailable,\n    startProcess: startProcess,\n    stopProcess: stopProcess,\n    upload: _upload,\n    uploadData: uploadData,\n    uploadDataFromDisk: uploadDataFromDisk,\n    uploadFile: uploadFile,\n    uploadFileFromDisk: uploadFileFromDisk,\n    uploadDirectory: uploadDirectory,\n    uploadDirectoryFromDisk: uploadDirectoryFromDisk,\n    uploadToManifest: uploadToManifest,\n    pick: pick,\n    hash: hash,\n    fromString: fromString,\n    toString: toString\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}