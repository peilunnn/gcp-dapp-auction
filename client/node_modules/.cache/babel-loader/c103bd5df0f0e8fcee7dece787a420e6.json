{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst abi_coder_1 = require(\"ethers/utils/abi-coder\");\nconst lodash_1 = __importDefault(require(\"lodash\"));\nexports.QuorumDefinition = {\n  initNetworkType(web3) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // duck punch some of web3's output formatters\n      overrides.getBlock(web3);\n      overrides.getTransaction(web3);\n      overrides.getTransactionReceipt(web3);\n      overrides.decodeParameters(web3);\n    });\n  }\n};\nconst overrides = {\n  // The ts-ignores are ignoring the checks that are\n  // saying that web3.eth.getBlock is a function and doesn't\n  // have a `method` property, which it does\n  \"getBlock\": web3 => {\n    // @ts-ignore\n    const _oldBlockFormatter = web3.eth.getBlock.method.outputFormatter;\n    // @ts-ignore\n    web3.eth.getBlock.method.outputFormatter = block => {\n      const _oldTimestamp = block.timestamp;\n      const _oldGasLimit = block.gasLimit;\n      const _oldGasUsed = block.gasUsed;\n      // Quorum uses nanoseconds instead of seconds in timestamp\n      let timestamp = new bn_js_1.default(block.timestamp.slice(2), 16);\n      timestamp = timestamp.div(new bn_js_1.default(10).pow(new bn_js_1.default(9)));\n      block.timestamp = \"0x\" + timestamp.toString(16);\n      // Since we're overwriting the gasLimit/Used later,\n      // it doesn't matter what it is before the call\n      // The same applies to the timestamp, but I reduced\n      // the precision since there was an accurate representation\n      // We do this because Quorum can have large block/transaction\n      // gas limits\n      block.gasLimit = \"0x0\";\n      block.gasUsed = \"0x0\";\n      // @ts-ignore\n      let result = _oldBlockFormatter.call(web3.eth.getBlock.method, block);\n      // Perhaps there is a better method of doing this,\n      // but the raw hexstrings work for the time being\n      result.timestamp = _oldTimestamp;\n      result.gasLimit = _oldGasLimit;\n      result.gasUsed = _oldGasUsed;\n      return result;\n    };\n  },\n  \"getTransaction\": web3 => {\n    const _oldTransactionFormatter =\n    // @ts-ignore\n    web3.eth.getTransaction.method.outputFormatter;\n    // @ts-ignore\n    web3.eth.getTransaction.method.outputFormatter = tx => {\n      const _oldGas = tx.gas;\n      tx.gas = \"0x0\";\n      let result = _oldTransactionFormatter.call(\n      // @ts-ignore\n      web3.eth.getTransaction.method, tx);\n      // Perhaps there is a better method of doing this,\n      // but the raw hexstrings work for the time being\n      result.gas = _oldGas;\n      return result;\n    };\n  },\n  \"getTransactionReceipt\": web3 => {\n    const _oldTransactionReceiptFormatter =\n    // @ts-ignore\n    web3.eth.getTransactionReceipt.method.outputFormatter;\n    // @ts-ignore\n    web3.eth.getTransactionReceipt.method.outputFormatter = receipt => {\n      const _oldGasUsed = receipt.gasUsed;\n      receipt.gasUsed = \"0x0\";\n      let result = _oldTransactionReceiptFormatter.call(\n      // @ts-ignore\n      web3.eth.getTransactionReceipt.method, receipt);\n      // Perhaps there is a better method of doing this,\n      // but the raw hexstrings work for the time being\n      result.gasUsed = _oldGasUsed;\n      return result;\n    };\n  },\n  // The primary difference between this decodeParameters function and web3's\n  // is that the 'Out of Gas?' zero/null bytes guard has been removed and any\n  // falsy bytes are interpreted as a zero value.\n  \"decodeParameters\": web3 => {\n    const _oldDecodeParameters = web3.eth.abi.decodeParameters;\n    const ethersAbiCoder = new abi_coder_1.AbiCoder((type, value) => {\n      if (type.match(/^u?int/) && !lodash_1.default.isArray(value) && (!lodash_1.default.isObject(value) || value.constructor.name !== \"BN\")) {\n        return value.toString();\n      }\n      return value;\n    });\n    // result method\n    function Result() {}\n    web3.eth.abi.decodeParameters = (outputs, bytes) => {\n      // if bytes is falsy, we'll pass 64 '0' bits to the ethers.js decoder.\n      // the decoder will decode the 64 '0' bits as a 0 value.\n      if (!bytes) bytes = \"0\".repeat(64);\n      const res = ethersAbiCoder.decode(\n      //@ts-ignore 'mapTypes' not existing on type 'ABI'\n      web3.eth.abi.mapTypes(outputs), `0x${bytes.replace(/0x/i, \"\")}`);\n      //@ts-ignore complaint regarding Result method\n      const returnValue = new Result();\n      returnValue.__length__ = 0;\n      outputs.forEach((output, i) => {\n        let decodedValue = res[returnValue.__length__];\n        decodedValue = decodedValue === \"0x\" ? null : decodedValue;\n        returnValue[i] = decodedValue;\n        // @ts-ignore object not having name key\n        if (lodash_1.default.isObject(output) && output.name) {\n          // @ts-ignore object not having name key\n          returnValue[output.name] = decodedValue;\n        }\n        returnValue.__length__++;\n      });\n      return returnValue;\n    };\n  }\n};","map":{"version":3,"sources":["../lib/quorum-overloads.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst abi_coder_1 = require(\"ethers/utils/abi-coder\");\nconst lodash_1 = __importDefault(require(\"lodash\"));\nexports.QuorumDefinition = {\n    initNetworkType(web3) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // duck punch some of web3's output formatters\n            overrides.getBlock(web3);\n            overrides.getTransaction(web3);\n            overrides.getTransactionReceipt(web3);\n            overrides.decodeParameters(web3);\n        });\n    }\n};\nconst overrides = {\n    // The ts-ignores are ignoring the checks that are\n    // saying that web3.eth.getBlock is a function and doesn't\n    // have a `method` property, which it does\n    \"getBlock\": (web3) => {\n        // @ts-ignore\n        const _oldBlockFormatter = web3.eth.getBlock.method.outputFormatter;\n        // @ts-ignore\n        web3.eth.getBlock.method.outputFormatter = (block) => {\n            const _oldTimestamp = block.timestamp;\n            const _oldGasLimit = block.gasLimit;\n            const _oldGasUsed = block.gasUsed;\n            // Quorum uses nanoseconds instead of seconds in timestamp\n            let timestamp = new bn_js_1.default(block.timestamp.slice(2), 16);\n            timestamp = timestamp.div(new bn_js_1.default(10).pow(new bn_js_1.default(9)));\n            block.timestamp = \"0x\" + timestamp.toString(16);\n            // Since we're overwriting the gasLimit/Used later,\n            // it doesn't matter what it is before the call\n            // The same applies to the timestamp, but I reduced\n            // the precision since there was an accurate representation\n            // We do this because Quorum can have large block/transaction\n            // gas limits\n            block.gasLimit = \"0x0\";\n            block.gasUsed = \"0x0\";\n            // @ts-ignore\n            let result = _oldBlockFormatter.call(web3.eth.getBlock.method, block);\n            // Perhaps there is a better method of doing this,\n            // but the raw hexstrings work for the time being\n            result.timestamp = _oldTimestamp;\n            result.gasLimit = _oldGasLimit;\n            result.gasUsed = _oldGasUsed;\n            return result;\n        };\n    },\n    \"getTransaction\": (web3) => {\n        const _oldTransactionFormatter = \n        // @ts-ignore\n        web3.eth.getTransaction.method.outputFormatter;\n        // @ts-ignore\n        web3.eth.getTransaction.method.outputFormatter = (tx) => {\n            const _oldGas = tx.gas;\n            tx.gas = \"0x0\";\n            let result = _oldTransactionFormatter.call(\n            // @ts-ignore\n            web3.eth.getTransaction.method, tx);\n            // Perhaps there is a better method of doing this,\n            // but the raw hexstrings work for the time being\n            result.gas = _oldGas;\n            return result;\n        };\n    },\n    \"getTransactionReceipt\": (web3) => {\n        const _oldTransactionReceiptFormatter = \n        // @ts-ignore\n        web3.eth.getTransactionReceipt.method.outputFormatter;\n        // @ts-ignore\n        web3.eth.getTransactionReceipt.method.outputFormatter = (receipt) => {\n            const _oldGasUsed = receipt.gasUsed;\n            receipt.gasUsed = \"0x0\";\n            let result = _oldTransactionReceiptFormatter.call(\n            // @ts-ignore\n            web3.eth.getTransactionReceipt.method, receipt);\n            // Perhaps there is a better method of doing this,\n            // but the raw hexstrings work for the time being\n            result.gasUsed = _oldGasUsed;\n            return result;\n        };\n    },\n    // The primary difference between this decodeParameters function and web3's\n    // is that the 'Out of Gas?' zero/null bytes guard has been removed and any\n    // falsy bytes are interpreted as a zero value.\n    \"decodeParameters\": (web3) => {\n        const _oldDecodeParameters = web3.eth.abi.decodeParameters;\n        const ethersAbiCoder = new abi_coder_1.AbiCoder((type, value) => {\n            if (type.match(/^u?int/) &&\n                !lodash_1.default.isArray(value) &&\n                (!lodash_1.default.isObject(value) || value.constructor.name !== \"BN\")) {\n                return value.toString();\n            }\n            return value;\n        });\n        // result method\n        function Result() { }\n        web3.eth.abi.decodeParameters = (outputs, bytes) => {\n            // if bytes is falsy, we'll pass 64 '0' bits to the ethers.js decoder.\n            // the decoder will decode the 64 '0' bits as a 0 value.\n            if (!bytes)\n                bytes = \"0\".repeat(64);\n            const res = ethersAbiCoder.decode(\n            //@ts-ignore 'mapTypes' not existing on type 'ABI'\n            web3.eth.abi.mapTypes(outputs), `0x${bytes.replace(/0x/i, \"\")}`);\n            //@ts-ignore complaint regarding Result method\n            const returnValue = new Result();\n            returnValue.__length__ = 0;\n            outputs.forEach((output, i) => {\n                let decodedValue = res[returnValue.__length__];\n                decodedValue = decodedValue === \"0x\" ? null : decodedValue;\n                returnValue[i] = decodedValue;\n                // @ts-ignore object not having name key\n                if (lodash_1.default.isObject(output) && output.name) {\n                    // @ts-ignore object not having name key\n                    returnValue[output.name] = decodedValue;\n                }\n                returnValue.__length__++;\n            });\n            return returnValue;\n        };\n    }\n};\n//# sourceMappingURL=quorum-overloads.js.map"]},"metadata":{},"sourceType":"script"}