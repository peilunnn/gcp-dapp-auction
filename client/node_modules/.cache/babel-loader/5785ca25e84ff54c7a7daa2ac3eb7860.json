{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar bytes_1 = require(\"./bytes\");\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n  UnicodeNormalizationForm[\"current\"] = \"\";\n  UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n  UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n  UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n  UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\n;\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form) {\n  if (form === void 0) {\n    form = UnicodeNormalizationForm.current;\n  }\n  if (form != UnicodeNormalizationForm.current) {\n    errors_1.checkNormalize();\n    str = str.normalize(form);\n  }\n  var result = [];\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    if (c < 0x80) {\n      result.push(c);\n    } else if (c < 0x800) {\n      result.push(c >> 6 | 0xc0);\n      result.push(c & 0x3f | 0x80);\n    } else if ((c & 0xfc00) == 0xd800) {\n      i++;\n      var c2 = str.charCodeAt(i);\n      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n        throw new Error('invalid utf-8 string');\n      }\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n      result.push(c >> 18 | 0xf0);\n      result.push(c >> 12 & 0x3f | 0x80);\n      result.push(c >> 6 & 0x3f | 0x80);\n      result.push(c & 0x3f | 0x80);\n    } else {\n      result.push(c >> 12 | 0xe0);\n      result.push(c >> 6 & 0x3f | 0x80);\n      result.push(c & 0x3f | 0x80);\n    }\n  }\n  return bytes_1.arrayify(result);\n}\nexports.toUtf8Bytes = toUtf8Bytes;\n;\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction toUtf8String(bytes, ignoreErrors) {\n  bytes = bytes_1.arrayify(bytes);\n  var result = '';\n  var i = 0;\n  // Invalid bytes are ignored\n  while (i < bytes.length) {\n    var c = bytes[i++];\n    // 0xxx xxxx\n    if (c >> 7 === 0) {\n      result += String.fromCharCode(c);\n      continue;\n    }\n    // Multibyte; how many bytes left for this character?\n    var extraLength = null;\n    var overlongMask = null;\n    // 110x xxxx 10xx xxxx\n    if ((c & 0xe0) === 0xc0) {\n      extraLength = 1;\n      overlongMask = 0x7f;\n      // 1110 xxxx 10xx xxxx 10xx xxxx\n    } else if ((c & 0xf0) === 0xe0) {\n      extraLength = 2;\n      overlongMask = 0x7ff;\n      // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n    } else if ((c & 0xf8) === 0xf0) {\n      extraLength = 3;\n      overlongMask = 0xffff;\n    } else {\n      if (!ignoreErrors) {\n        if ((c & 0xc0) === 0x80) {\n          throw new Error('invalid utf8 byte sequence; unexpected continuation byte');\n        }\n        throw new Error('invalid utf8 byte sequence; invalid prefix');\n      }\n      continue;\n    }\n    // Do we have enough bytes in our data?\n    if (i + extraLength > bytes.length) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; too short');\n      }\n      // If there is an invalid unprocessed byte, skip continuation bytes\n      for (; i < bytes.length; i++) {\n        if (bytes[i] >> 6 !== 0x02) {\n          break;\n        }\n      }\n      continue;\n    }\n    // Remove the length prefix from the char\n    var res = c & (1 << 8 - extraLength - 1) - 1;\n    for (var j = 0; j < extraLength; j++) {\n      var nextChar = bytes[i];\n      // Invalid continuation byte\n      if ((nextChar & 0xc0) != 0x80) {\n        res = null;\n        break;\n      }\n      ;\n      res = res << 6 | nextChar & 0x3f;\n      i++;\n    }\n    if (res === null) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; invalid continuation byte');\n      }\n      continue;\n    }\n    // Check for overlong seuences (more bytes than needed)\n    if (res <= overlongMask) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; overlong');\n      }\n      continue;\n    }\n    // Maximum code point\n    if (res > 0x10ffff) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; out-of-range');\n      }\n      continue;\n    }\n    // Reserved for UTF-16 surrogate halves\n    if (res >= 0xd800 && res <= 0xdfff) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; utf-16 surrogate');\n      }\n      continue;\n    }\n    if (res <= 0xffff) {\n      result += String.fromCharCode(res);\n      continue;\n    }\n    res -= 0x10000;\n    result += String.fromCharCode((res >> 10 & 0x3ff) + 0xd800, (res & 0x3ff) + 0xdc00);\n  }\n  return result;\n}\nexports.toUtf8String = toUtf8String;\nfunction formatBytes32String(text) {\n  // Get the bytes\n  var bytes = toUtf8Bytes(text);\n  // Check we have room for null-termination\n  if (bytes.length > 31) {\n    throw new Error('bytes32 string must be less than 32 bytes');\n  }\n  // Zero-pad (implicitly null-terminates)\n  return bytes_1.hexlify(bytes_1.concat([bytes, constants_1.HashZero]).slice(0, 32));\n}\nexports.formatBytes32String = formatBytes32String;\nfunction parseBytes32String(bytes) {\n  var data = bytes_1.arrayify(bytes);\n  // Must be 32 bytes with a null-termination\n  if (data.length !== 32) {\n    throw new Error('invalid bytes32 - not 32 bytes long');\n  }\n  if (data[31] !== 0) {\n    throw new Error('invalid bytes32 string - no null terminator');\n  }\n  // Find the null termination\n  var length = 31;\n  while (data[length - 1] === 0) {\n    length--;\n  }\n  // Determine the string value\n  return toUtf8String(data.slice(0, length));\n}\nexports.parseBytes32String = parseBytes32String;","map":{"version":3,"names":["Object","defineProperty","exports","value","constants_1","require","errors_1","bytes_1","UnicodeNormalizationForm","toUtf8Bytes","str","form","current","checkNormalize","normalize","result","i","length","c","charCodeAt","push","c2","Error","arrayify","toUtf8String","bytes","ignoreErrors","String","fromCharCode","extraLength","overlongMask","res","j","nextChar","formatBytes32String","text","hexlify","concat","HashZero","slice","parseBytes32String","data"],"sources":["/home/peilunnn/Downloads/Internship Projects/gcp-dapp-auction/client/node_modules/truffle-interface-adapter/node_modules/ethers/utils/utf8.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar bytes_1 = require(\"./bytes\");\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\n;\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form) {\n    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n    if (form != UnicodeNormalizationForm.current) {\n        errors_1.checkNormalize();\n        str = str.normalize(form);\n    }\n    var result = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            var c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error('invalid utf-8 string');\n            }\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((c >> 18) | 0xf0);\n            result.push(((c >> 12) & 0x3f) | 0x80);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return bytes_1.arrayify(result);\n}\nexports.toUtf8Bytes = toUtf8Bytes;\n;\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction toUtf8String(bytes, ignoreErrors) {\n    bytes = bytes_1.arrayify(bytes);\n    var result = '';\n    var i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        var c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result += String.fromCharCode(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        var extraLength = null;\n        var overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if (!ignoreErrors) {\n                if ((c & 0xc0) === 0x80) {\n                    throw new Error('invalid utf8 byte sequence; unexpected continuation byte');\n                }\n                throw new Error('invalid utf8 byte sequence; invalid prefix');\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i + extraLength > bytes.length) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; too short');\n            }\n            // If there is an invalid unprocessed byte, skip continuation bytes\n            for (; i < bytes.length; i++) {\n                if (bytes[i] >> 6 !== 0x02) {\n                    break;\n                }\n            }\n            continue;\n        }\n        // Remove the length prefix from the char\n        var res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (var j = 0; j < extraLength; j++) {\n            var nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        if (res === null) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; invalid continuation byte');\n            }\n            continue;\n        }\n        // Check for overlong seuences (more bytes than needed)\n        if (res <= overlongMask) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; overlong');\n            }\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; out-of-range');\n            }\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; utf-16 surrogate');\n            }\n            continue;\n        }\n        if (res <= 0xffff) {\n            result += String.fromCharCode(res);\n            continue;\n        }\n        res -= 0x10000;\n        result += String.fromCharCode(((res >> 10) & 0x3ff) + 0xd800, (res & 0x3ff) + 0xdc00);\n    }\n    return result;\n}\nexports.toUtf8String = toUtf8String;\nfunction formatBytes32String(text) {\n    // Get the bytes\n    var bytes = toUtf8Bytes(text);\n    // Check we have room for null-termination\n    if (bytes.length > 31) {\n        throw new Error('bytes32 string must be less than 32 bytes');\n    }\n    // Zero-pad (implicitly null-terminates)\n    return bytes_1.hexlify(bytes_1.concat([bytes, constants_1.HashZero]).slice(0, 32));\n}\nexports.formatBytes32String = formatBytes32String;\nfunction parseBytes32String(bytes) {\n    var data = bytes_1.arrayify(bytes);\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) {\n        throw new Error('invalid bytes32 - not 32 bytes long');\n    }\n    if (data[31] !== 0) {\n        throw new Error('invalid bytes32 string - no null terminator');\n    }\n    // Find the null termination\n    var length = 31;\n    while (data[length - 1] === 0) {\n        length--;\n    }\n    // Determine the string value\n    return toUtf8String(data.slice(0, length));\n}\nexports.parseBytes32String = parseBytes32String;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}