{"ast":null,"code":"var pkgVersion = require(\"./package.json\").version;\nvar Ajv = require(\"ajv\");\nvar util = require(\"util\");\nvar contractObjectSchema = require(\"./spec/contract-object.spec.json\");\nvar networkObjectSchema = require(\"./spec/network-object.spec.json\");\nvar abiSchema = require(\"./spec/abi.spec.json\");\n\n/**\n * Property definitions for Contract Objects\n *\n * Describes canonical output properties as sourced from some \"dirty\" input\n * object. Describes normalization process to account for deprecated and/or\n * nonstandard keys and values.\n *\n * Maps (key -> property) where:\n *  - `key` is the top-level output key matching up with those in the schema\n *  - `property` is an object with optional values:\n *      - `sources`: list of sources (see below); default `key`\n *      - `transform`: function(value) -> transformed value; default x -> x\n *\n * Each source represents a means to select a value from dirty object.\n * Allows:\n *  - dot-separated (`.`) string, corresponding to path to value in dirty\n *    object\n *  - function(dirtyObj) -> (cleanValue | undefined)\n *\n * The optional `transform` parameter standardizes value regardless of source,\n * for purposes of ensuring data type and/or string schemas.\n */\n\n// helper that ensures abi's do not contain function signatures\nconst sanitizedValue = dirtyValueArray => {\n  let sanitizedValueArray = [];\n  dirtyValueArray.forEach(item => {\n    let sanitizedItem = Object.assign({}, item);\n    delete sanitizedItem.signature;\n    sanitizedValueArray.push(sanitizedItem);\n  });\n  return sanitizedValueArray;\n};\n\n// filter `signature` property from an event\nconst sanitizeEvent = dirtyEvent => Object.entries(dirtyEvent).reduce((acc, _ref) => {\n  let [property, value] = _ref;\n  return property === \"signature\" ? acc : Object.assign(acc, {\n    [property]: value\n  });\n}, {});\n\n// sanitize aggregrate events given a `network-object.spec.json#events` object\nconst sanitizeAllEvents = dirtyEvents => Object.entries(dirtyEvents).reduce((acc, _ref2) => {\n  let [property, event] = _ref2;\n  return Object.assign(acc, {\n    [property]: sanitizeEvent(event)\n  });\n}, {});\nvar properties = {\n  contractName: {\n    sources: [\"contractName\", \"contract_name\"]\n  },\n  abi: {\n    sources: [\"abi\", \"interface\"],\n    transform: function (value) {\n      if (typeof value === \"string\") {\n        try {\n          value = JSON.parse(value);\n        } catch (_) {\n          value = undefined;\n        }\n      }\n      if (Array.isArray(value)) {\n        return sanitizedValue(value);\n      }\n      return value;\n    }\n  },\n  metadata: {\n    sources: [\"metadata\"]\n  },\n  bytecode: {\n    sources: [\"bytecode\", \"binary\", \"unlinked_binary\", \"evm.bytecode.object\"],\n    transform: function (value) {\n      if (value && value.indexOf(\"0x\") !== 0) {\n        value = \"0x\" + value;\n      }\n      return value;\n    }\n  },\n  deployedBytecode: {\n    sources: [\"deployedBytecode\", \"runtimeBytecode\", \"evm.deployedBytecode.object\"],\n    transform: function (value) {\n      if (value && value.indexOf(\"0x\") !== 0) {\n        value = \"0x\" + value;\n      }\n      return value;\n    }\n  },\n  immutableReferences: {},\n  generatedSources: {},\n  deployedGeneratedSources: {},\n  sourceMap: {\n    transform: function (value) {\n      if (typeof value === \"string\") {\n        try {\n          return JSON.parse(value);\n        } catch (_) {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    },\n    sources: [\"sourceMap\", \"srcmap\", \"evm.bytecode.sourceMap\"]\n  },\n  deployedSourceMap: {\n    transform: function (value) {\n      if (typeof value === \"string\") {\n        try {\n          return JSON.parse(value);\n        } catch (_) {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    },\n    sources: [\"deployedSourceMap\", \"srcmapRuntime\", \"evm.deployedBytecode.sourceMap\"]\n  },\n  source: {},\n  sourcePath: {},\n  ast: {},\n  legacyAST: {},\n  compiler: {},\n  networks: {\n    /**\n     * Normalize a networks object. Currently this makes sure `events` are\n     * always sanitized and `links` is extracted when copying from\n     * a TruffleContract context object.\n     *\n     * @param {object} value - the target object\n     * @param {object | TruffleContract} obj - the context, or source object.\n     * @return {object} The normalized Network object\n     */\n    transform: function () {\n      let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      let obj = arguments.length > 1 ? arguments[1] : undefined;\n      // Sanitize value's events for known networks\n      Object.keys(value).forEach(networkId => {\n        if (value[networkId].events) {\n          value[networkId].events = sanitizeAllEvents(value[networkId].events);\n        }\n      });\n\n      // Set and sanitize the current networks property from the\n      // TruffleContract. Note: obj is a TruffleContract if it has\n      // `network_id` attribute\n      const networkId = obj.network_id;\n      if (networkId && value.hasOwnProperty(networkId)) {\n        value[networkId].links = obj.links;\n        value[networkId].events = sanitizeAllEvents(obj.events);\n      }\n      return value;\n    }\n  },\n  schemaVersion: {\n    sources: [\"schemaVersion\", \"schema_version\"]\n  },\n  updatedAt: {\n    sources: [\"updatedAt\", \"updated_at\"],\n    transform: function (value) {\n      if (typeof value === \"number\") {\n        value = new Date(value).toISOString();\n      }\n      return value;\n    }\n  },\n  networkType: {},\n  devdoc: {},\n  userdoc: {},\n  db: {}\n};\n\n/**\n * Construct a getter for a given key, possibly applying some post-retrieve\n * transformation on the resulting value.\n *\n * @return {Function} Accepting dirty object and returning value || undefined\n */\nfunction getter(key, transform) {\n  if (transform === undefined) {\n    transform = function (x) {\n      return x;\n    };\n  }\n  return function (obj) {\n    try {\n      return transform(obj[key]);\n    } catch (_) {\n      return undefined;\n    }\n  };\n}\n\n/**\n * Chains together a series of function(obj) -> value, passing resulting\n * returned value to next function in chain.\n *\n * Accepts any number of functions passed as arguments\n * @return {Function} Accepting initial object, returning end-of-chain value\n *\n * Assumes all intermediary values to be objects, with well-formed sequence\n * of operations.\n */\nfunction chain() {\n  var getters = Array.prototype.slice.call(arguments);\n  return function (obj) {\n    return getters.reduce(function (cur, get) {\n      return get(cur);\n    }, obj);\n  };\n}\n\n// Schema module\n//\n\nvar TruffleContractSchema = {\n  // Return a promise to validate a contract object\n  // - Resolves as validated `contractObj`\n  // - Rejects with list of errors from schema validator\n  validate: function (contractObj) {\n    var ajv = new Ajv({\n      verbose: true\n    });\n    ajv.addSchema(abiSchema);\n    ajv.addSchema(networkObjectSchema);\n    ajv.addSchema(contractObjectSchema);\n    if (ajv.validate(\"contract-object.spec.json\", contractObj)) {\n      return contractObj;\n    } else {\n      const message = `Schema validation failed. Errors:\\n\\n${ajv.errors.map(_ref3 => {\n        let {\n          keyword,\n          dataPath,\n          schemaPath,\n          params,\n          message,\n          data,\n          parentSchema\n        } = _ref3;\n        return util.format(\"%s (%s):\\n%s\\n\", message, keyword, util.inspect({\n          dataPath,\n          schemaPath,\n          params,\n          data,\n          parentSchema\n        }, {\n          depth: 5\n        }));\n      }).join(\"\\n\")}`;\n      const error = new Error(message);\n      error.errors = ajv.errors;\n      throw error;\n    }\n  },\n  // accepts as argument anything that can be turned into a contract object\n  // returns a contract object\n  normalize: function (objDirty, options) {\n    options = options || {};\n    var normalized = {};\n\n    // iterate over each property\n    Object.keys(properties).forEach(function (key) {\n      var property = properties[key];\n      var value; // normalized value || undefined\n\n      // either used the defined sources or assume the key will only ever be\n      // listed as its canonical name (itself)\n      var sources = property.sources || [key];\n\n      // iterate over sources until value is defined or end of list met\n      for (var i = 0; value === undefined && i < sources.length; i++) {\n        var source = sources[i];\n        // string refers to path to value in objDirty, split and chain\n        // getters\n        if (typeof source === \"string\") {\n          var traversals = source.split(\".\").map(function (k) {\n            return getter(k);\n          });\n          source = chain.apply(null, traversals);\n        }\n\n        // source should be a function that takes the objDirty and returns\n        // value or undefined\n        value = source(objDirty);\n      }\n\n      // run source-agnostic transform on value\n      // (e.g. make sure bytecode begins 0x)\n      if (property.transform) {\n        value = property.transform(value, objDirty);\n      }\n\n      // add resulting (possibly undefined) to normalized obj\n      normalized[key] = value;\n    });\n\n    // Copy x- options\n    Object.keys(objDirty).forEach(function (key) {\n      if (key.indexOf(\"x-\") === 0) {\n        normalized[key] = getter(key)(objDirty);\n      }\n    });\n\n    // update schema version\n    normalized.schemaVersion = pkgVersion;\n    if (options.validate) {\n      this.validate(normalized);\n    }\n    return normalized;\n  }\n};\nmodule.exports = TruffleContractSchema;","map":{"version":3,"names":["pkgVersion","require","version","Ajv","util","contractObjectSchema","networkObjectSchema","abiSchema","sanitizedValue","dirtyValueArray","sanitizedValueArray","forEach","item","sanitizedItem","Object","assign","signature","push","sanitizeEvent","dirtyEvent","entries","reduce","acc","property","value","sanitizeAllEvents","dirtyEvents","event","properties","contractName","sources","abi","transform","JSON","parse","_","undefined","Array","isArray","metadata","bytecode","indexOf","deployedBytecode","immutableReferences","generatedSources","deployedGeneratedSources","sourceMap","deployedSourceMap","source","sourcePath","ast","legacyAST","compiler","networks","obj","keys","networkId","events","network_id","hasOwnProperty","links","schemaVersion","updatedAt","Date","toISOString","networkType","devdoc","userdoc","db","getter","key","x","chain","getters","prototype","slice","call","arguments","cur","get","TruffleContractSchema","validate","contractObj","ajv","verbose","addSchema","message","errors","map","keyword","dataPath","schemaPath","params","data","parentSchema","format","inspect","depth","join","error","Error","normalize","objDirty","options","normalized","i","length","traversals","split","k","apply","module","exports"],"sources":["/home/peilunnn/Downloads/Internship Projects/gcp-dapp-auction/client/node_modules/@truffle/contract-schema/index.js"],"sourcesContent":["var pkgVersion = require(\"./package.json\").version;\nvar Ajv = require(\"ajv\");\nvar util = require(\"util\");\n\nvar contractObjectSchema = require(\"./spec/contract-object.spec.json\");\nvar networkObjectSchema = require(\"./spec/network-object.spec.json\");\nvar abiSchema = require(\"./spec/abi.spec.json\");\n\n/**\n * Property definitions for Contract Objects\n *\n * Describes canonical output properties as sourced from some \"dirty\" input\n * object. Describes normalization process to account for deprecated and/or\n * nonstandard keys and values.\n *\n * Maps (key -> property) where:\n *  - `key` is the top-level output key matching up with those in the schema\n *  - `property` is an object with optional values:\n *      - `sources`: list of sources (see below); default `key`\n *      - `transform`: function(value) -> transformed value; default x -> x\n *\n * Each source represents a means to select a value from dirty object.\n * Allows:\n *  - dot-separated (`.`) string, corresponding to path to value in dirty\n *    object\n *  - function(dirtyObj) -> (cleanValue | undefined)\n *\n * The optional `transform` parameter standardizes value regardless of source,\n * for purposes of ensuring data type and/or string schemas.\n */\n\n// helper that ensures abi's do not contain function signatures\nconst sanitizedValue = dirtyValueArray => {\n  let sanitizedValueArray = [];\n  dirtyValueArray.forEach(item => {\n    let sanitizedItem = Object.assign({}, item);\n    delete sanitizedItem.signature;\n    sanitizedValueArray.push(sanitizedItem);\n  });\n  return sanitizedValueArray;\n};\n\n// filter `signature` property from an event\nconst sanitizeEvent = dirtyEvent =>\n  Object.entries(dirtyEvent).reduce(\n    (acc, [property, value]) =>\n      property === \"signature\"\n        ? acc\n        : Object.assign(acc, { [property]: value }),\n    {}\n  );\n\n// sanitize aggregrate events given a `network-object.spec.json#events` object\nconst sanitizeAllEvents = dirtyEvents =>\n  Object.entries(dirtyEvents).reduce(\n    (acc, [property, event]) =>\n      Object.assign(acc, { [property]: sanitizeEvent(event) }),\n    {}\n  );\n\nvar properties = {\n  contractName: {\n    sources: [\"contractName\", \"contract_name\"]\n  },\n  abi: {\n    sources: [\"abi\", \"interface\"],\n    transform: function (value) {\n      if (typeof value === \"string\") {\n        try {\n          value = JSON.parse(value);\n        } catch (_) {\n          value = undefined;\n        }\n      }\n      if (Array.isArray(value)) {\n        return sanitizedValue(value);\n      }\n      return value;\n    }\n  },\n  metadata: {\n    sources: [\"metadata\"]\n  },\n  bytecode: {\n    sources: [\"bytecode\", \"binary\", \"unlinked_binary\", \"evm.bytecode.object\"],\n    transform: function (value) {\n      if (value && value.indexOf(\"0x\") !== 0) {\n        value = \"0x\" + value;\n      }\n      return value;\n    }\n  },\n  deployedBytecode: {\n    sources: [\n      \"deployedBytecode\",\n      \"runtimeBytecode\",\n      \"evm.deployedBytecode.object\"\n    ],\n    transform: function (value) {\n      if (value && value.indexOf(\"0x\") !== 0) {\n        value = \"0x\" + value;\n      }\n      return value;\n    }\n  },\n  immutableReferences: {},\n  generatedSources: {},\n  deployedGeneratedSources: {},\n  sourceMap: {\n    transform: function (value) {\n      if (typeof value === \"string\") {\n        try {\n          return JSON.parse(value);\n        } catch (_) {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    },\n    sources: [\"sourceMap\", \"srcmap\", \"evm.bytecode.sourceMap\"]\n  },\n  deployedSourceMap: {\n    transform: function (value) {\n      if (typeof value === \"string\") {\n        try {\n          return JSON.parse(value);\n        } catch (_) {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    },\n    sources: [\n      \"deployedSourceMap\",\n      \"srcmapRuntime\",\n      \"evm.deployedBytecode.sourceMap\"\n    ]\n  },\n  source: {},\n  sourcePath: {},\n  ast: {},\n  legacyAST: {},\n  compiler: {},\n  networks: {\n    /**\n     * Normalize a networks object. Currently this makes sure `events` are\n     * always sanitized and `links` is extracted when copying from\n     * a TruffleContract context object.\n     *\n     * @param {object} value - the target object\n     * @param {object | TruffleContract} obj - the context, or source object.\n     * @return {object} The normalized Network object\n     */\n    transform: function (value = {}, obj) {\n      // Sanitize value's events for known networks\n      Object.keys(value).forEach(networkId => {\n        if (value[networkId].events) {\n          value[networkId].events = sanitizeAllEvents(value[networkId].events);\n        }\n      });\n\n      // Set and sanitize the current networks property from the\n      // TruffleContract. Note: obj is a TruffleContract if it has\n      // `network_id` attribute\n      const networkId = obj.network_id;\n      if (networkId && value.hasOwnProperty(networkId)) {\n        value[networkId].links = obj.links;\n        value[networkId].events = sanitizeAllEvents(obj.events);\n      }\n\n      return value;\n    }\n  },\n  schemaVersion: {\n    sources: [\"schemaVersion\", \"schema_version\"]\n  },\n  updatedAt: {\n    sources: [\"updatedAt\", \"updated_at\"],\n    transform: function (value) {\n      if (typeof value === \"number\") {\n        value = new Date(value).toISOString();\n      }\n      return value;\n    }\n  },\n  networkType: {},\n  devdoc: {},\n  userdoc: {},\n  db: {}\n};\n\n/**\n * Construct a getter for a given key, possibly applying some post-retrieve\n * transformation on the resulting value.\n *\n * @return {Function} Accepting dirty object and returning value || undefined\n */\nfunction getter(key, transform) {\n  if (transform === undefined) {\n    transform = function (x) {\n      return x;\n    };\n  }\n\n  return function (obj) {\n    try {\n      return transform(obj[key]);\n    } catch (_) {\n      return undefined;\n    }\n  };\n}\n\n/**\n * Chains together a series of function(obj) -> value, passing resulting\n * returned value to next function in chain.\n *\n * Accepts any number of functions passed as arguments\n * @return {Function} Accepting initial object, returning end-of-chain value\n *\n * Assumes all intermediary values to be objects, with well-formed sequence\n * of operations.\n */\nfunction chain() {\n  var getters = Array.prototype.slice.call(arguments);\n  return function (obj) {\n    return getters.reduce(function (cur, get) {\n      return get(cur);\n    }, obj);\n  };\n}\n\n// Schema module\n//\n\nvar TruffleContractSchema = {\n  // Return a promise to validate a contract object\n  // - Resolves as validated `contractObj`\n  // - Rejects with list of errors from schema validator\n  validate: function (contractObj) {\n    var ajv = new Ajv({ verbose: true });\n    ajv.addSchema(abiSchema);\n    ajv.addSchema(networkObjectSchema);\n    ajv.addSchema(contractObjectSchema);\n    if (ajv.validate(\"contract-object.spec.json\", contractObj)) {\n      return contractObj;\n    } else {\n      const message = `Schema validation failed. Errors:\\n\\n${ajv.errors\n        .map(\n          ({\n            keyword,\n            dataPath,\n            schemaPath,\n            params,\n            message,\n            data,\n            parentSchema\n          }) =>\n            util.format(\n              \"%s (%s):\\n%s\\n\",\n              message,\n              keyword,\n              util.inspect(\n                {\n                  dataPath,\n                  schemaPath,\n                  params,\n                  data,\n                  parentSchema\n                },\n                { depth: 5 }\n              )\n            )\n        )\n        .join(\"\\n\")}`;\n      const error = new Error(message);\n      error.errors = ajv.errors;\n      throw error;\n    }\n  },\n\n  // accepts as argument anything that can be turned into a contract object\n  // returns a contract object\n  normalize: function (objDirty, options) {\n    options = options || {};\n    var normalized = {};\n\n    // iterate over each property\n    Object.keys(properties).forEach(function (key) {\n      var property = properties[key];\n      var value; // normalized value || undefined\n\n      // either used the defined sources or assume the key will only ever be\n      // listed as its canonical name (itself)\n      var sources = property.sources || [key];\n\n      // iterate over sources until value is defined or end of list met\n      for (var i = 0; value === undefined && i < sources.length; i++) {\n        var source = sources[i];\n        // string refers to path to value in objDirty, split and chain\n        // getters\n        if (typeof source === \"string\") {\n          var traversals = source.split(\".\").map(function (k) {\n            return getter(k);\n          });\n          source = chain.apply(null, traversals);\n        }\n\n        // source should be a function that takes the objDirty and returns\n        // value or undefined\n        value = source(objDirty);\n      }\n\n      // run source-agnostic transform on value\n      // (e.g. make sure bytecode begins 0x)\n      if (property.transform) {\n        value = property.transform(value, objDirty);\n      }\n\n      // add resulting (possibly undefined) to normalized obj\n      normalized[key] = value;\n    });\n\n    // Copy x- options\n    Object.keys(objDirty).forEach(function (key) {\n      if (key.indexOf(\"x-\") === 0) {\n        normalized[key] = getter(key)(objDirty);\n      }\n    });\n\n    // update schema version\n    normalized.schemaVersion = pkgVersion;\n\n    if (options.validate) {\n      this.validate(normalized);\n    }\n\n    return normalized;\n  }\n};\n\nmodule.exports = TruffleContractSchema;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}