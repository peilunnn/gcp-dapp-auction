{"ast":null,"code":"const debug = require(\"debug\")(\"contract:handlers\"); // eslint-disable-line no-unused-vars\nvar StatusError = require(\"./statuserror\");\nvar Utils = require(\"./utils\");\nvar Reason = require(\"./reason\");\n\n/*\n  Handlers for events emitted by `send` / `call` etc.\n */\nvar handlers = {\n  // ----------------------------------- Constants -------------------------------------------------\n\n  maxConfirmations: 24,\n  // Maximum number of confirmation web3 emits\n  defaultTimeoutBlocks: 50,\n  // Maximum number of blocks web3 will wait before abandoning tx\n  timeoutMessage: \"50 blocks\",\n  // Substring of web3 timeout error.\n\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Parses error message and determines if we should squash block timeout errors at user's request.\n   * @param  {Object} context execution state\n   * @param  {Object} error   error\n   * @return {Boolean}\n   */\n  ignoreTimeoutError: function (context, error) {\n    var timedOut = error.message && error.message.includes(handlers.timeoutMessage);\n    var shouldWait = context.contract && context.contract.timeoutBlocks && context.contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\n    return timedOut && shouldWait;\n  },\n  /**\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\n   * @param {Object}       context  execution state\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\n   */\n  setup: function (emitter, context) {\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context));\n    emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\n  },\n  // -----------------------------------  Handlers -------------------------------------------------\n  /**\n   * Error event handler. Emits error unless error is block timeout and user has\n   * specified we should wait longer\n   * @param  {Object} context   execution state\n   * @param  {Object} error     error\n   */\n  error: function (context, error) {\n    if (!handlers.ignoreTimeoutError(context, error)) {\n      context.promiEvent.eventEmitter.emit(\"error\", error);\n      this.removeListener(\"error\", handlers.error);\n    }\n  },\n  /**\n   * Transaction hash event handler. Attaches the hash to the context object\n   * so it can be attached to the contract instance after a deployment resolves.\n   * @param  {Object} context   execution state\n   * @param  {String} hash      transaction hash\n   */\n  hash: function (context, hash) {\n    context.transactionHash = hash;\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", hash);\n    this.removeListener(\"transactionHash\", handlers.hash);\n  },\n  confirmation: function (context, number, receipt) {\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt);\n\n    // Per web3: initial confirmation index is 0\n    if (number === handlers.maxConfirmations + 1) {\n      this.removeListener(\"confirmation\", handlers.confirmation);\n    }\n  },\n  /**\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\n   * @param  {Object} context   execution state\n   * @param  {Object} receipt   transaction receipt\n   */\n  receipt: async function (context, receipt) {\n    // keep around the raw (not decoded) logs in the raw logs field as a\n    // stopgap until we can get the ABI for all events, not just the current\n    // contract\n    receipt.rawLogs = receipt.logs;\n\n    // Decode logs, use as receipt.logs for ease of use.\n    try {\n      receipt.logs = receipt.logs ? Utils.decodeLogs.call(context.contract, receipt.logs) : [];\n    } catch (error) {\n      return context.promiEvent.reject(error);\n    }\n\n    // Emit receipt\n    context.promiEvent.eventEmitter.emit(\"receipt\", receipt);\n\n    // .new(): Exit early. We need the promiEvent to resolve a contract instance.\n    if (context.onlyEmitReceipt) {\n      context.receipt = receipt;\n      return;\n    }\n\n    // .method(): resolve/reject receipt in handler\n    if (receipt.status !== undefined && !receipt.status) {\n      var reason = await Reason.get(context.params, context.contract.web3);\n      var error = new StatusError(context.params, receipt.transactionHash, receipt, reason);\n      return context.promiEvent.reject(error);\n    }\n\n    // This object has some duplicate data but is backward compatible.\n    context.promiEvent.resolve({\n      tx: receipt.transactionHash,\n      receipt: receipt,\n      logs: receipt.logs\n    });\n    this.removeListener(\"receipt\", handlers.receipt);\n  }\n};\nmodule.exports = handlers;","map":{"version":3,"names":["debug","require","StatusError","Utils","Reason","handlers","maxConfirmations","defaultTimeoutBlocks","timeoutMessage","ignoreTimeoutError","context","error","timedOut","message","includes","shouldWait","contract","timeoutBlocks","setup","emitter","on","bind","hash","confirmation","receipt","promiEvent","eventEmitter","emit","removeListener","transactionHash","number","rawLogs","logs","decodeLogs","call","reject","onlyEmitReceipt","status","undefined","reason","get","params","web3","resolve","tx","module","exports"],"sources":["/home/peilunnn/Downloads/Internship Projects/gcp-dapp-auction/client/node_modules/truffle-contract/lib/handlers.js"],"sourcesContent":["const debug = require(\"debug\")(\"contract:handlers\"); // eslint-disable-line no-unused-vars\nvar StatusError = require(\"./statuserror\");\nvar Utils = require(\"./utils\");\nvar Reason = require(\"./reason\");\n\n/*\n  Handlers for events emitted by `send` / `call` etc.\n */\nvar handlers = {\n  // ----------------------------------- Constants -------------------------------------------------\n\n  maxConfirmations: 24, // Maximum number of confirmation web3 emits\n  defaultTimeoutBlocks: 50, // Maximum number of blocks web3 will wait before abandoning tx\n  timeoutMessage: \"50 blocks\", // Substring of web3 timeout error.\n\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Parses error message and determines if we should squash block timeout errors at user's request.\n   * @param  {Object} context execution state\n   * @param  {Object} error   error\n   * @return {Boolean}\n   */\n  ignoreTimeoutError: function(context, error) {\n    var timedOut =\n      error.message && error.message.includes(handlers.timeoutMessage);\n\n    var shouldWait =\n      context.contract &&\n      context.contract.timeoutBlocks &&\n      context.contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\n\n    return timedOut && shouldWait;\n  },\n\n  /**\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\n   * @param {Object}       context  execution state\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\n   */\n  setup: function(emitter, context) {\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context));\n    emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\n  },\n\n  // -----------------------------------  Handlers -------------------------------------------------\n  /**\n   * Error event handler. Emits error unless error is block timeout and user has\n   * specified we should wait longer\n   * @param  {Object} context   execution state\n   * @param  {Object} error     error\n   */\n  error: function(context, error) {\n    if (!handlers.ignoreTimeoutError(context, error)) {\n      context.promiEvent.eventEmitter.emit(\"error\", error);\n      this.removeListener(\"error\", handlers.error);\n    }\n  },\n\n  /**\n   * Transaction hash event handler. Attaches the hash to the context object\n   * so it can be attached to the contract instance after a deployment resolves.\n   * @param  {Object} context   execution state\n   * @param  {String} hash      transaction hash\n   */\n  hash: function(context, hash) {\n    context.transactionHash = hash;\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", hash);\n    this.removeListener(\"transactionHash\", handlers.hash);\n  },\n\n  confirmation: function(context, number, receipt) {\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt);\n\n    // Per web3: initial confirmation index is 0\n    if (number === handlers.maxConfirmations + 1) {\n      this.removeListener(\"confirmation\", handlers.confirmation);\n    }\n  },\n\n  /**\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\n   * @param  {Object} context   execution state\n   * @param  {Object} receipt   transaction receipt\n   */\n  receipt: async function(context, receipt) {\n    // keep around the raw (not decoded) logs in the raw logs field as a\n    // stopgap until we can get the ABI for all events, not just the current\n    // contract\n    receipt.rawLogs = receipt.logs;\n\n    // Decode logs, use as receipt.logs for ease of use.\n    try {\n      receipt.logs = receipt.logs\n        ? Utils.decodeLogs.call(context.contract, receipt.logs)\n        : [];\n    } catch (error) {\n      return context.promiEvent.reject(error);\n    }\n\n    // Emit receipt\n    context.promiEvent.eventEmitter.emit(\"receipt\", receipt);\n\n    // .new(): Exit early. We need the promiEvent to resolve a contract instance.\n    if (context.onlyEmitReceipt) {\n      context.receipt = receipt;\n      return;\n    }\n\n    // .method(): resolve/reject receipt in handler\n    if (receipt.status !== undefined && !receipt.status) {\n      var reason = await Reason.get(context.params, context.contract.web3);\n\n      var error = new StatusError(\n        context.params,\n        receipt.transactionHash,\n        receipt,\n        reason\n      );\n\n      return context.promiEvent.reject(error);\n    }\n\n    // This object has some duplicate data but is backward compatible.\n    context.promiEvent.resolve({\n      tx: receipt.transactionHash,\n      receipt: receipt,\n      logs: receipt.logs\n    });\n\n    this.removeListener(\"receipt\", handlers.receipt);\n  }\n};\n\nmodule.exports = handlers;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}